function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
    i,
    q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
    i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function isFunction(value) {
  return typeof value === 'function';
}

function createErrorClass(createImpl) {
  var _super = function (instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

var UnsubscriptionError = createErrorClass(function (_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
      return i + 1 + ") " + err.toString();
    }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
  };
});

function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

var Subscription = function () {
  function Subscription(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription.prototype.unsubscribe = function () {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription.prototype.add = function (teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription.prototype._hasParent = function (parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription.prototype._addParent = function (parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription.prototype._removeParent = function (parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription.prototype.remove = function (teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription) {
      teardown._removeParent(this);
    }
  };
  Subscription.EMPTY = function () {
    var empty = new Subscription();
    empty.closed = true;
    return empty;
  }();
  return Subscription;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: undefined,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

var timeoutProvider = {
  setTimeout: function (handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function (handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: undefined
};

function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function () {
    {
      throw err;
    }
  });
}

function noop() {}

function errorContext(cb) {
  {
    cb();
  }
}

var Subscriber = function (_super) {
  __extends(Subscriber, _super);
  function Subscriber(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber.create = function (next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber.prototype.next = function (value) {
    if (this.isStopped) ; else {
      this._next(value);
    }
  };
  Subscriber.prototype.error = function (err) {
    if (this.isStopped) ; else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber.prototype.complete = function () {
    if (this.isStopped) ; else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber.prototype.unsubscribe = function () {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber.prototype._next = function (value) {
    this.destination.next(value);
  };
  Subscriber.prototype._error = function (err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber.prototype._complete = function () {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function () {
  function ConsumerObserver(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver.prototype.next = function (value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver.prototype.error = function (err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver.prototype.complete = function () {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver;
}();
var SafeSubscriber = function (_super) {
  __extends(SafeSubscriber, _super);
  function SafeSubscriber(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
        error: error !== null && error !== void 0 ? error : undefined,
        complete: complete !== null && complete !== void 0 ? complete : undefined
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function () {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber;
}(Subscriber);
function handleUnhandledError(error) {
  {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

var observable = function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}();

function identity(x) {
  return x;
}

function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function (prev, fn) {
      return fn(prev);
    }, input);
  };
}

var Observable = function () {
  function Observable(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable.prototype.lift = function (operator) {
    var observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
  };
  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function () {
      var _a = _this,
        operator = _a.operator,
        source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable.prototype._trySubscribe = function (sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable.prototype.forEach = function (next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function (value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable.prototype._subscribe = function (subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable.prototype[observable] = function () {
    return this;
  };
  Observable.prototype.pipe = function () {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable.prototype.toPromise = function (promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var value;
      _this.subscribe(function (x) {
        return value = x;
      }, function (err) {
        return reject(err);
      }, function () {
        return resolve(value);
      });
    });
  };
  Observable.create = function (subscribe) {
    return new Observable(subscribe);
  };
  return Observable;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function (source) {
    if (hasLift(source)) {
      return source.lift(function (liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError('Unable to lift unknown Observable type');
  };
}

function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function (_super) {
  __extends(OperatorSubscriber, _super);
  function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function (value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function (err) {
      try {
        onError(err);
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function () {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber.prototype.unsubscribe = function () {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber;
}(Subscriber);

var ObjectUnsubscribedError = createErrorClass(function (_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = 'ObjectUnsubscribedError';
    this.message = 'object unsubscribed';
  };
});

var Subject = function (_super) {
  __extends(Subject, _super);
  function Subject() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject.prototype.lift = function (operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject.prototype._throwIfClosed = function () {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject.prototype.next = function (value) {
    var _this = this;
    errorContext(function () {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject.prototype.error = function (err) {
    var _this = this;
    errorContext(function () {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject.prototype.complete = function () {
    var _this = this;
    errorContext(function () {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject.prototype.unsubscribe = function () {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject.prototype, "observed", {
    get: function () {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject.prototype._trySubscribe = function (subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject.prototype._subscribe = function (subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject.prototype._innerSubscribe = function (subscriber) {
    var _this = this;
    var _a = this,
      hasError = _a.hasError,
      isStopped = _a.isStopped,
      observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function () {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject.prototype._checkFinalizedStatuses = function (subscriber) {
    var _a = this,
      hasError = _a.hasError,
      thrownError = _a.thrownError,
      isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject.prototype.asObservable = function () {
    var observable = new Observable();
    observable.source = this;
    return observable;
  };
  Subject.create = function (destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject;
}(Observable);
var AnonymousSubject = function (_super) {
  __extends(AnonymousSubject, _super);
  function AnonymousSubject(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject.prototype.next = function (value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject.prototype.error = function (err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject.prototype.complete = function () {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject.prototype._subscribe = function (subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject;
}(Subject);

var BehaviorSubject = function (_super) {
  __extends(BehaviorSubject, _super);
  function BehaviorSubject(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject.prototype, "value", {
    get: function () {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject.prototype._subscribe = function (subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject.prototype.getValue = function () {
    var _a = this,
      hasError = _a.hasError,
      thrownError = _a.thrownError,
      _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject.prototype.next = function (value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject;
}(Subject);

function isScheduler(value) {
  return value && isFunction(value.schedule);
}

function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : undefined;
}

var isArrayLike = function (x) {
  return x && typeof x.length === 'number' && typeof x !== 'function';
};

function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

function isInteropObservable(input) {
  return isFunction(input[observable]);
}

function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

function getSymbolIterator() {
  if (typeof Symbol !== 'function' || !Symbol.iterator) {
    return '@@iterator';
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function (_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1,, 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function (subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError('Provided object does not correctly implement Symbol.observable');
  });
}
function fromArrayLike(array) {
  return new Observable(function (subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function (subscriber) {
    promise.then(function (value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function (err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function (subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function (subscriber) {
    process(asyncIterable, subscriber).catch(function (err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function () {
    var value, e_2_1;
    return __generator(this, function (_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = {
            error: e_2_1
          };
          return [3, 11];
        case 6:
          _b.trys.push([6,, 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function () {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}

function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function (source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      return executeSchedule(subscriber, scheduler, function () {
        return subscriber.next(value);
      }, delay);
    }, function () {
      return executeSchedule(subscriber, scheduler, function () {
        return subscriber.complete();
      }, delay);
    }, function (err) {
      return executeSchedule(subscriber, scheduler, function () {
        return subscriber.error(err);
      }, delay);
    }));
  });
}

function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function (source, subscriber) {
    subscriber.add(scheduler.schedule(function () {
      return source.subscribe(subscriber);
    }, delay));
  });
}

function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

function scheduleArray(input, scheduler) {
  return new Observable(function (subscriber) {
    var i = 0;
    return scheduler.schedule(function () {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

function scheduleIterable(input, scheduler) {
  return new Observable(function (subscriber) {
    var iterator$1;
    executeSchedule(subscriber, scheduler, function () {
      iterator$1 = input[iterator]();
      executeSchedule(subscriber, scheduler, function () {
        var _a;
        var value;
        var done;
        try {
          _a = iterator$1.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function () {
      return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
    };
  });
}

function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error('Iterable cannot be null');
  }
  return new Observable(function (subscriber) {
    executeSchedule(subscriber, scheduler, function () {
      var iterator = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function () {
        iterator.next().then(function (result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

function map(project, thisArg) {
  return operate(function (source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function () {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function (value) {
    return active < concurrent ? doInnerSub(value) : buffer.push(value);
  };
  var doInnerSub = function (value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function (innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function () {
      innerComplete = true;
    }, undefined, function () {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function () {
            var bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function () {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function () {
    isComplete = true;
    checkComplete();
  }));
  return function () {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function (a, i) {
      return map(function (b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === 'number') {
    concurrent = resultSelector;
  }
  return operate(function (source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

function catchError(selector) {
  return operate(function (source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function (source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function () {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}

function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

function skipWhile(predicate) {
  return operate(function (source, subscriber) {
    var taking = false;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
    }));
  });
}

function switchMap(project, resultSelector) {
  return operate(function (source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function () {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function (innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function () {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function () {
      isComplete = true;
      checkComplete();
    }));
  });
}

function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? {
    next: observerOrNext,
    error: error,
    complete: complete
  } : observerOrNext;
  return tapObserver ? operate(function (source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function (value) {
      var _a;
      (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
      subscriber.next(value);
    }, function () {
      var _a;
      isUnsub = false;
      (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      subscriber.complete();
    }, function (err) {
      var _a;
      isUnsub = false;
      (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
      subscriber.error(err);
    }, function () {
      var _a, _b;
      if (isUnsub) {
        (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

/*
 * A pure JavaScript implementation of RIPEMD128 using Uint8Array as input/output.
 * By Feng Dihai <fengdh@gmail.com>, 2015/07/09
 *
 * Based on coiscir/jsdigest (https://github.com/coiscir/jsdigest/blob/master/src/hash/ripemd128.js)
 *
 * ripemd128.js is free software released under terms of the MIT License.
 * You can get a copy on http://opensource.org/licenses/MIT.
 *
 *
 * RIPEMD-128 (c) 1996 Hans Dobbertin, Antoon Bosselaers, and Bart Preneel
 */

// convert array of number to Uint32Array
function asUint32Array(arr) {
  return new Uint32Array(arr);
}

// concat 2 typed array
function concat(a, b) {
  var c = new a.constructor(a.length + b.length);
  c.set(a);
  c.set(b, a.length);
  return c;
}

// swap high and low bits of a 32-bit int.
function rotl(x, n) {
  return x >>> 32 - n | x << n;
}
var S = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  // round 1
  [7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12],
  // round 2
  [11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5],
  // round 3
  [11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12],
  // round 4
  [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6],
  // parallel round 1
  [9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11],
  // parallel round 2
  [9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5],
  // parallel round 3
  [15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8] // parallel round 4
  ].map(asUint32Array),
  X = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
  // round 1
  [7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8],
  // round 2
  [3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12],
  // round 3
  [1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2],
  // round 4
  [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12],
  // parallel round 1
  [6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2],
  // parallel round 2
  [15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13],
  // parallel round 3
  [8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14] // parallel round 4
  ].map(asUint32Array),
  K = asUint32Array([0x00000000,
  // FF
  0x5a827999,
  // GG
  0x6ed9eba1,
  // HH
  0x8f1bbcdc,
  // II
  0x50a28be6,
  // III
  0x5c4dd124,
  // HHH
  0x6d703ef3,
  // GGG
  0x00000000 // FFF
  ]),
  F = [function (x, y, z) {
    return x ^ y ^ z;
  }, function (x, y, z) {
    return x & y | ~x & z;
  }, function (x, y, z) {
    return (x | ~y) ^ z;
  }, function (x, y, z) {
    return x & z | y & ~z;
  }];
function ripemd128(data) {
  var aa,
    bb,
    cc,
    dd,
    aaa,
    bbb,
    ccc,
    ddd,
    i,
    l,
    r,
    rr,
    t,
    tmp,
    x,
    hash = new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]),
    bytes = data.length;
  var padding = new Uint8Array((bytes % 64 < 56 ? 56 : 120) - bytes % 64);
  // @ts-ignore
  padding[0] = [0x80];
  data = new Uint32Array(concat(data, padding).buffer);

  // ending with check bits (= little endian 64-bit int, 8 * data.length)
  bytes = bytes << 3;
  x = concat(data, [bytes, bytes >> 31 >> 1]);
  // update hash
  for (i = 0, t = 0, l = x.length; i < l; i += 16, t = 0) {
    aa = aaa = hash[0];
    bb = bbb = hash[1];
    cc = ccc = hash[2];
    dd = ddd = hash[3];
    for (; t < 64; ++t) {
      r = ~~(t / 16);
      aa = rotl(aa + F[r](bb, cc, dd) + x[i + X[r][t % 16]] + K[r], S[r][t % 16]);
      tmp = dd;
      dd = cc;
      cc = bb;
      bb = aa;
      aa = tmp;
    }
    for (; t < 128; ++t) {
      r = ~~(t / 16);
      rr = ~~((63 - t % 64) / 16);
      aaa = rotl(aaa + F[rr](bbb, ccc, ddd) + x[i + X[r][t % 16]] + K[r], S[r][t % 16]);
      tmp = ddd;
      ddd = ccc;
      ccc = bbb;
      bbb = aaa;
      aaa = tmp;
    }
    ddd = hash[1] + cc + ddd;
    hash[1] = hash[2] + dd + aaa;
    hash[2] = hash[3] + aa + bbb;
    hash[3] = hash[0] + bb + ccc;
    hash[0] = ddd;
  }
  return new Uint8Array(hash.buffer);
}

var getExtension = function getExtension(filename, defaultExt) {
  return filename ? /(?:\.([^.]+))?$/.exec(filename)[1] : defaultExt;
};
var parseXml = function parseXml(str) {
  return new DOMParser().parseFromString(str, 'text/xml');
};

/*
   * Decrypt encrypted data block of keyword index (attrs.Encrypted = "2").
   * @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#keyword-index-encryption
   * @param buf an ArrayBuffer containing source data
   * @param key an ArrayBuffer holding decryption key, which will be supplied to ripemd128() before decryption
   * @return an ArrayBuffer carrying decrypted data, occupying the same memory space of source buffer
   */
function decrypt(buf, key) {
  key = ripemd128(key);
  var _byte,
    keylen = key.length,
    prev = 0x36,
    i = 0,
    len = buf.length;
  for (; i < len; i++) {
    _byte = buf[i];
    _byte = _byte >> 4 | _byte << 4;
    _byte = _byte ^ prev ^ i & 0xFF ^ key[i % keylen];
    prev = buf[i];
    buf[i] = _byte;
  }
  return buf;
}
function conseq() {
  return arguments.length <= 0 ? undefined : arguments[0];
}

/**
 * Test if a value of dictionary attribute is true or not.
 */
function isTrue(v) {
  v = ((v || false) + '').toLowerCase();
  return v === 'yes' || v === 'true';
}

/**
 * Match the first element in list with given offset.
 */
function matchOffset(list, offset) {
  return list.some(function (el) {
    return el.offset === offset ? list = [el] : false;
  }) ? list : [];
}

var sliceFile = function sliceFile(file, offset, len) {
  var file$ = new BehaviorSubject(null);
  file$.subscribe(function () {
    var reader = new FileReader();
    reader.readAsArrayBuffer(file.slice(offset, len));
    reader.onload = function () {
      if (reader.result) {
        file$.next(reader.result);
      }
    };
    reader.onloadend = function () {
      file$.complete();
    };
    reader.onerror = function (err) {
      file$.error(err);
    };
    reader.onabort = function () {
      file$.error("遇到意外退出");
    };
  });
  return file$.pipe(skipWhile(function (buffer) {
    return buffer === null || buffer === undefined || buffer.byteLength <= 0;
  }));
};

var _excluded$g = ["file", "next", "offset"];
var slice = function slice(pos, len) {
  return function (source$) {
    return new Observable(function (observer) {
      return source$.pipe(mergeMap(function (_ref) {
        var file = _ref.file,
          _ref$next = _ref.next,
          next = _ref$next === void 0 ? 0 : _ref$next,
          _ref$offset = _ref.offset,
          offset = _ref$offset === void 0 ? 0 : _ref$offset,
          rest = _objectWithoutProperties(_ref, _excluded$g);
        var start = typeof pos !== 'undefined' ? pos : offset;
        var size = len ? len + next : next;
        var subject$ = sliceFile(file, start, start + size);
        return subject$.pipe(map(function (buffer) {
          return Object.assign(_objectSpread2({
            file: file,
            next: next,
            offset: offset
          }, rest), {
            buffer: buffer,
            offset: start + size
          });
        }));
      })).subscribe({
        next: function next(res) {
          observer.next(res);
        }
      });
    });
  };
};

/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* number of distance codes */

const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) =>
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
const copy_block = (s, buf, len, header) =>
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) =>
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) =>
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let lx = 0;         /* running index in l_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) =>
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) =>
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) =>
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let black_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) =>
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) =>
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //let out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
};

var _tr_init_1  = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1  = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const rank = (f) => {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};


/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
const deflate_stored = (s, flush) => {

  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  let max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    const max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
};

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


const deflateResetKeep = (strm) => {

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH$2;
  _tr_init(s);
  return Z_OK$3;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$2; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR$2; }
  strm.state.gzhead = head;
  return Z_OK$3;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$2);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};


const deflate$2 = (strm, flush) => {

  let beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }

  const s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }

  s.strm = strm; /* just in case */
  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
    let bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH$3) { return Z_OK$3; }
  if (s.wrap <= 0) { return Z_STREAM_END$3; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};


const deflateEnd = (strm) => {

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$2;
  }

  const status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR$2);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR$2;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$2.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 30;       /* got a data error -- remain here until reset */
const TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
  let base_index = 0;
//  let shoextra;    /* extra bits table to use */
  let end;                    /* use base and extra for symbol > end */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;
  let extra_index = 0;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 1;       /* i: waiting for magic header */
const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
const    TIME = 3;       /* i: waiting for modification time (gzip) */
const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
const    NAME = 7;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
const    HCRC = 9;       /* i: waiting for header crc (gzip) */
const    DICTID = 10;    /* i: waiting for dictionary check value */
const    DICT = 11;      /* waiting for inflateSetDictionary() call */
const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 14;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 18;   /* i: waiting for code length code lengths */
const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
const            LEN = 21;       /* i: waiting for length/lit/eob code */
const            LENEXT = 22;    /* i: waiting for length extra bits */
const            DIST = 23;      /* i: waiting for distance code */
const            DISTEXT = 24;   /* i: waiting for distance extra bits */
const            MATCH = 25;     /* o: waiting for output space to copy string */
const            LIT = 26;       /* o: waiting for output space to write literal */
const    CHECK = 27;     /* i: waiting for 32-bit check value */
const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 29;      /* finished check, done -- remain here until reset */
const    BAD = 30;       /* got a data error -- remain here until reset */
const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateResetKeep = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};


const inflateReset = (strm) => {

  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;

var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1,
	constants: constants
};

const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;

/*
 * minilzo-js
 * JavaScript port of minilzo by Alistair Braidwood
 *
 *
 * This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License as
 *  published by the Free Software Foundation; either version 2 of
 *  the License, or (at your option) any later version.
 *
 * You should have received a copy of the GNU General Public License
 *  along with the minilzo-js library; see the file COPYING.
 *  If not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

/*
 * original minilzo.c by:
 *
 * Markus F.X.J. Oberhumer
 * <markus@oberhumer.com>
 * http://www.oberhumer.com/opensource/lzo/
 */

/*
 * NOTE:
 *   the full LZO package can be found at
 *   http://www.oberhumer.com/opensource/lzo/
 */

var lzo = function () {
  var _lzo1x = function _lzo1x() {};
  _lzo1x.prototype = {
    blockSize: 4096,
    OK: 0,
    INPUT_OVERRUN: -4,
    OUTPUT_OVERRUN: -5,
    LOOKBEHIND_OVERRUN: -6,
    EOF_FOUND: -999,
    buf: null,
    buf32: null,
    out: null,
    out32: null,
    cbl: 0,
    ip_end: 0,
    op_end: 0,
    t: 0,
    ip: 0,
    op: 0,
    m_pos: 0,
    skipToFirstLiteralFun: false,
    extendBuffer: function extendBuffer() {
      var newBuffer = new Uint8Array(this.cbl + this.blockSize);
      newBuffer.set(this.out);
      this.out = newBuffer;
      this.out32 = new Uint32Array(this.out.buffer);
      this.state.outputBuffer = this.out;
      this.cbl = this.out.length;
    },
    match_next: function match_next() {
      // if (op_end - op < t) return OUTPUT_OVERRUN;
      // if (ip_end - ip < t+3) return INPUT_OVERRUN;

      while (this.op + 3 > this.cbl) {
        this.extendBuffer();
      }
      this.out[this.op++] = this.buf[this.ip++];
      if (this.t > 1) {
        this.out[this.op++] = this.buf[this.ip++];
        if (this.t > 2) {
          this.out[this.op++] = this.buf[this.ip++];
        }
      }
      this.t = this.buf[this.ip++];
    },
    match_done: function match_done() {
      this.t = this.buf[this.ip - 2] & 3;
      return this.t;
    },
    copy_match: function copy_match() {
      this.t += 2;
      while (this.op + this.t > this.cbl) {
        this.extendBuffer();
      }
      if (this.t > 4 && this.op % 4 === this.m_pos % 4) {
        while (this.op % 4 > 0) {
          this.out[this.op++] = this.out[this.m_pos++];
          this.t--;
        }
        while (this.t > 4) {
          this.out32[0 | this.op / 4] = this.out32[0 | this.m_pos / 4];
          this.op += 4;
          this.m_pos += 4;
          this.t -= 4;
        }
      }
      do {
        this.out[this.op++] = this.out[this.m_pos++];
      } while (--this.t > 0);
    },
    copy_from_buf: function copy_from_buf() {
      while (this.op + this.t > this.cbl) {
        this.extendBuffer();
      }
      if (this.t > 4 && this.op % 4 === this.ip % 4) {
        while (this.op % 4 > 0) {
          this.out[this.op++] = this.buf[this.ip++];
          this.t--;
        }
        while (this.t > 4) {
          this.out32[0 | this.op / 4] = this.buf32[0 | this.ip / 4];
          this.op += 4;
          this.ip += 4;
          this.t -= 4;
        }
      }
      do {
        this.out[this.op++] = this.buf[this.ip++];
      } while (--this.t > 0);
    },
    match: function match() {
      for (;;) {
        if (this.t >= 64) {
          this.m_pos = this.op - 1;
          this.m_pos -= this.t >> 2 & 7;
          this.m_pos -= this.buf[this.ip++] << 3;
          this.t = (this.t >> 5) - 1;

          // if ( m_pos < out || m_pos >= op) return LOOKBEHIND_OVERRUN;
          // if (op_end - op < t+3-1) return OUTPUT_OVERRUN;

          this.copy_match();
          if (this.match_done() === 0) {
            break;
          } else {
            this.match_next();
            continue;
          }
        } else if (this.t >= 32) {
          this.t &= 31;
          if (this.t === 0) {
            while (this.buf[this.ip] === 0) {
              this.t += 255;
              this.ip++;
              // if (t > -511) return OUTPUT_OVERRUN;
              // if (ip_end - ip < 1) return INPUT_OVERRUN;
            }

            this.t += 31 + this.buf[this.ip++];
            // if (ip_end - ip < 2) return INPUT_OVERRUN;
          }

          this.m_pos = this.op - 1;
          this.m_pos -= (this.buf[this.ip] >> 2) + (this.buf[this.ip + 1] << 6);
          this.ip += 2;
        } else if (this.t >= 16) {
          this.m_pos = this.op;
          this.m_pos -= (this.t & 8) << 11;
          this.t &= 7;
          if (this.t === 0) {
            while (this.buf[this.ip] === 0) {
              this.t += 255;
              this.ip++;
              // if (t > -511) return OUTPUT_OVERRUN;
              // if (ip_end - ip < 1) return INPUT_OVERRUN;
            }

            this.t += 7 + this.buf[this.ip++];
            // if (ip_end - ip < 2) return INPUT_OVERRUN;
          }

          this.m_pos -= (this.buf[this.ip] >> 2) + (this.buf[this.ip + 1] << 6);
          this.ip += 2;
          if (this.m_pos === this.op) {
            this.state.outputBuffer = this.state.outputBuffer.subarray(0, this.op);
            return this.EOF_FOUND;
          }
          this.m_pos -= 0x4000;
        } else {
          this.m_pos = this.op - 1;
          this.m_pos -= this.t >> 2;
          this.m_pos -= this.buf[this.ip++] << 2;

          // if (m_pos < out || m_pos >= op) return LOOKBEHIND_OVERRUN;
          // if (op_end - op < 2) return OUTPUT_OVERRUN;
          while (this.op + 2 > this.cbl) {
            this.extendBuffer();
          }
          this.out[this.op++] = this.out[this.m_pos++];
          this.out[this.op++] = this.out[this.m_pos];
          if (this.match_done() === 0) {
            break;
          } else {
            this.match_next();
            continue;
          }
        }

        // if (m_pos < out || m_pos >= op) return LOOKBEHIND_OVERRUN;
        // if (op_end - op < t+3-1) return OUTPUT_OVERRUN;

        this.copy_match();
        if (this.match_done() === 0) {
          break;
        }
        this.match_next();
      }
      return this.OK;
    },
    decompress: function decompress(state) {
      this.state = state;
      this.buf = this.state.inputBuffer;
      var buf_4b = new Uint8Array(this.buf.length + (4 - this.buf.length % 4));
      buf_4b.set(this.buf);
      this.buf32 = new Uint32Array(buf_4b.buffer);
      this.out = new Uint8Array(this.buf.length + (this.blockSize - this.buf.length % this.blockSize));
      this.out32 = new Uint32Array(this.out.buffer);
      this.cbl = this.out.length;
      this.state.outputBuffer = this.out;
      this.ip_end = this.buf.length;
      this.op_end = this.out.length;
      this.t = 0;
      this.ip = 0;
      this.op = 0;
      this.m_pos = 0;
      this.skipToFirstLiteralFun = false;
      var ret;
      // if (ip_end - ip < 1) return INPUT_OVERRUN;
      if (this.buf[this.ip] > 17) {
        this.t = this.buf[this.ip++] - 17;
        if (this.t < 4) {
          this.match_next();
          ret = this.match();
          if (ret !== this.OK) {
            return ret === this.EOF_FOUND ? this.OK : ret;
          }
        } else {
          // if (op_end - op < t) return OUTPUT_OVERRUN;
          // if (ip_end - ip < t+3) return INPUT_OVERRUN;
          this.copy_from_buf();
          this.skipToFirstLiteralFun = true;
        }
      }
      for (;;) {
        if (!this.skipToFirstLiteralFun) {
          // if (ip_end - ip < 3) return INPUT_OVERRUN;
          this.t = this.buf[this.ip++];
          if (this.t >= 16) {
            ret = this.match();
            if (ret !== this.OK) {
              return ret === this.EOF_FOUND ? this.OK : ret;
            }
            continue;
          }
          if (this.t === 0) {
            while (this.buf[this.ip] === 0) {
              this.t += 255;
              this.ip++;
              // if (t > 511) return INPUT_OVERRUN;
              // if (ip_end - ip < 1) return INPUT_OVERRUN;
            }

            this.t += 15 + this.buf[this.ip++];
          }
          // if (op_end - op < t+3) return OUTPUT_OVERRUN;
          // if (ip_end - ip < t+6) return INPUT_OVERRUN;

          this.t += 3;
          this.copy_from_buf();
        } else {
          this.skipToFirstLiteralFun = false;
        }
        this.t = this.buf[this.ip++];
        if (this.t < 16) {
          this.m_pos = this.op - (1 + 0x0800);
          this.m_pos -= this.t >> 2;
          this.m_pos -= this.buf[this.ip++] << 2;

          // if ( m_pos <  out || m_pos >= op) return LOOKBEHIND_OVERRUN;
          // if (op_end - op < 3) return OUTPUT_OVERRUN;
          while (this.op + 3 > this.cbl) {
            this.extendBuffer();
          }
          this.out[this.op++] = this.out[this.m_pos++];
          this.out[this.op++] = this.out[this.m_pos++];
          this.out[this.op++] = this.out[this.m_pos];
          if (this.match_done() === 0) {
            continue;
          } else {
            this.match_next();
          }
        }
        ret = this.match();
        if (ret !== this.OK) {
          return ret === this.EOF_FOUND ? this.OK : ret;
        }
      }
      return this.OK;
    },
    _compressCore: function _compressCore(in_len, ti) {
      var ip_start = this.ip;
      var ip_end = this.ip + in_len - 20;
      var ii = this.ip;
      this.ip += ti < 4 ? 4 - ti : 0;
      var m_pos;
      var m_off;
      var m_len;
      var dv_hi;
      var dv_lo;
      var dindex;
      this.ip += 1 + (this.ip - ii >> 5);
      for (;;) {
        if (this.ip >= ip_end) {
          break;
        }

        // dv = this.buf[this.ip] | (this.buf[this.ip + 1] << 8) | (this.buf[this.ip + 2] << 16) | (this.buf[this.ip + 3] << 24);
        // dindex = ((0x1824429d * dv) >> 18) & 16383;
        // The above code doesn't work in JavaScript due to a lack of 64 bit bitwise operations
        // Instead, use (optimised two's complement integer arithmetic)
        // Optimization is based on us only needing the high 16 bits of the lower 32 bit integer.
        dv_lo = this.buf[this.ip] | this.buf[this.ip + 1] << 8;
        dv_hi = this.buf[this.ip + 2] | this.buf[this.ip + 3] << 8;
        dindex = ((dv_lo * 0x429d >>> 16) + dv_hi * 0x429d + dv_lo * 0x1824 & 0xFFFF) >>> 2;
        m_pos = ip_start + this.dict[dindex];
        this.dict[dindex] = this.ip - ip_start;
        if ((dv_hi << 16) + dv_lo !== (this.buf[m_pos] | this.buf[m_pos + 1] << 8 | this.buf[m_pos + 2] << 16 | this.buf[m_pos + 3] << 24)) {
          this.ip += 1 + (this.ip - ii >> 5);
          continue;
        }
        ii -= ti;
        ti = 0;
        var t = this.ip - ii;
        if (t !== 0) {
          if (t <= 3) {
            this.out[this.op - 2] |= t;
            do {
              this.out[this.op++] = this.buf[ii++];
            } while (--t > 0);
          } else {
            if (t <= 18) {
              this.out[this.op++] = t - 3;
            } else {
              var tt = t - 18;
              this.out[this.op++] = 0;
              while (tt > 255) {
                tt -= 255;
                this.out[this.op++] = 0;
              }
              this.out[this.op++] = tt;
            }
            do {
              this.out[this.op++] = this.buf[ii++];
            } while (--t > 0);
          }
        }
        m_len = 4;

        // let skipTo_m_len_done = false;
        if (this.buf[this.ip + m_len] === this.buf[m_pos + m_len]) {
          do {
            m_len += 1;
            if (this.buf[this.ip + m_len] !== this.buf[m_pos + m_len]) {
              break;
            }
            m_len += 1;
            if (this.buf[this.ip + m_len] !== this.buf[m_pos + m_len]) {
              break;
            }
            m_len += 1;
            if (this.buf[this.ip + m_len] !== this.buf[m_pos + m_len]) {
              break;
            }
            m_len += 1;
            if (this.buf[this.ip + m_len] !== this.buf[m_pos + m_len]) {
              break;
            }
            m_len += 1;
            if (this.buf[this.ip + m_len] !== this.buf[m_pos + m_len]) {
              break;
            }
            m_len += 1;
            if (this.buf[this.ip + m_len] !== this.buf[m_pos + m_len]) {
              break;
            }
            m_len += 1;
            if (this.buf[this.ip + m_len] !== this.buf[m_pos + m_len]) {
              break;
            }
            m_len += 1;
            if (this.buf[this.ip + m_len] !== this.buf[m_pos + m_len]) {
              break;
            }
            if (this.ip + m_len >= ip_end) {
              // skipTo_m_len_done = true;
              break;
            }
          } while (this.buf[this.ip + m_len] === this.buf[m_pos + m_len]);
        }

        // if (!skipTo_m_len_done) {
        //     let inc = this.ctzl(this.buf[this.ip + m_len] ^ this.buf[m_pos + m_len]) >> 3;
        //     m_len += inc;
        // }

        m_off = this.ip - m_pos;
        this.ip += m_len;
        ii = this.ip;
        if (m_len <= 8 && m_off <= 0x0800) {
          m_off -= 1;
          this.out[this.op++] = m_len - 1 << 5 | (m_off & 7) << 2;
          this.out[this.op++] = m_off >> 3;
        } else if (m_off <= 0x4000) {
          m_off -= 1;
          if (m_len <= 33) {
            this.out[this.op++] = 32 | m_len - 2;
          } else {
            m_len -= 33;
            this.out[this.op++] = 32;
            while (m_len > 255) {
              m_len -= 255;
              this.out[this.op++] = 0;
            }
            this.out[this.op++] = m_len;
          }
          this.out[this.op++] = m_off << 2;
          this.out[this.op++] = m_off >> 6;
        } else {
          m_off -= 0x4000;
          if (m_len <= 9) {
            this.out[this.op++] = 16 | m_off >> 11 & 8 | m_len - 2;
          } else {
            m_len -= 9;
            this.out[this.op++] = 16 | m_off >> 11 & 8;
            while (m_len > 255) {
              m_len -= 255;
              this.out[this.op++] = 0;
            }
            this.out[this.op++] = m_len;
          }
          this.out[this.op++] = m_off << 2;
          this.out[this.op++] = m_off >> 6;
        }
      }
      return in_len - (ii - ip_start - ti);
    },
    compress: function compress(state) {
      this.state = state;
      this.ip = 0;
      this.buf = this.state.inputBuffer;
      var in_len = this.buf.length;
      var max_len = in_len + Math.ceil(in_len / 16) + 64 + 3;
      this.state.outputBuffer = new Uint8Array(max_len);
      this.out = this.state.outputBuffer;
      this.op = 0;
      this.dict = new Uint32Array(16384);
      var l = in_len;
      var t = 0;
      while (l > 20) {
        var ll = l <= 49152 ? l : 49152;
        if (t + ll >> 5 <= 0) {
          break;
        }
        this.dict = new Uint32Array(16384);
        var prev_ip = this.ip;
        t = this._compressCore(ll, t);
        this.ip = prev_ip + ll;
        l -= ll;
      }
      t += l;
      if (t > 0) {
        var ii = in_len - t;
        if (this.op === 0 && t <= 238) {
          this.out[this.op++] = 17 + t;
        } else if (t <= 3) {
          this.out[this.op - 2] |= t;
        } else if (t <= 18) {
          this.out[this.op++] = t - 3;
        } else {
          var tt = t - 18;
          this.out[this.op++] = 0;
          while (tt > 255) {
            tt -= 255;
            this.out[this.op++] = 0;
          }
          this.out[this.op++] = tt;
        }
        do {
          this.out[this.op++] = this.buf[ii++];
        } while (--t > 0);
      }
      this.out[this.op++] = 17;
      this.out[this.op++] = 0;
      this.out[this.op++] = 0;
      this.state.outputBuffer = this.out.subarray(0, this.op);
      return this.OK;
    }
  };
  var instance = new _lzo1x();
  return {
    compress: function compress(state) {
      return instance.compress(state);
    },
    decompress: function decompress(state) {
      return instance.decompress(state);
    }
  };
}();

/**
 * Regular expression to strip key if dictionary's "StripKey" attribute is true. 
 */
var REGEXP_STRIPKEY = {
  'mdx': /[()., '/\\@_-]()/g,
  'mdd': /([.][^.]*$)|[()., '/\\@_-]/g
};
var UNDEFINED = void 0;

var scanner = function scanner(buffer) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _ref.len;
    var v2 = _ref.v2,
    _ref$bpu = _ref.bpu,
    bpu = _ref$bpu === void 0 ? 1 : _ref$bpu,
    decoder = _ref.decoder,
    _ref$tail = _ref.tail,
    tail = _ref$tail === void 0 ? 0 : _ref$tail,
    searchTextLen = _ref.searchTextLen;
  var dv = new DataView(buffer);
  var _offset = 0;
  var methods = {
    forward: function forward(len) {
      return _offset += len;
    },
    offset: function offset() {
      return _offset;
    },
    readInt: function readInt() {
      var res = dv.getUint32(_offset, false);
      methods.forward(4);
      return res;
    },
    readNum: function readNum() {
      methods.forward(4);
      return methods.readInt();
    },
    readUint8: function readUint8() {
      return conseq(dv.getUint8(_offset), methods.forward(1));
    },
    readUint16: function readUint16() {
      return conseq(dv.getUint16(_offset, false), methods.forward(2));
    },
    checksum_v2: function checksum_v2() {
      _offset += 4;
    },
    readBlock: function readBlock(len, expectedBufSize, decryptor) {
      var comp_type = dv.getUint8(_offset);
      if (comp_type === 0) {
        if (v2) {
          methods.forward(8);
        }
        return methods;
      } else {
        _offset += 8;
        len -= 8;
        var tmp = new Uint8Array(buffer, _offset, len);
        if (decryptor) {
          var passkey = new Uint8Array(8);
          passkey.set(new Uint8Array(buffer, _offset - 4, 4));
          passkey.set([0x95, 0x36, 0x00, 0x00], 4);
          tmp = decryptor(tmp, passkey);
        }
        tmp = comp_type === 2 ? inflate_1(tmp) : lzo.decompress(tmp);
        methods.forward(len);
        return scanner(tmp.buffer, {
          len: tmp.length,
          v2: v2,
          bpu: bpu,
          decoder: decoder,
          tail: tail,
          searchTextLen: searchTextLen
        });
      }
    },
    readText: function readText() {
      var len = searchTextLen(dv, _offset);
      var res = conseq(decoder.decode(new Uint8Array(buffer, _offset, len)), methods.forward(len + bpu));
      return res;
    },
    readTextSized: function readTextSized(len) {
      len *= bpu;
      var res = decoder ? decoder.decode(new Uint8Array(buffer, _offset, len)) : '';
      methods.forward(len + tail);
      return res;
    },
    readShort: function readShort() {
      if (v2) {
        return methods.readUint16();
      } else {
        return methods.readUint8();
      }
    },
    readRaw: function readRaw(len) {
      return conseq(new Uint8Array(buffer, _offset, len), methods.forward(len === UNDEFINED ? buffer.byteLength - _offset : len));
    }
  };
  return Object.create(methods);
};

var _excluded$f = ["buffer", "next"];
var readHead = function readHead(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var buffer = _ref.buffer;
          _ref.next;
          var rest = _objectWithoutProperties(_ref, _excluded$f);
        var sca = scanner(buffer);
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          buffer: buffer,
          next: sca.readInt()
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var _excluded$e = ["buffer", "file", "next"];
var readHeader = function readHeader(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var buffer = _ref.buffer,
          file = _ref.file,
          _next = _ref.next,
          rest = _objectWithoutProperties(_ref, _excluded$e);
        var UTF_16LE = new TextDecoder('utf-16le');
        var header_str = UTF_16LE.decode(new Uint8Array(buffer, 0, _next)).replace(/\0$/, '');
        var xml = parseXml(header_str).querySelector('Dictionary, Library_Data').attributes;
        var attrs = {};
        for (var i = 0, item; i < xml.length; i++) {
          item = xml.item(i);
          attrs[item.nodeName] = item.nodeValue;
        }
        attrs.Encrypted = parseInt(attrs.Encrypted, 10) || 0;
        attrs.Encoding = attrs.Encoding || 'UTF-16';
        var isV2 = parseInt(attrs.GeneratedByEngineVersion, 10) >= 2.0;
        var bpu = attrs.Encoding === 'UTF-16' ? 2 : 1;
        var adaptKey = function adaptKey(key) {
          return key;
        };
        var ext = getExtension(file.name, 'mdx');
        var regexp = REGEXP_STRIPKEY[ext];
        if (isTrue(attrs.KeyCaseSensitive)) {
          adaptKey = isTrue(attrs.StripKey) ? function (key) {
            return key.replace(regexp, '$1');
          } : adaptKey;
        } else {
          adaptKey = isTrue(attrs.StripKey || (isV2 ? '' : 'yes')) ? function (key) {
            return key ? key.toLowerCase().replace(regexp, '$1') : key;
          } : function (key) {
            return key ? key.toLowerCase() : key;
          };
        }
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          next: _next,
          file: file,
          buffer: buffer,
          offset: _next + 4,
          v2: isV2,
          decryptors: attrs.Encrypted & 0x02 ? [false, decrypt] : [false, false],
          bpu: bpu,
          attrs: attrs,
          decoder: new TextDecoder(attrs.Encoding || 'UTF-16LE'),
          tail: isV2 ? bpu : 0,
          searchTextLen: attrs.Encoding === 'UTF-16' ? function (dv, offset) {
            offset = offset;
            var mark = offset;
            while (dv.getUint16(offset)) {
              offset += bpu;
            }
            return offset - mark;
          } : function (dv, offset) {
            offset = offset;
            var mark = offset;
            while (dv.getUint8(offset++)) {/* scan for NUL */}
            return offset - mark - 1;
          },
          adaptKey: adaptKey
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var _excluded$d = ["buffer", "file", "next", "offset"];
var readKeywordSummary = function readKeywordSummary(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var buffer = _ref.buffer,
          file = _ref.file,
          _ref$next = _ref.next,
          _next = _ref$next === void 0 ? 0 : _ref$next,
          offset = _ref.offset,
          rest = _objectWithoutProperties(_ref, _excluded$d);
        var sca = scanner(buffer);
        sca.forward(offset);
        var data = {
          num_blocks: sca.readNum(),
          num_entries: sca.readNum(),
          key_index_decomp_len: sca.readNum(),
          key_index_comp_len: sca.readNum(),
          key_blocks_len: sca.readNum(),
          chksum: sca.checksum_v2(),
          len: sca.offset() - _next
        };
        observer.next(_objectSpread2(_objectSpread2(_objectSpread2({}, rest), data), {}, {
          next: data.key_index_comp_len,
          file: file,
          offset: offset + data.len,
          buffer: buffer
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var _excluded$c = ["file", "offset", "key_blocks_len"],
  _excluded2 = ["buffer", "key_index_comp_len", "key_index_decomp_len", "decryptors", "searchTextLen", "num_blocks", "v2", "bpu", "decoder", "tail", "file"];
var readKeywordIndex = function readKeywordIndex(source$) {
  return new Observable(function (observer) {
    var subscription = source$.pipe(switchMap(function (_ref) {
      var file = _ref.file,
        offset = _ref.offset,
        key_blocks_len = _ref.key_blocks_len,
        rest = _objectWithoutProperties(_ref, _excluded$c);
      var subject$ = sliceFile(file, offset, offset + key_blocks_len);
      return subject$.pipe(map(function (buffer) {
        return Object.assign(_objectSpread2({
          file: file,
          offset: offset,
          key_blocks_len: key_blocks_len
        }, rest), {
          slicedKeyBlock: {
            buffer: buffer,
            offset: offset + key_blocks_len
          }
        });
      }), skipWhile(function (_ref2) {
        var slicedKeyBlock = _ref2.slicedKeyBlock;
        return slicedKeyBlock.buffer === null || slicedKeyBlock.buffer === undefined;
      }));
    })).subscribe({
      next: function next(_ref3) {
        var buffer = _ref3.buffer,
          key_index_comp_len = _ref3.key_index_comp_len,
          key_index_decomp_len = _ref3.key_index_decomp_len,
          _ref3$decryptors = _ref3.decryptors,
          decryptors = _ref3$decryptors === void 0 ? [false, false] : _ref3$decryptors,
          searchTextLen = _ref3.searchTextLen,
          num_blocks = _ref3.num_blocks,
          v2 = _ref3.v2,
          bpu = _ref3.bpu,
          decoder = _ref3.decoder,
          tail = _ref3.tail,
          file = _ref3.file,
          rest = _objectWithoutProperties(_ref3, _excluded2);
        var sca = scanner(buffer, {
          v2: v2,
          bpu: bpu,
          decoder: decoder,
          tail: tail,
          searchTextLen: searchTextLen
        }).readBlock(key_index_comp_len, key_index_decomp_len, decryptors[1]);
        var keywordIndex = Array(num_blocks);
        var offset = 0;
        for (var i = 0, size; i < num_blocks; i++) {
          keywordIndex[i] = {
            num_entries: conseq(sca.readNum(), size = sca.readShort()),
            first_word: conseq(sca.readTextSized(size), size = sca.readShort()),
            last_word: sca.readTextSized(size),
            comp_size: size = sca.readNum(),
            decomp_size: sca.readNum(),
            offset: offset,
            index: i
          };
          offset += size;
        }
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          file: file,
          buffer: buffer,
          key_index_comp_len: key_index_comp_len,
          key_index_decomp_len: key_index_decomp_len,
          decryptors: decryptors,
          searchTextLen: searchTextLen,
          num_blocks: num_blocks,
          v2: v2,
          bpu: bpu,
          decoder: decoder,
          tail: tail,
          keywordIndex: keywordIndex,
          offset: rest.offset + rest.key_blocks_len,
          pos: rest.offset + rest.key_blocks_len,
          next: 0
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var _excluded$b = ["buffer", "pos", "offset"];
var readRecordSummary = function readRecordSummary(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var buffer = _ref.buffer,
          pos = _ref.pos;
          _ref.offset;
          var rest = _objectWithoutProperties(_ref, _excluded$b);
        var sca = scanner(buffer);
        var record_summary = {
          num_blocks: sca.readNum(),
          num_entries: sca.readNum(),
          index_len: sca.readNum(),
          blocks_len: sca.readNum(),
          len: sca.offset()
        };
        record_summary.block_pos = pos + record_summary.index_len + record_summary.len;
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          record_summary: record_summary,
          offset: pos + record_summary.len,
          next: record_summary.index_len,
          buffer: buffer
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

/*
 * Create a Record Block Table object to load record block info from record section in mdx/mdd file.
 * Retrived data is stored in an Uint32Array which contains N pairs of (offset_comp, offset_decomp) value,
 * where N is number of record blocks.
 *
 * When looking up a given key for its definition:
 *   1. Search KEY_INDEX to locate keyword block containing the given key.
 *   2. Scanning the found keyword block to get its record offset and size.
 *   3. Search RECORD_BLOCK_TABLE to get record block containing the record.
 *   4. Load the found record block, using its offset and size to retrieve record content.
 *
 * @see https://github.com/zhansliu/writemdict/blob/master/fileformat.md#record-section
 */
function createRecordBlockTable() {
  var pos = 0,
    // current position
    arr; // backed Uint32Array
  return {
    // Allocate required ArrayBuffer for storing record block table, where len is number of record blocks.
    alloc: function alloc(len) {
      arr = new Uint32Array(len * 2);
    },
    // Store offset pair value (compressed & decompressed) for a record block
    // NOTE: offset_comp is absolute offset counted from start of mdx/mdd file.
    put: function put(offset_comp, offset_decomp) {
      if (arr) {
        arr[pos++] = offset_comp;
        arr[pos++] = offset_decomp;
      }
    },
    // Given offset of a keyword after decompression, return a record block info containing it, else undefined if not found.
    find: function find(keyAt) {
      var hi = (arr.length >> 1) - 1,
        lo = 0,
        i = lo + hi >> 1,
        val = arr[(i << 1) + 1];
      if (keyAt > arr[(hi << 1) + 1] || keyAt < 0) return;
      while (true) {
        if (hi - lo <= 1) {
          if (i < hi) {
            return {
              block_no: i,
              comp_offset: arr[i <<= 1],
              comp_size: arr[i + 2] - arr[i],
              decomp_offset: arr[i + 1],
              decomp_size: arr[i + 3] - arr[i + 1]
            };
          } else {
            return;
          }
        }
        keyAt < val ? hi = i : lo = i;
        i = lo + hi >> 1;
        val = arr[(i << 1) + 1];
      }
    },
    get: function get() {
      return arr;
    }
  };
}

var _excluded$a = ["buffer", "offset", "record_summary"];
var readRecordBlock = function readRecordBlock(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var buffer = _ref.buffer,
          offset = _ref.offset,
          record_summary = _ref.record_summary,
          rest = _objectWithoutProperties(_ref, _excluded$a);
        var sca = scanner(buffer);
        var size = record_summary.num_blocks;
        var recordIndex = Array(size);
        var pos0 = record_summary.block_pos;
        var pos1 = 0;
        var blockTable = createRecordBlockTable();
        blockTable.alloc(size + 1);
        for (var i = 0, rdx; i < size; i++) {
          recordIndex[i] = rdx = {
            comp_size: sca.readNum(),
            decomp_size: sca.readNum()
          };
          blockTable.put(pos0, pos1);
          pos0 += rdx.comp_size;
          pos1 += rdx.decomp_size;
        }
        blockTable.put(pos0, pos1);
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          blockTable: blockTable,
          recordIndex: recordIndex,
          buffer: buffer,
          offset: offset,
          record_summary: record_summary
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

function parse(file, ext) {
  var file$ = new BehaviorSubject({
    file: file
  });
  return file$.pipe(slice(0, 4), readHead, slice(4, 48), readHeader, readKeywordSummary, slice(), readKeywordIndex, slice(undefined, 32), readRecordSummary, slice(), readRecordBlock);
}

var reduce = function reduce(adaptKey, arr, phrase) {
  var len = arr.length;
  if (len > 1) {
    len = len >> 1;
    return phrase > adaptKey(arr[len - 1].last_word) ? reduce(adaptKey, arr.slice(len), phrase) : reduce(adaptKey, arr.slice(0, len), phrase);
  } else {
    return arr[0];
  }
};

var _excluded$9 = ["adaptKey", "keywordIndex"];
var seekVanguard = function seekVanguard(query) {
  return function (source$) {
    return new Observable(function (observer) {
      var subscription = source$.subscribe({
        next: function next(_ref) {
          var adaptKey = _ref.adaptKey,
            keywordIndex = _ref.keywordIndex,
            rest = _objectWithoutProperties(_ref, _excluded$9);
          var word = query.trim().toLowerCase();
          var phrase = adaptKey(word);
          var kdx = reduce(adaptKey, keywordIndex, phrase);
          // look back for the first record block containing keyword for the specified phrase
          if (phrase <= adaptKey(kdx.last_word)) {
            var index = kdx.index - 1,
              prev;
            while (prev = keywordIndex[index]) {
              if (adaptKey(prev.last_word) !== adaptKey(kdx.last_word)) {
                break;
              }
              kdx = prev;
              index--;
            }
          }
          observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
            kdx: kdx,
            phrase: phrase,
            adaptKey: adaptKey,
            keywordIndex: keywordIndex,
            query: query,
            word: word
          }));
        },
        error: function error(err) {
          return observer.error(err);
        },
        complete: function complete() {
          return observer.complete();
        }
      });
      return function () {
        subscription.unsubscribe();
      };
    });
  };
};

var _excluded$8 = ["cachedKeys", "kdx", "slicedKeyBlock"];
var loadKeys = function loadKeys(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var cachedKeys = _ref.cachedKeys,
          kdx = _ref.kdx,
          slicedKeyBlock = _ref.slicedKeyBlock,
          rest = _objectWithoutProperties(_ref, _excluded$8);
        if (cachedKeys && cachedKeys.pilot === kdx.first_word) {
          observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
            cachedKeys: cachedKeys,
            kdx: kdx
          }));
        } else {
          // todo get slicedKeyBlock's value
          observer.next(_objectSpread2(_objectSpread2(_objectSpread2({}, rest), slicedKeyBlock), {}, {
            cachedKeys: cachedKeys,
            kdx: kdx
          }));
        }
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var _excluded$7 = ["buffer", "kdx", "searchTextLen", "decoder", "bpu"];
var slicedKeyBlockThen = function slicedKeyBlockThen(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var buffer = _ref.buffer,
          _ref$kdx = _ref.kdx,
          kdx = _ref$kdx === void 0 ? {} : _ref$kdx,
          searchTextLen = _ref.searchTextLen,
          decoder = _ref.decoder,
          bpu = _ref.bpu,
          rest = _objectWithoutProperties(_ref, _excluded$7);
        var sca = scanner(buffer, {
          searchTextLen: searchTextLen,
          decoder: decoder,
          bpu: bpu
        });
        var list = kdx.num_entries ? Array(kdx.num_entries) : [];
        sca.forward(kdx.offset);
        sca = sca.readBlock(kdx.comp_size, kdx.decomp_size);
        for (var i = 0; i < kdx.num_entries; i++) {
          var offset = sca.readNum();
          list[i] = new Object(sca.readText());
          list[i].offset = offset;
          if (i > 0) {
            list[i - 1].size = offset - list[i - 1].offset;
          }
        }
        var cachedKeys = {
          list: list,
          pilot: kdx.first_word
        };
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          buffer: buffer,
          kdx: kdx,
          searchTextLen: searchTextLen,
          decoder: decoder,
          bpu: bpu,
          cachedKeys: cachedKeys
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var shrink = function shrink(adaptKey, arr, phrase) {
  var len = arr.length;
  var sub;
  if (len > 1) {
    len = len >> 1;
    var key = adaptKey(arr[len]);
    if (phrase < key) {
      sub = arr.slice(0, len);
      sub.pos = arr.pos;
    } else {
      sub = arr.slice(len);
      sub.pos = (arr.pos || 0) + len;
    }
    return shrink(adaptKey, sub, phrase);
  } else {
    return (arr.pos || 0) + (phrase <= adaptKey(arr[0]) ? 0 : 1);
  }
};

var _excluded$6 = ["buffer", "kdx", "adaptKey", "phrase", "cachedKeys"];
var seekVanguardThen = function seekVanguardThen(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        _ref.buffer;
          _ref.kdx;
          var adaptKey = _ref.adaptKey,
          phrase = _ref.phrase,
          cachedKeys = _ref.cachedKeys,
          rest = _objectWithoutProperties(_ref, _excluded$6);
        var list = cachedKeys.list;
        var idx = shrink(adaptKey, list, phrase);
        while (idx > 0) {
          if (adaptKey(list[--idx]) !== adaptKey(phrase)) {
            idx++;
            break;
          }
        }
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          cachedKeys: cachedKeys,
          idx: idx
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var _excluded$5 = ["query", "kdx", "word", "idx", "cachedKeys"];
var seekVanguardSpreadMdx = function seekVanguardSpreadMdx(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var _ref$query = _ref.query,
          query = _ref$query === void 0 ? {} : _ref$query;
          _ref.kdx;
          var word = _ref.word,
          idx = _ref.idx,
          cachedKeys = _ref.cachedKeys,
          rest = _objectWithoutProperties(_ref, _excluded$5);
        var list = cachedKeys.list.slice(idx);
        var offset = query.offset;
        if (offset !== UNDEFINED) {
          list = matchOffset(list, offset);
        } else {
          list = list.filter(function (el) {
            return el.toLowerCase() === word;
          });
        }
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          list: list
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var mdx = function mdx(query) {
  return function (source$) {
    return source$.pipe(seekVanguard(query), loadKeys, slicedKeyBlockThen, seekVanguardThen, seekVanguardSpreadMdx);
  };
};

var _excluded$4 = ["slicedKeyBlock", "block", "decryptors", "offset", "searchTextLen", "decoder", "bpu"];
var findWord = function findWord(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var slicedKeyBlock = _ref.slicedKeyBlock,
          block = _ref.block,
          decryptors = _ref.decryptors,
          offset = _ref.offset,
          searchTextLen = _ref.searchTextLen,
          decoder = _ref.decoder,
          bpu = _ref.bpu,
          rest = _objectWithoutProperties(_ref, _excluded$4);
        var sca = scanner(slicedKeyBlock.buffer, {
          searchTextLen: searchTextLen,
          decoder: decoder,
          bpu: bpu
        }).readBlock(block.comp_size, block.decomp_size);
        sca.forward(offset - block.decomp_offset);
        var definition = sca.readText();
        var isLink = definition.substring(0, 8) !== '@@@LINK=';
        definition = isLink ? definition : null;
        var newQuery = isLink ? null : definition.substring(8);
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          definition: definition,
          newQuery: newQuery,
          slicedKeyBlock: slicedKeyBlock,
          block: block,
          decryptors: decryptors,
          offset: offset
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var _excluded$3 = ["file", "block"];
function search(mdx$, query) {
  return mdx$.pipe(mdx(query), concatMap(function (_ref) {
    var list = _ref.list,
      blockTable = _ref.blockTable,
      slicedKeyBlock = _ref.slicedKeyBlock,
      decryptors = _ref.decryptors,
      file = _ref.file,
      searchTextLen = _ref.searchTextLen,
      decoder = _ref.decoder,
      bpu = _ref.bpu;
    return from(list).pipe(map(function (res) {
      return Object.assign(res, {
        blockTable: blockTable,
        slicedKeyBlock: slicedKeyBlock,
        decryptors: decryptors,
        file: file,
        searchTextLen: searchTextLen,
        decoder: decoder,
        bpu: bpu
      });
    }), map(function (res) {
      return Object.assign(res, {
        block: res.blockTable.find(res.offset)
      });
    }), concatMap(function (_ref2) {
      var file = _ref2.file,
        block = _ref2.block,
        rest = _objectWithoutProperties(_ref2, _excluded$3);
      var subject$ = sliceFile(file, block.comp_offset, block.comp_offset + block.comp_size);
      return subject$.pipe(map(function (buffer) {
        return Object.assign(_objectSpread2({
          file: file,
          block: block
        }, rest), {
          slicedKeyBlock: {
            buffer: buffer,
            offset: block.comp_offset + block.comp_size
          }
        });
      }), findWord, map(function (res) {
        if (res.newQuery) {
          throw res.newQuery;
        } else {
          return res;
        }
      }), catchError(function (error) {
        return mdx(error)(mdx$);
      }));
    }), scan(function (pre, cur) {
      var result = pre.result || [pre.definition];
      result.push(cur.definition);
      return Object.assign(pre, {
        result: result
      });
    }), map(function (res) {
      return Object.assign(res, {
        result: res.result && res.result.length ? res.result : [res.definition]
      });
    }));
  }));
}

var _excluded$2 = ["query", "kdx", "word", "idx", "cachedKeys"];
var seekVanguardSpreadMdd = function seekVanguardSpreadMdd(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        _ref.query;
          _ref.kdx;
          var word = _ref.word,
          idx = _ref.idx,
          cachedKeys = _ref.cachedKeys,
          rest = _objectWithoutProperties(_ref, _excluded$2);
        var candidates = cachedKeys.list.slice(idx).filter(function (item) {
          console.log('seekVanguardSpreadMdd', item);
          return item.toLowerCase() === word;
        });
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          candidates: candidates
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var mdd = function mdd(query) {
  return function (source$) {
    var word = query.trim().toLowerCase();
    word = '\\' + word.replace(/(^[/\\])|([/]$)/, '');
    word = word.replace(/\//g, '\\');
    return source$.pipe(seekVanguard(word), loadKeys, slicedKeyBlockThen, seekVanguardThen, seekVanguardSpreadMdd);
  };
};

var _excluded$1 = ["slicedKeyBlock", "block", "candidates"];
var findResource = function findResource(source$) {
  return new Observable(function (observer) {
    var subscription = source$.subscribe({
      next: function next(_ref) {
        var slicedKeyBlock = _ref.slicedKeyBlock,
          block = _ref.block,
          candidates = _ref.candidates,
          rest = _objectWithoutProperties(_ref, _excluded$1);
        var sca = scanner(slicedKeyBlock.buffer).readBlock(block.comp_size, block.decomp_size);
        sca.forward(candidates.offset - block.decomp_offset);
        var blob = sca.readRaw(candidates.size);
        var resource = URL.createObjectURL(blob);
        observer.next(_objectSpread2(_objectSpread2({}, rest), {}, {
          slicedKeyBlock: slicedKeyBlock,
          block: block,
          candidates: candidates,
          resource: resource
        }));
      },
      error: function error(err) {
        return observer.error(err);
      },
      complete: function complete() {
        return observer.complete();
      }
    });
    return function () {
      subscription.unsubscribe();
    };
  });
};

var _excluded = ["file", "candidates", "blockTable"];
function resource(mdd$, query) {
  return mdd$.pipe(mdd(query), tap(function (res) {
    return console.log('resource 1', res);
  }), map(function (res) {
    if (res.candidates && res.candidates.length) {
      return Object.assign(res, {
        candidates: res.candidates[0]
      });
    } else {
      throw Object.assign(res, {
        message: "*RESOURCE NOT FOUND* ".concat(query),
        noResource: true,
        candidates: null
      });
    }
  }), catchError(function (error) {
    return of(error).pipe(tap(function (_ref) {
      var message = _ref.message;
      return console.log(message);
    }));
  }), concatMap(function (_ref2) {
    var file = _ref2.file,
      candidates = _ref2.candidates,
      blockTable = _ref2.blockTable,
      rest = _objectWithoutProperties(_ref2, _excluded);
    if (candidates) {
      var block = blockTable.find(candidates.offset);
      var subject$ = sliceFile(file, block.comp_offset, block.comp_offset + block.comp_size);
      return subject$.pipe(map(function (buffer) {
        return Object.assign(_objectSpread2({
          file: file,
          block: block
        }, rest), {
          slicedKeyBlock: {
            buffer: buffer,
            offset: block.comp_offset + block.comp_size
          }
        });
      }), findResource);
    } else {
      return of(_objectSpread2({
        file: file,
        candidates: candidates,
        blockTable: blockTable
      }, rest));
    }
  }));
}

var defaultResource = [];
var Mdict = /*#__PURE__*/function () {
  function Mdict(files) {
    _classCallCheck(this, Mdict);
    _defineProperty(this, "resources", defaultResource);
    this.resources = this.load(files);
  }
  _createClass(Mdict, [{
    key: "get",
    value: function get(key) {
      return function (resource) {
        return Reflect.get(resource, key);
      };
    }
  }, {
    key: "load",
    value: function load(files) {
      return _toConsumableArray(files).reduce(function (acc, file) {
        var ext = getExtension(file.name, 'mdx');
        var observable$ = parse(file);
        Object.assign(acc, _defineProperty({}, ext, observable$));
        return acc;
      }, []);
    }
  }, {
    key: "search",
    value: function search$1(query) {
      var mdx$ = this.get('mdx')(this.resources) || new Observable();
      var mdd$ = this.get('mdd')(this.resources);
      var search$ = search(mdx$, query);
      if (mdd$) {
        var resource$ = resource(mdd$, query);
        return search$.pipe(tap(function (res) {
          return console.log('search', res);
        }), mergeMap(function (res) {
          return resource$.pipe(tap(function (data) {
            return console.log('resource', data, Object.assign(res, {
              resource: data.resource
            }));
          }), map(function (_ref) {
            var resource = _ref.resource;
            return Object.assign(res, {
              resource: resource
            });
          }));
        }));
      } else {
        return search$;
      }
    }
  }]);
  return Mdict;
}();

export { Mdict as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZXNtLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdHNsaWJAMi41LjIvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzRnVuY3Rpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9jcmVhdGVFcnJvckNsYXNzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvY29uZmlnLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlci90aW1lb3V0UHJvdmlkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL25vb3AuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9lcnJvckNvbnRleHQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvU3Vic2NyaWJlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zeW1ib2wvb2JzZXJ2YWJsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lkZW50aXR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvcGlwZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9PYnNlcnZhYmxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvbGlmdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvT3BlcmF0b3JTdWJzY3JpYmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvU3ViamVjdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9CZWhhdmlvclN1YmplY3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc1NjaGVkdWxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2FyZ3MuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0FycmF5TGlrZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzUHJvbWlzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzSW50ZXJvcE9ic2VydmFibGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0FzeW5jSXRlcmFibGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC90aHJvd1Vub2JzZXJ2YWJsZUVycm9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3N5bWJvbC9pdGVyYXRvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2lzSXRlcmFibGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2lubmVyRnJvbS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2V4ZWN1dGVTY2hlZHVsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvb2JzZXJ2ZU9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9zdWJzY3JpYmVPbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVPYnNlcnZhYmxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlZC9zY2hlZHVsZVByb21pc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlSXRlcmFibGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlQXN5bmNJdGVyYWJsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZWQvc2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVkL3NjaGVkdWxlZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb20uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9vZi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvbWFwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9tZXJnZUludGVybmFscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VNYXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2NhdGNoRXJyb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL3NjYW5JbnRlcm5hbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2NvbmNhdE1hcC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvc2Nhbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9yeGpzQDcuOC4xL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvc2tpcFdoaWxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3J4anNANy44LjEvbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9zd2l0Y2hNYXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcnhqc0A3LjguMS9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL3RhcC5qcyIsIi4uL3NyYy91dGlscy9yaXBlbWQxMjgudHMiLCIuLi9zcmMvdXRpbHMvaW5kZXgudHMiLCIuLi9zcmMvcGFyc2Uvc2xpY2VGaWxlLnRzIiwiLi4vc3JjL3BhcnNlL3NsaWNlLnRzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMi4wLjQvbm9kZV9tb2R1bGVzL3Bha28vZGlzdC9wYWtvLmVzbS5tanMiLCIuLi9zcmMvdXRpbHMvbHpvMXgudHMiLCIuLi9zcmMvY29uc3RhbnQudHMiLCIuLi9zcmMvcGFyc2Uvc2Nhbm5lci50cyIsIi4uL3NyYy9wYXJzZS9yZWFkSGVhZC50cyIsIi4uL3NyYy9wYXJzZS9yZWFkSGVhZGVyLnRzIiwiLi4vc3JjL3BhcnNlL3JlYWRLZXl3b3JkU3VtbWFyeS50cyIsIi4uL3NyYy9wYXJzZS9yZWFkS2V5d29yZEluZGV4LnRzIiwiLi4vc3JjL3BhcnNlL3JlYWRSZWNvcmRTdW1tYXJ5LnRzIiwiLi4vc3JjL3V0aWxzL2NyZWF0ZVJlY29yZEJsb2NrVGFibGUudHMiLCIuLi9zcmMvcGFyc2UvcmVhZFJlY29yZEJsb2NrLnRzIiwiLi4vc3JjL3BhcnNlL2luZGV4LnRzIiwiLi4vc3JjL3NlYXJjaC9yZWR1Y2UudHMiLCIuLi9zcmMvc2VhcmNoL3NlZWtWYW5ndWFyZC50cyIsIi4uL3NyYy9zZWFyY2gvbG9hZEtleXMudHMiLCIuLi9zcmMvc2VhcmNoL3NsaWNlZEtleUJsb2NrVGhlbi50cyIsIi4uL3NyYy9zZWFyY2gvc2hyaW5rLnRzIiwiLi4vc3JjL3NlYXJjaC9zZWVrVmFuZ3VhcmRUaGVuLnRzIiwiLi4vc3JjL3NlYXJjaC9zZWVrVmFuZ3VhcmRTcHJlYWRNZHgudHMiLCIuLi9zcmMvc2VhcmNoL21keC50cyIsIi4uL3NyYy9zZWFyY2gvZmluZFdvcmQudHMiLCIuLi9zcmMvc2VhcmNoL2luZGV4LnRzIiwiLi4vc3JjL3NlYXJjaC9zZWVrVmFuZ3VhcmRTcHJlYWRNZGQudHMiLCIuLi9zcmMvc2VhcmNoL21kZC50cyIsIi4uL3NyYy9zZWFyY2gvZmluZFJlc291cmNlLnRzIiwiLi4vc3JjL3NlYXJjaC9yZXNvdXJjZS50cyIsIi4uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xyXG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XHJcbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xyXG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XHJcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcclxuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XHJcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcclxuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xyXG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xyXG4gICAgZG9uZSA9IHRydWU7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xyXG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XHJcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XHJcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICBfX2V4dGVuZHMsXHJcbiAgICBfX2Fzc2lnbixcclxuICAgIF9fcmVzdCxcclxuICAgIF9fZGVjb3JhdGUsXHJcbiAgICBfX3BhcmFtLFxyXG4gICAgX19tZXRhZGF0YSxcclxuICAgIF9fYXdhaXRlcixcclxuICAgIF9fZ2VuZXJhdG9yLFxyXG4gICAgX19jcmVhdGVCaW5kaW5nLFxyXG4gICAgX19leHBvcnRTdGFyLFxyXG4gICAgX192YWx1ZXMsXHJcbiAgICBfX3JlYWQsXHJcbiAgICBfX3NwcmVhZCxcclxuICAgIF9fc3ByZWFkQXJyYXlzLFxyXG4gICAgX19zcHJlYWRBcnJheSxcclxuICAgIF9fYXdhaXQsXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yLFxyXG4gICAgX19hc3luY0RlbGVnYXRvcixcclxuICAgIF9fYXN5bmNWYWx1ZXMsXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcclxuICAgIF9faW1wb3J0U3RhcixcclxuICAgIF9faW1wb3J0RGVmYXVsdCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxyXG59O1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0Z1bmN0aW9uLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFcnJvckNsYXNzKGNyZWF0ZUltcGwpIHtcbiAgICB2YXIgX3N1cGVyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIEVycm9yLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgICBpbnN0YW5jZS5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgIH07XG4gICAgdmFyIGN0b3JGdW5jID0gY3JlYXRlSW1wbChfc3VwZXIpO1xuICAgIGN0b3JGdW5jLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICBjdG9yRnVuYy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yRnVuYztcbiAgICByZXR1cm4gY3RvckZ1bmM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVFcnJvckNsYXNzLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUVycm9yQ2xhc3MgfSBmcm9tICcuL2NyZWF0ZUVycm9yQ2xhc3MnO1xuZXhwb3J0IHZhciBVbnN1YnNjcmlwdGlvbkVycm9yID0gY3JlYXRlRXJyb3JDbGFzcyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsKGVycm9ycykge1xuICAgICAgICBfc3VwZXIodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVycm9yc1xuICAgICAgICAgICAgPyBlcnJvcnMubGVuZ3RoICsgXCIgZXJyb3JzIG9jY3VycmVkIGR1cmluZyB1bnN1YnNjcmlwdGlvbjpcXG5cIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gaSArIDEgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKTsgfSkuam9pbignXFxuICAnKVxuICAgICAgICAgICAgOiAnJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbnN1YnNjcmlwdGlvbkVycm9yLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBhcnJSZW1vdmUoYXJyLCBpdGVtKSB7XG4gICAgaWYgKGFycikge1xuICAgICAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgMCA8PSBpbmRleCAmJiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJSZW1vdmUuanMubWFwIiwiaW1wb3J0IHsgX19yZWFkLCBfX3NwcmVhZEFycmF5LCBfX3ZhbHVlcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbC9pc0Z1bmN0aW9uJztcbmltcG9ydCB7IFVuc3Vic2NyaXB0aW9uRXJyb3IgfSBmcm9tICcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcic7XG5pbXBvcnQgeyBhcnJSZW1vdmUgfSBmcm9tICcuL3V0aWwvYXJyUmVtb3ZlJztcbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihpbml0aWFsVGVhcmRvd24pIHtcbiAgICAgICAgdGhpcy5pbml0aWFsVGVhcmRvd24gPSBpbml0aWFsVGVhcmRvd247XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcmVudGFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplcnMgPSBudWxsO1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgdmFyIGVycm9ycztcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRhZ2UgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgICAgICAgICBpZiAoX3BhcmVudGFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudGFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3BhcmVudGFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9wYXJlbnRhZ2VfMSA9IF9fdmFsdWVzKF9wYXJlbnRhZ2UpLCBfcGFyZW50YWdlXzFfMSA9IF9wYXJlbnRhZ2VfMS5uZXh0KCk7ICFfcGFyZW50YWdlXzFfMS5kb25lOyBfcGFyZW50YWdlXzFfMSA9IF9wYXJlbnRhZ2VfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBfcGFyZW50YWdlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMS5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcGFyZW50YWdlXzFfMSAmJiAhX3BhcmVudGFnZV8xXzEuZG9uZSAmJiAoX2EgPSBfcGFyZW50YWdlXzEucmV0dXJuKSkgX2EuY2FsbChfcGFyZW50YWdlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfcGFyZW50YWdlLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5pdGlhbEZpbmFsaXplciA9IHRoaXMuaW5pdGlhbFRlYXJkb3duO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaW5pdGlhbEZpbmFsaXplcikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsRmluYWxpemVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yID8gZS5lcnJvcnMgOiBbZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9maW5hbGl6ZXJzID0gdGhpcy5fZmluYWxpemVycztcbiAgICAgICAgICAgIGlmIChfZmluYWxpemVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXplcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9maW5hbGl6ZXJzXzEgPSBfX3ZhbHVlcyhfZmluYWxpemVycyksIF9maW5hbGl6ZXJzXzFfMSA9IF9maW5hbGl6ZXJzXzEubmV4dCgpOyAhX2ZpbmFsaXplcnNfMV8xLmRvbmU7IF9maW5hbGl6ZXJzXzFfMSA9IF9maW5hbGl6ZXJzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxpemVyID0gX2ZpbmFsaXplcnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjRmluYWxpemVyKGZpbmFsaXplcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzICE9PSBudWxsICYmIGVycm9ycyAhPT0gdm9pZCAwID8gZXJyb3JzIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZXJyb3JzKSksIF9fcmVhZChlcnIuZXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9maW5hbGl6ZXJzXzFfMSAmJiAhX2ZpbmFsaXplcnNfMV8xLmRvbmUgJiYgKF9iID0gX2ZpbmFsaXplcnNfMS5yZXR1cm4pKSBfYi5jYWxsKF9maW5hbGl6ZXJzXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGVhcmRvd24gJiYgdGVhcmRvd24gIT09IHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGV4ZWNGaW5hbGl6ZXIodGVhcmRvd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bi5jbG9zZWQgfHwgdGVhcmRvd24uX2hhc1BhcmVudCh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duLl9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICh0aGlzLl9maW5hbGl6ZXJzID0gKF9hID0gdGhpcy5fZmluYWxpemVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLnB1c2godGVhcmRvd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9oYXNQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfcGFyZW50YWdlID0gdGhpcy5fcGFyZW50YWdlO1xuICAgICAgICByZXR1cm4gX3BhcmVudGFnZSA9PT0gcGFyZW50IHx8IChBcnJheS5pc0FycmF5KF9wYXJlbnRhZ2UpICYmIF9wYXJlbnRhZ2UuaW5jbHVkZXMocGFyZW50KSk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9hZGRQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfcGFyZW50YWdlID0gdGhpcy5fcGFyZW50YWdlO1xuICAgICAgICB0aGlzLl9wYXJlbnRhZ2UgPSBBcnJheS5pc0FycmF5KF9wYXJlbnRhZ2UpID8gKF9wYXJlbnRhZ2UucHVzaChwYXJlbnQpLCBfcGFyZW50YWdlKSA6IF9wYXJlbnRhZ2UgPyBbX3BhcmVudGFnZSwgcGFyZW50XSA6IHBhcmVudDtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3JlbW92ZVBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRhZ2UgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgICAgIGlmIChfcGFyZW50YWdlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudGFnZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfcGFyZW50YWdlKSkge1xuICAgICAgICAgICAgYXJyUmVtb3ZlKF9wYXJlbnRhZ2UsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgICAgIHZhciBfZmluYWxpemVycyA9IHRoaXMuX2ZpbmFsaXplcnM7XG4gICAgICAgIF9maW5hbGl6ZXJzICYmIGFyclJlbW92ZShfZmluYWxpemVycywgdGVhcmRvd24pO1xuICAgICAgICBpZiAodGVhcmRvd24gaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRlYXJkb3duLl9yZW1vdmVQYXJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBTdWJzY3JpcHRpb24gfTtcbmV4cG9ydCB2YXIgRU1QVFlfU1VCU0NSSVBUSU9OID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3Vic2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbiB8fFxuICAgICAgICAodmFsdWUgJiYgJ2Nsb3NlZCcgaW4gdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5yZW1vdmUpICYmIGlzRnVuY3Rpb24odmFsdWUuYWRkKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnVuc3Vic2NyaWJlKSkpO1xufVxuZnVuY3Rpb24gZXhlY0ZpbmFsaXplcihmaW5hbGl6ZXIpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihmaW5hbGl6ZXIpKSB7XG4gICAgICAgIGZpbmFsaXplcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmluYWxpemVyLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uLmpzLm1hcCIsImV4cG9ydCB2YXIgY29uZmlnID0ge1xuICAgIG9uVW5oYW5kbGVkRXJyb3I6IG51bGwsXG4gICAgb25TdG9wcGVkTm90aWZpY2F0aW9uOiBudWxsLFxuICAgIFByb21pc2U6IHVuZGVmaW5lZCxcbiAgICB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nOiBmYWxzZSxcbiAgICB1c2VEZXByZWNhdGVkTmV4dENvbnRleHQ6IGZhbHNlLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXAiLCJpbXBvcnQgeyBfX3JlYWQsIF9fc3ByZWFkQXJyYXkgfSBmcm9tIFwidHNsaWJcIjtcbmV4cG9ydCB2YXIgdGltZW91dFByb3ZpZGVyID0ge1xuICAgIHNldFRpbWVvdXQ6IGZ1bmN0aW9uIChoYW5kbGVyLCB0aW1lb3V0KSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IHRpbWVvdXRQcm92aWRlci5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlID09PSBudWxsIHx8IGRlbGVnYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWxlZ2F0ZS5zZXRUaW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuc2V0VGltZW91dC5hcHBseShkZWxlZ2F0ZSwgX19zcHJlYWRBcnJheShbaGFuZGxlciwgdGltZW91dF0sIF9fcmVhZChhcmdzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbaGFuZGxlciwgdGltZW91dF0sIF9fcmVhZChhcmdzKSkpO1xuICAgIH0sXG4gICAgY2xlYXJUaW1lb3V0OiBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IHRpbWVvdXRQcm92aWRlci5kZWxlZ2F0ZTtcbiAgICAgICAgcmV0dXJuICgoZGVsZWdhdGUgPT09IG51bGwgfHwgZGVsZWdhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlbGVnYXRlLmNsZWFyVGltZW91dCkgfHwgY2xlYXJUaW1lb3V0KShoYW5kbGUpO1xuICAgIH0sXG4gICAgZGVsZWdhdGU6IHVuZGVmaW5lZCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0UHJvdmlkZXIuanMubWFwIiwiaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IHRpbWVvdXRQcm92aWRlciB9IGZyb20gJy4uL3NjaGVkdWxlci90aW1lb3V0UHJvdmlkZXInO1xuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycikge1xuICAgIHRpbWVvdXRQcm92aWRlci5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9uVW5oYW5kbGVkRXJyb3IgPSBjb25maWcub25VbmhhbmRsZWRFcnJvcjtcbiAgICAgICAgaWYgKG9uVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICAgIG9uVW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwb3J0VW5oYW5kbGVkRXJyb3IuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7IH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vb3AuanMubWFwIiwiaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJztcbnZhciBjb250ZXh0ID0gbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiBlcnJvckNvbnRleHQoY2IpIHtcbiAgICBpZiAoY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgdmFyIGlzUm9vdCA9ICFjb250ZXh0O1xuICAgICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0geyBlcnJvclRocm93bjogZmFsc2UsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2IoKTtcbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udGV4dCwgZXJyb3JUaHJvd24gPSBfYS5lcnJvclRocm93biwgZXJyb3IgPSBfYS5lcnJvcjtcbiAgICAgICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVFcnJvcihlcnIpIHtcbiAgICBpZiAoY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgJiYgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LmVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5lcnJvciA9IGVycjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvckNvbnRleHQuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi91dGlsL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgaXNTdWJzY3JpcHRpb24sIFN1YnNjcmlwdGlvbiB9IGZyb20gJy4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IHJlcG9ydFVuaGFuZGxlZEVycm9yIH0gZnJvbSAnLi91dGlsL3JlcG9ydFVuaGFuZGxlZEVycm9yJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuL3V0aWwvbm9vcCc7XG5pbXBvcnQgeyBuZXh0Tm90aWZpY2F0aW9uLCBlcnJvck5vdGlmaWNhdGlvbiwgQ09NUExFVEVfTk9USUZJQ0FUSU9OIH0gZnJvbSAnLi9Ob3RpZmljYXRpb25GYWN0b3JpZXMnO1xuaW1wb3J0IHsgdGltZW91dFByb3ZpZGVyIH0gZnJvbSAnLi9zY2hlZHVsZXIvdGltZW91dFByb3ZpZGVyJztcbmltcG9ydCB7IGNhcHR1cmVFcnJvciB9IGZyb20gJy4vdXRpbC9lcnJvckNvbnRleHQnO1xudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIGlmIChpc1N1YnNjcmlwdGlvbihkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5hZGQoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBFTVBUWV9PQlNFUlZFUjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgaGFuZGxlU3RvcHBlZE5vdGlmaWNhdGlvbihuZXh0Tm90aWZpY2F0aW9uKHZhbHVlKSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgaGFuZGxlU3RvcHBlZE5vdGlmaWNhdGlvbihlcnJvck5vdGlmaWNhdGlvbihlcnIpLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZVN0b3BwZWROb3RpZmljYXRpb24oQ09NUExFVEVfTk9USUZJQ0FUSU9OLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3Vic2NyaWJlcjtcbn0oU3Vic2NyaXB0aW9uKSk7XG5leHBvcnQgeyBTdWJzY3JpYmVyIH07XG52YXIgX2JpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZDtcbmZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gX2JpbmQuY2FsbChmbiwgdGhpc0FyZyk7XG59XG52YXIgQ29uc3VtZXJPYnNlcnZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uc3VtZXJPYnNlcnZlcihwYXJ0aWFsT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5wYXJ0aWFsT2JzZXJ2ZXIgPSBwYXJ0aWFsT2JzZXJ2ZXI7XG4gICAgfVxuICAgIENvbnN1bWVyT2JzZXJ2ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxPYnNlcnZlciA9IHRoaXMucGFydGlhbE9ic2VydmVyO1xuICAgICAgICBpZiAocGFydGlhbE9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbE9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlVW5oYW5kbGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25zdW1lck9ic2VydmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxPYnNlcnZlciA9IHRoaXMucGFydGlhbE9ic2VydmVyO1xuICAgICAgICBpZiAocGFydGlhbE9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxPYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlVW5oYW5kbGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlVW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uc3VtZXJPYnNlcnZlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsT2JzZXJ2ZXIgPSB0aGlzLnBhcnRpYWxPYnNlcnZlcjtcbiAgICAgICAgaWYgKHBhcnRpYWxPYnNlcnZlci5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsT2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZVVuaGFuZGxlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbnN1bWVyT2JzZXJ2ZXI7XG59KCkpO1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgcGFydGlhbE9ic2VydmVyO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYnNlcnZlck9yTmV4dCkgfHwgIW9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBwYXJ0aWFsT2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgbmV4dDogKG9ic2VydmVyT3JOZXh0ICE9PSBudWxsICYmIG9ic2VydmVyT3JOZXh0ICE9PSB2b2lkIDAgPyBvYnNlcnZlck9yTmV4dCA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yICE9PSBudWxsICYmIGVycm9yICE9PSB2b2lkIDAgPyBlcnJvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGUgIT09IG51bGwgJiYgY29tcGxldGUgIT09IHZvaWQgMCA/IGNvbXBsZXRlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0XzE7XG4gICAgICAgICAgICBpZiAoX3RoaXMgJiYgY29uZmlnLnVzZURlcHJlY2F0ZWROZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRfMSA9IE9iamVjdC5jcmVhdGUob2JzZXJ2ZXJPck5leHQpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRfMS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgICAgICAgICAgcGFydGlhbE9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0OiBvYnNlcnZlck9yTmV4dC5uZXh0ICYmIGJpbmQob2JzZXJ2ZXJPck5leHQubmV4dCwgY29udGV4dF8xKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG9ic2VydmVyT3JOZXh0LmVycm9yICYmIGJpbmQob2JzZXJ2ZXJPck5leHQuZXJyb3IsIGNvbnRleHRfMSksXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZSAmJiBiaW5kKG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlLCBjb250ZXh0XzEpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsT2JzZXJ2ZXIgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBDb25zdW1lck9ic2VydmVyKHBhcnRpYWxPYnNlcnZlcik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG5leHBvcnQgeyBTYWZlU3Vic2NyaWJlciB9O1xuZnVuY3Rpb24gaGFuZGxlVW5oYW5kbGVkRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgY2FwdHVyZUVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycm9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycikge1xuICAgIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIGhhbmRsZVN0b3BwZWROb3RpZmljYXRpb24obm90aWZpY2F0aW9uLCBzdWJzY3JpYmVyKSB7XG4gICAgdmFyIG9uU3RvcHBlZE5vdGlmaWNhdGlvbiA9IGNvbmZpZy5vblN0b3BwZWROb3RpZmljYXRpb247XG4gICAgb25TdG9wcGVkTm90aWZpY2F0aW9uICYmIHRpbWVvdXRQcm92aWRlci5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9uU3RvcHBlZE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24sIHN1YnNjcmliZXIpOyB9KTtcbn1cbmV4cG9ydCB2YXIgRU1QVFlfT0JTRVJWRVIgPSB7XG4gICAgY2xvc2VkOiB0cnVlLFxuICAgIG5leHQ6IG5vb3AsXG4gICAgZXJyb3I6IGRlZmF1bHRFcnJvckhhbmRsZXIsXG4gICAgY29tcGxldGU6IG5vb3AsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaWJlci5qcy5tYXAiLCJleHBvcnQgdmFyIG9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUpIHx8ICdAQG9ic2VydmFibGUnOyB9KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRlbnRpdHkuanMubWFwIiwiaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICcuL2lkZW50aXR5JztcbmV4cG9ydCBmdW5jdGlvbiBwaXBlKCkge1xuICAgIHZhciBmbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBmbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHBpcGVGcm9tQXJyYXkoZm5zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwaXBlRnJvbUFycmF5KGZucykge1xuICAgIGlmIChmbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICB9XG4gICAgaWYgKGZucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZuc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBmbnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBmbikgeyByZXR1cm4gZm4ocHJldik7IH0sIGlucHV0KTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZS5qcy5tYXAiLCJpbXBvcnQgeyBTYWZlU3Vic2NyaWJlciwgU3Vic2NyaWJlciB9IGZyb20gJy4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBpc1N1YnNjcmlwdGlvbiB9IGZyb20gJy4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IG9ic2VydmFibGUgYXMgU3ltYm9sX29ic2VydmFibGUgfSBmcm9tICcuL3N5bWJvbC9vYnNlcnZhYmxlJztcbmltcG9ydCB7IHBpcGVGcm9tQXJyYXkgfSBmcm9tICcuL3V0aWwvcGlwZSc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi91dGlsL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgZXJyb3JDb250ZXh0IH0gZnJvbSAnLi91dGlsL2Vycm9yQ29udGV4dCc7XG52YXIgT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmUpIHtcbiAgICAgICAgaWYgKHN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IGlzU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCkgPyBvYnNlcnZlck9yTmV4dCA6IG5ldyBTYWZlU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgZXJyb3JDb250ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLCBvcGVyYXRvciA9IF9hLm9wZXJhdG9yLCBzb3VyY2UgPSBfYS5zb3VyY2U7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmFkZChvcGVyYXRvclxuICAgICAgICAgICAgICAgID9cbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IuY2FsbChzdWJzY3JpYmVyLCBzb3VyY2UpXG4gICAgICAgICAgICAgICAgOiBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N1YnNjcmliZShzdWJzY3JpYmVyKVxuICAgICAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdHJ5U3Vic2NyaWJlKHN1YnNjcmliZXIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHNpbmspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNpbmsuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChuZXh0LCBwcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwcm9taXNlQ3RvciA9IGdldFByb21pc2VDdG9yKHByb21pc2VDdG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTYWZlU3Vic2NyaWJlcih7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnNvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlW1N5bWJvbF9vYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgb3BlcmF0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlRnJvbUFycmF5KG9wZXJhdGlvbnMpKHRoaXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHByb21pc2VDdG9yID0gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpO1xuICAgICAgICByZXR1cm4gbmV3IHByb21pc2VDdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAoeCkgeyByZXR1cm4gKHZhbHVlID0geCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIHJlamVjdChlcnIpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKHZhbHVlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0IHsgT2JzZXJ2YWJsZSB9O1xuZnVuY3Rpb24gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHByb21pc2VDdG9yICE9PSBudWxsICYmIHByb21pc2VDdG9yICE9PSB2b2lkIDAgPyBwcm9taXNlQ3RvciA6IGNvbmZpZy5Qcm9taXNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBQcm9taXNlO1xufVxuZnVuY3Rpb24gaXNPYnNlcnZlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLm5leHQpICYmIGlzRnVuY3Rpb24odmFsdWUuZXJyb3IpICYmIGlzRnVuY3Rpb24odmFsdWUuY29tcGxldGUpO1xufVxuZnVuY3Rpb24gaXNTdWJzY3JpYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHx8IChpc09ic2VydmVyKHZhbHVlKSAmJiBpc1N1YnNjcmlwdGlvbih2YWx1ZSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZS5qcy5tYXAiLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9pc0Z1bmN0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBoYXNMaWZ0KHNvdXJjZSkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5saWZ0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvcGVyYXRlKGluaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzTGlmdChzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmxpZnQoZnVuY3Rpb24gKGxpZnRlZFNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0KGxpZnRlZFNvdXJjZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuYWJsZSB0byBsaWZ0IHVua25vd24gT2JzZXJ2YWJsZSB0eXBlJyk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZnQuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBvbk5leHQsIG9uQ29tcGxldGUsIG9uRXJyb3IsIG9uRmluYWxpemUpIHtcbiAgICByZXR1cm4gbmV3IE9wZXJhdG9yU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb25OZXh0LCBvbkNvbXBsZXRlLCBvbkVycm9yLCBvbkZpbmFsaXplKTtcbn1cbnZhciBPcGVyYXRvclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPcGVyYXRvclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3BlcmF0b3JTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBvbk5leHQsIG9uQ29tcGxldGUsIG9uRXJyb3IsIG9uRmluYWxpemUsIHNob3VsZFVuc3Vic2NyaWJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vbkZpbmFsaXplID0gb25GaW5hbGl6ZTtcbiAgICAgICAgX3RoaXMuc2hvdWxkVW5zdWJzY3JpYmUgPSBzaG91bGRVbnN1YnNjcmliZTtcbiAgICAgICAgX3RoaXMuX25leHQgPSBvbk5leHRcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb25OZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogX3N1cGVyLnByb3RvdHlwZS5fbmV4dDtcbiAgICAgICAgX3RoaXMuX2Vycm9yID0gb25FcnJvclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBfc3VwZXIucHJvdG90eXBlLl9lcnJvcjtcbiAgICAgICAgX3RoaXMuX2NvbXBsZXRlID0gb25Db21wbGV0ZVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPcGVyYXRvclN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRVbnN1YnNjcmliZSB8fCB0aGlzLnNob3VsZFVuc3Vic2NyaWJlKCkpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZWRfMSA9IHRoaXMuY2xvc2VkO1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgIWNsb3NlZF8xICYmICgoX2EgPSB0aGlzLm9uRmluYWxpemUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE9wZXJhdG9yU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcikpO1xuZXhwb3J0IHsgT3BlcmF0b3JTdWJzY3JpYmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PcGVyYXRvclN1YnNjcmliZXIuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlRXJyb3JDbGFzcyB9IGZyb20gJy4vY3JlYXRlRXJyb3JDbGFzcyc7XG5leHBvcnQgdmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gY3JlYXRlRXJyb3JDbGFzcyhmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9ySW1wbCgpIHtcbiAgICAgICAgX3N1cGVyKHRoaXMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnb2JqZWN0IHVuc3Vic2NyaWJlZCc7XG4gICAgfTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzLCBfX3ZhbHVlcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIEVNUFRZX1NVQlNDUklQVElPTiB9IGZyb20gJy4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yIH0gZnJvbSAnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbmltcG9ydCB7IGFyclJlbW92ZSB9IGZyb20gJy4vdXRpbC9hcnJSZW1vdmUnO1xuaW1wb3J0IHsgZXJyb3JDb250ZXh0IH0gZnJvbSAnLi91dGlsL2Vycm9yQ29udGV4dCc7XG52YXIgU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmN1cnJlbnRPYnNlcnZlcnMgPSBudWxsO1xuICAgICAgICBfdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgX3RoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnRocm93bkVycm9yID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdWJqZWN0LnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IEFub255bW91c1N1YmplY3QodGhpcywgdGhpcyk7XG4gICAgICAgIHN1YmplY3Qub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5fdGhyb3dJZkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBlcnJvckNvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICBfdGhpcy5fdGhyb3dJZkNsb3NlZCgpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmN1cnJlbnRPYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudE9ic2VydmVycyA9IEFycmF5LmZyb20oX3RoaXMub2JzZXJ2ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhfdGhpcy5jdXJyZW50T2JzZXJ2ZXJzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGVycm9yQ29udGV4dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fdGhyb3dJZkNsb3NlZCgpO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYXNFcnJvciA9IF90aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMudGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IF90aGlzLm9ic2VydmVycztcbiAgICAgICAgICAgICAgICB3aGlsZSAob2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc2hpZnQoKS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZXJyb3JDb250ZXh0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl90aHJvd0lmQ2xvc2VkKCk7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IF90aGlzLm9ic2VydmVycztcbiAgICAgICAgICAgICAgICB3aGlsZSAob2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc2hpZnQoKS5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gdGhpcy5jdXJyZW50T2JzZXJ2ZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJqZWN0LnByb3RvdHlwZSwgXCJvYnNlcnZlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLm9ic2VydmVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZDbG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3RyeVN1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHRoaXMuX3Rocm93SWZDbG9zZWQoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyhzdWJzY3JpYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyU3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX2lubmVyU3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgaGFzRXJyb3IgPSBfYS5oYXNFcnJvciwgaXNTdG9wcGVkID0gX2EuaXNTdG9wcGVkLCBvYnNlcnZlcnMgPSBfYS5vYnNlcnZlcnM7XG4gICAgICAgIGlmIChoYXNFcnJvciB8fCBpc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9TVUJTQ1JJUFRJT047XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50T2JzZXJ2ZXJzID0gbnVsbDtcbiAgICAgICAgb2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgIHJldHVybiBuZXcgU3Vic2NyaXB0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRPYnNlcnZlcnMgPSBudWxsO1xuICAgICAgICAgICAgYXJyUmVtb3ZlKG9ic2VydmVycywgc3Vic2NyaWJlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX2NoZWNrRmluYWxpemVkU3RhdHVzZXMgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBoYXNFcnJvciA9IF9hLmhhc0Vycm9yLCB0aHJvd25FcnJvciA9IF9hLnRocm93bkVycm9yLCBpc1N0b3BwZWQgPSBfYS5pc1N0b3BwZWQ7XG4gICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aHJvd25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmFzT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdDtcbn0oT2JzZXJ2YWJsZSkpO1xuZXhwb3J0IHsgU3ViamVjdCB9O1xudmFyIEFub255bW91c1N1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbm9ueW1vdXNTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmRlc3RpbmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHZhbHVlKTtcbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmRlc3RpbmF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBlcnIpO1xuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuZGVzdGluYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21wbGV0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnNvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YnNjcmliZShzdWJzY3JpYmVyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogRU1QVFlfU1VCU0NSSVBUSU9OO1xuICAgIH07XG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpKTtcbmV4cG9ydCB7IEFub255bW91c1N1YmplY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3QuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAnLi9TdWJqZWN0JztcbnZhciBCZWhhdmlvclN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCZWhhdmlvclN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQmVoYXZpb3JTdWJqZWN0KF92YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fdmFsdWUgPSBfdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJlaGF2aW9yU3ViamVjdC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gX3N1cGVyLnByb3RvdHlwZS5fc3Vic2NyaWJlLmNhbGwodGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgICFzdWJzY3JpcHRpb24uY2xvc2VkICYmIHN1YnNjcmliZXIubmV4dCh0aGlzLl92YWx1ZSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICBCZWhhdmlvclN1YmplY3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBoYXNFcnJvciA9IF9hLmhhc0Vycm9yLCB0aHJvd25FcnJvciA9IF9hLnRocm93bkVycm9yLCBfdmFsdWUgPSBfYS5fdmFsdWU7XG4gICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhyb3duRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGhyb3dJZkNsb3NlZCgpO1xuICAgICAgICByZXR1cm4gX3ZhbHVlO1xuICAgIH07XG4gICAgQmVoYXZpb3JTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmV4dC5jYWxsKHRoaXMsICh0aGlzLl92YWx1ZSA9IHZhbHVlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmVoYXZpb3JTdWJqZWN0O1xufShTdWJqZWN0KSk7XG5leHBvcnQgeyBCZWhhdmlvclN1YmplY3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJlaGF2aW9yU3ViamVjdC5qcy5tYXAiLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9pc0Z1bmN0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBpc1NjaGVkdWxlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnNjaGVkdWxlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2NoZWR1bGVyLmpzLm1hcCIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgaXNTY2hlZHVsZXIgfSBmcm9tICcuL2lzU2NoZWR1bGVyJztcbmZ1bmN0aW9uIGxhc3QoYXJyKSB7XG4gICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5leHBvcnQgZnVuY3Rpb24gcG9wUmVzdWx0U2VsZWN0b3IoYXJncykge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGxhc3QoYXJncykpID8gYXJncy5wb3AoKSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3BTY2hlZHVsZXIoYXJncykge1xuICAgIHJldHVybiBpc1NjaGVkdWxlcihsYXN0KGFyZ3MpKSA/IGFyZ3MucG9wKCkgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9wTnVtYmVyKGFyZ3MsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgbGFzdChhcmdzKSA9PT0gJ251bWJlcicgPyBhcmdzLnBvcCgpIDogZGVmYXVsdFZhbHVlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJncy5qcy5tYXAiLCJleHBvcnQgdmFyIGlzQXJyYXlMaWtlID0gKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHggIT09ICdmdW5jdGlvbic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheUxpa2UuanMubWFwIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gXCIuL2lzRnVuY3Rpb25cIjtcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbih2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWUudGhlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1Byb21pc2UuanMubWFwIiwiaW1wb3J0IHsgb2JzZXJ2YWJsZSBhcyBTeW1ib2xfb2JzZXJ2YWJsZSB9IGZyb20gJy4uL3N5bWJvbC9vYnNlcnZhYmxlJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL2lzRnVuY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZXJvcE9ic2VydmFibGUoaW5wdXQpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihpbnB1dFtTeW1ib2xfb2JzZXJ2YWJsZV0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNJbnRlcm9wT2JzZXJ2YWJsZS5qcy5tYXAiLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9pc0Z1bmN0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUob2JqKSB7XG4gICAgcmV0dXJuIFN5bWJvbC5hc3luY0l0ZXJhdG9yICYmIGlzRnVuY3Rpb24ob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0FzeW5jSXRlcmFibGUuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUludmFsaWRPYnNlcnZhYmxlVHlwZUVycm9yKGlucHV0KSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgcHJvdmlkZWQgXCIgKyAoaW5wdXQgIT09IG51bGwgJiYgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyA/ICdhbiBpbnZhbGlkIG9iamVjdCcgOiBcIidcIiArIGlucHV0ICsgXCInXCIpICsgXCIgd2hlcmUgYSBzdHJlYW0gd2FzIGV4cGVjdGVkLiBZb3UgY2FuIHByb3ZpZGUgYW4gT2JzZXJ2YWJsZSwgUHJvbWlzZSwgUmVhZGFibGVTdHJlYW0sIEFycmF5LCBBc3luY0l0ZXJhYmxlLCBvciBJdGVyYWJsZS5cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvd1Vub2JzZXJ2YWJsZUVycm9yLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCAhU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiAnQEBpdGVyYXRvcic7XG4gICAgfVxuICAgIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG59XG5leHBvcnQgdmFyIGl0ZXJhdG9yID0gZ2V0U3ltYm9sSXRlcmF0b3IoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZXJhdG9yLmpzLm1hcCIsImltcG9ydCB7IGl0ZXJhdG9yIGFzIFN5bWJvbF9pdGVyYXRvciB9IGZyb20gJy4uL3N5bWJvbC9pdGVyYXRvcic7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9pc0Z1bmN0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBpc0l0ZXJhYmxlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0W1N5bWJvbF9pdGVyYXRvcl0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNJdGVyYWJsZS5qcy5tYXAiLCJpbXBvcnQgeyBfX2FzeW5jR2VuZXJhdG9yLCBfX2F3YWl0LCBfX2dlbmVyYXRvciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vaXNGdW5jdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1MaWtlVG9Bc3luY0dlbmVyYXRvcihyZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1MaWtlVG9Bc3luY0dlbmVyYXRvcl8xKCkge1xuICAgICAgICB2YXIgcmVhZGVyLCBfYSwgdmFsdWUsIGRvbmU7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsICwgOSwgMTBdKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cnVlKSByZXR1cm4gWzMsIDhdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIF9fYXdhaXQocmVhZGVyLnJlYWQoKSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCksIHZhbHVlID0gX2EudmFsdWUsIGRvbmUgPSBfYS5kb25lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHJldHVybiBbMywgNV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgX19hd2FpdCh2b2lkIDApXTtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiwgX2Iuc2VudCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCwgX19hd2FpdCh2YWx1ZSldO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFs0LCBfYi5zZW50KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszLCAxMF07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs3XTtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtTGlrZShvYmopIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmouZ2V0UmVhZGVyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzUmVhZGFibGVTdHJlYW1MaWtlLmpzLm1hcCIsImltcG9ydCB7IF9fYXN5bmNWYWx1ZXMsIF9fYXdhaXRlciwgX19nZW5lcmF0b3IsIF9fdmFsdWVzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpc0FycmF5TGlrZSB9IGZyb20gJy4uL3V0aWwvaXNBcnJheUxpa2UnO1xuaW1wb3J0IHsgaXNQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9pc1Byb21pc2UnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgaXNJbnRlcm9wT2JzZXJ2YWJsZSB9IGZyb20gJy4uL3V0aWwvaXNJbnRlcm9wT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpc0FzeW5jSXRlcmFibGUgfSBmcm9tICcuLi91dGlsL2lzQXN5bmNJdGVyYWJsZSc7XG5pbXBvcnQgeyBjcmVhdGVJbnZhbGlkT2JzZXJ2YWJsZVR5cGVFcnJvciB9IGZyb20gJy4uL3V0aWwvdGhyb3dVbm9ic2VydmFibGVFcnJvcic7XG5pbXBvcnQgeyBpc0l0ZXJhYmxlIH0gZnJvbSAnLi4vdXRpbC9pc0l0ZXJhYmxlJztcbmltcG9ydCB7IGlzUmVhZGFibGVTdHJlYW1MaWtlLCByZWFkYWJsZVN0cmVhbUxpa2VUb0FzeW5jR2VuZXJhdG9yIH0gZnJvbSAnLi4vdXRpbC9pc1JlYWRhYmxlU3RyZWFtTGlrZSc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbC9pc0Z1bmN0aW9uJztcbmltcG9ydCB7IHJlcG9ydFVuaGFuZGxlZEVycm9yIH0gZnJvbSAnLi4vdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvcic7XG5pbXBvcnQgeyBvYnNlcnZhYmxlIGFzIFN5bWJvbF9vYnNlcnZhYmxlIH0gZnJvbSAnLi4vc3ltYm9sL29ic2VydmFibGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlubmVyRnJvbShpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNJbnRlcm9wT2JzZXJ2YWJsZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSW50ZXJvcE9ic2VydmFibGUoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5TGlrZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9taXNlKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21Qcm9taXNlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBc3luY0l0ZXJhYmxlKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21Bc3luY0l0ZXJhYmxlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJdGVyYWJsZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSXRlcmFibGUoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlYWRhYmxlU3RyZWFtTGlrZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tUmVhZGFibGVTdHJlYW1MaWtlKGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBjcmVhdGVJbnZhbGlkT2JzZXJ2YWJsZVR5cGVFcnJvcihpbnB1dCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbUludGVyb3BPYnNlcnZhYmxlKG9iaikge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgb2JzID0gb2JqW1N5bWJvbF9vYnNlcnZhYmxlXSgpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihvYnMuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdmlkZWQgb2JqZWN0IGRvZXMgbm90IGNvcnJlY3RseSBpbXBsZW1lbnQgU3ltYm9sLm9ic2VydmFibGUnKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGFycmF5KSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoICYmICFzdWJzY3JpYmVyLmNsb3NlZDsgaSsrKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUHJvbWlzZShwcm9taXNlKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHByb21pc2VcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBzdWJzY3JpYmVyLmVycm9yKGVycik7IH0pXG4gICAgICAgICAgICAudGhlbihudWxsLCByZXBvcnRVbmhhbmRsZWRFcnJvcik7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbUl0ZXJhYmxlKGl0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgaXRlcmFibGVfMSA9IF9fdmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMV8xID0gaXRlcmFibGVfMS5uZXh0KCk7ICFpdGVyYWJsZV8xXzEuZG9uZTsgaXRlcmFibGVfMV8xID0gaXRlcmFibGVfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpdGVyYWJsZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhYmxlXzFfMSAmJiAhaXRlcmFibGVfMV8xLmRvbmUgJiYgKF9hID0gaXRlcmFibGVfMS5yZXR1cm4pKSBfYS5jYWxsKGl0ZXJhYmxlXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQXN5bmNJdGVyYWJsZShhc3luY0l0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHByb2Nlc3MoYXN5bmNJdGVyYWJsZSwgc3Vic2NyaWJlcikuY2F0Y2goZnVuY3Rpb24gKGVycikgeyByZXR1cm4gc3Vic2NyaWJlci5lcnJvcihlcnIpOyB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUmVhZGFibGVTdHJlYW1MaWtlKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIGZyb21Bc3luY0l0ZXJhYmxlKHJlYWRhYmxlU3RyZWFtTGlrZVRvQXN5bmNHZW5lcmF0b3IocmVhZGFibGVTdHJlYW0pKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3MoYXN5bmNJdGVyYWJsZSwgc3Vic2NyaWJlcikge1xuICAgIHZhciBhc3luY0l0ZXJhYmxlXzEsIGFzeW5jSXRlcmFibGVfMV8xO1xuICAgIHZhciBlXzIsIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlLCBlXzJfMTtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFswLCA1LCA2LCAxMV0pO1xuICAgICAgICAgICAgICAgICAgICBhc3luY0l0ZXJhYmxlXzEgPSBfX2FzeW5jVmFsdWVzKGFzeW5jSXRlcmFibGUpO1xuICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzQsIGFzeW5jSXRlcmFibGVfMS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXN5bmNJdGVyYWJsZV8xXzEgPSBfYi5zZW50KCksICFhc3luY0l0ZXJhYmxlXzFfMS5kb25lKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhc3luY0l0ZXJhYmxlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzMsIDExXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIGVfMl8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBlXzIgPSB7IGVycm9yOiBlXzJfMSB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDExXTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbNiwgLCA5LCAxMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShhc3luY0l0ZXJhYmxlXzFfMSAmJiAhYXN5bmNJdGVyYWJsZV8xXzEuZG9uZSAmJiAoX2EgPSBhc3luY0l0ZXJhYmxlXzEucmV0dXJuKSkpIHJldHVybiBbMywgOF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgX2EuY2FsbChhc3luY0l0ZXJhYmxlXzEpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFszLCAxMF07XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbN107XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogcmV0dXJuIFs3XTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5uZXJGcm9tLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBleGVjdXRlU2NoZWR1bGUocGFyZW50U3Vic2NyaXB0aW9uLCBzY2hlZHVsZXIsIHdvcmssIGRlbGF5LCByZXBlYXQpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICBpZiAocmVwZWF0ID09PSB2b2lkIDApIHsgcmVwZWF0ID0gZmFsc2U7IH1cbiAgICB2YXIgc2NoZWR1bGVTdWJzY3JpcHRpb24gPSBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICB3b3JrKCk7XG4gICAgICAgIGlmIChyZXBlYXQpIHtcbiAgICAgICAgICAgIHBhcmVudFN1YnNjcmlwdGlvbi5hZGQodGhpcy5zY2hlZHVsZShudWxsLCBkZWxheSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfSwgZGVsYXkpO1xuICAgIHBhcmVudFN1YnNjcmlwdGlvbi5hZGQoc2NoZWR1bGVTdWJzY3JpcHRpb24pO1xuICAgIGlmICghcmVwZWF0KSB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZVN1YnNjcmlwdGlvbjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGVjdXRlU2NoZWR1bGUuanMubWFwIiwiaW1wb3J0IHsgZXhlY3V0ZVNjaGVkdWxlIH0gZnJvbSAnLi4vdXRpbC9leGVjdXRlU2NoZWR1bGUnO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZU9uKHNjaGVkdWxlciwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICByZXR1cm4gb3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KHZhbHVlKTsgfSwgZGVsYXkpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBleGVjdXRlU2NoZWR1bGUoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7IH0sIGRlbGF5KTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5lcnJvcihlcnIpOyB9LCBkZWxheSk7IH0pKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmVPbi5qcy5tYXAiLCJpbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmVPbihzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgcmV0dXJuIG9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xuICAgICAgICBzdWJzY3JpYmVyLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTsgfSwgZGVsYXkpKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZU9uLmpzLm1hcCIsImltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IG9ic2VydmVPbiB9IGZyb20gJy4uL29wZXJhdG9ycy9vYnNlcnZlT24nO1xuaW1wb3J0IHsgc3Vic2NyaWJlT24gfSBmcm9tICcuLi9vcGVyYXRvcnMvc3Vic2NyaWJlT24nO1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlT2JzZXJ2YWJsZShpbnB1dCwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIGlubmVyRnJvbShpbnB1dCkucGlwZShzdWJzY3JpYmVPbihzY2hlZHVsZXIpLCBvYnNlcnZlT24oc2NoZWR1bGVyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZU9ic2VydmFibGUuanMubWFwIiwiaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuaW1wb3J0IHsgb2JzZXJ2ZU9uIH0gZnJvbSAnLi4vb3BlcmF0b3JzL29ic2VydmVPbic7XG5pbXBvcnQgeyBzdWJzY3JpYmVPbiB9IGZyb20gJy4uL29wZXJhdG9ycy9zdWJzY3JpYmVPbic7XG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVQcm9taXNlKGlucHV0LCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gaW5uZXJGcm9tKGlucHV0KS5waXBlKHN1YnNjcmliZU9uKHNjaGVkdWxlciksIG9ic2VydmVPbihzY2hlZHVsZXIpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVkdWxlUHJvbWlzZS5qcy5tYXAiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVBcnJheShpbnB1dCwgc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGlucHV0W2krK10pO1xuICAgICAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZUFycmF5LmpzLm1hcCIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGl0ZXJhdG9yIGFzIFN5bWJvbF9pdGVyYXRvciB9IGZyb20gJy4uL3N5bWJvbC9pdGVyYXRvcic7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbC9pc0Z1bmN0aW9uJztcbmltcG9ydCB7IGV4ZWN1dGVTY2hlZHVsZSB9IGZyb20gJy4uL3V0aWwvZXhlY3V0ZVNjaGVkdWxlJztcbmV4cG9ydCBmdW5jdGlvbiBzY2hlZHVsZUl0ZXJhYmxlKGlucHV0LCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yO1xuICAgICAgICBleGVjdXRlU2NoZWR1bGUoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IGlucHV0W1N5bWJvbF9pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIGV4ZWN1dGVTY2hlZHVsZShzdWJzY3JpYmVyLCBzY2hlZHVsZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBkb25lO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGl0ZXJhdG9yLm5leHQoKSwgdmFsdWUgPSBfYS52YWx1ZSwgZG9uZSA9IF9hLmRvbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDAsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzRnVuY3Rpb24oaXRlcmF0b3IgPT09IG51bGwgfHwgaXRlcmF0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZXJhdG9yLnJldHVybikgJiYgaXRlcmF0b3IucmV0dXJuKCk7IH07XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZUl0ZXJhYmxlLmpzLm1hcCIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGV4ZWN1dGVTY2hlZHVsZSB9IGZyb20gJy4uL3V0aWwvZXhlY3V0ZVNjaGVkdWxlJztcbmV4cG9ydCBmdW5jdGlvbiBzY2hlZHVsZUFzeW5jSXRlcmFibGUoaW5wdXQsIHNjaGVkdWxlcikge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdGVyYWJsZSBjYW5ub3QgYmUgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgZXhlY3V0ZVNjaGVkdWxlKHN1YnNjcmliZXIsIHNjaGVkdWxlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaW5wdXRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICAgICAgICBleGVjdXRlU2NoZWR1bGUoc3Vic2NyaWJlciwgc2NoZWR1bGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAwLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2hlZHVsZUFzeW5jSXRlcmFibGUuanMubWFwIiwiaW1wb3J0IHsgc2NoZWR1bGVBc3luY0l0ZXJhYmxlIH0gZnJvbSAnLi9zY2hlZHVsZUFzeW5jSXRlcmFibGUnO1xuaW1wb3J0IHsgcmVhZGFibGVTdHJlYW1MaWtlVG9Bc3luY0dlbmVyYXRvciB9IGZyb20gJy4uL3V0aWwvaXNSZWFkYWJsZVN0cmVhbUxpa2UnO1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlKGlucHV0LCBzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVBc3luY0l0ZXJhYmxlKHJlYWRhYmxlU3RyZWFtTGlrZVRvQXN5bmNHZW5lcmF0b3IoaW5wdXQpLCBzY2hlZHVsZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2UuanMubWFwIiwiaW1wb3J0IHsgc2NoZWR1bGVPYnNlcnZhYmxlIH0gZnJvbSAnLi9zY2hlZHVsZU9ic2VydmFibGUnO1xuaW1wb3J0IHsgc2NoZWR1bGVQcm9taXNlIH0gZnJvbSAnLi9zY2hlZHVsZVByb21pc2UnO1xuaW1wb3J0IHsgc2NoZWR1bGVBcnJheSB9IGZyb20gJy4vc2NoZWR1bGVBcnJheSc7XG5pbXBvcnQgeyBzY2hlZHVsZUl0ZXJhYmxlIH0gZnJvbSAnLi9zY2hlZHVsZUl0ZXJhYmxlJztcbmltcG9ydCB7IHNjaGVkdWxlQXN5bmNJdGVyYWJsZSB9IGZyb20gJy4vc2NoZWR1bGVBc3luY0l0ZXJhYmxlJztcbmltcG9ydCB7IGlzSW50ZXJvcE9ic2VydmFibGUgfSBmcm9tICcuLi91dGlsL2lzSW50ZXJvcE9ic2VydmFibGUnO1xuaW1wb3J0IHsgaXNQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9pc1Byb21pc2UnO1xuaW1wb3J0IHsgaXNBcnJheUxpa2UgfSBmcm9tICcuLi91dGlsL2lzQXJyYXlMaWtlJztcbmltcG9ydCB7IGlzSXRlcmFibGUgfSBmcm9tICcuLi91dGlsL2lzSXRlcmFibGUnO1xuaW1wb3J0IHsgaXNBc3luY0l0ZXJhYmxlIH0gZnJvbSAnLi4vdXRpbC9pc0FzeW5jSXRlcmFibGUnO1xuaW1wb3J0IHsgY3JlYXRlSW52YWxpZE9ic2VydmFibGVUeXBlRXJyb3IgfSBmcm9tICcuLi91dGlsL3Rocm93VW5vYnNlcnZhYmxlRXJyb3InO1xuaW1wb3J0IHsgaXNSZWFkYWJsZVN0cmVhbUxpa2UgfSBmcm9tICcuLi91dGlsL2lzUmVhZGFibGVTdHJlYW1MaWtlJztcbmltcG9ydCB7IHNjaGVkdWxlUmVhZGFibGVTdHJlYW1MaWtlIH0gZnJvbSAnLi9zY2hlZHVsZVJlYWRhYmxlU3RyZWFtTGlrZSc7XG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVkKGlucHV0LCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNJbnRlcm9wT2JzZXJ2YWJsZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZU9ic2VydmFibGUoaW5wdXQsIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQXJyYXkoaW5wdXQsIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvbWlzZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZVByb21pc2UoaW5wdXQsIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXN5bmNJdGVyYWJsZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFzeW5jSXRlcmFibGUoaW5wdXQsIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSXRlcmFibGUoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVJdGVyYWJsZShpbnB1dCwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZWFkYWJsZVN0cmVhbUxpa2UoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2UoaW5wdXQsIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgY3JlYXRlSW52YWxpZE9ic2VydmFibGVUeXBlRXJyb3IoaW5wdXQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NoZWR1bGVkLmpzLm1hcCIsImltcG9ydCB7IHNjaGVkdWxlZCB9IGZyb20gJy4uL3NjaGVkdWxlZC9zY2hlZHVsZWQnO1xuaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi9pbm5lckZyb20nO1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oaW5wdXQsIHNjaGVkdWxlcikge1xuICAgIHJldHVybiBzY2hlZHVsZXIgPyBzY2hlZHVsZWQoaW5wdXQsIHNjaGVkdWxlcikgOiBpbm5lckZyb20oaW5wdXQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbS5qcy5tYXAiLCJpbXBvcnQgeyBwb3BTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2FyZ3MnO1xuaW1wb3J0IHsgZnJvbSB9IGZyb20gJy4vZnJvbSc7XG5leHBvcnQgZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzY2hlZHVsZXIgPSBwb3BTY2hlZHVsZXIoYXJncyk7XG4gICAgcmV0dXJuIGZyb20oYXJncywgc2NoZWR1bGVyKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mLmpzLm1hcCIsImltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIG9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChwcm9qZWN0LmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4KyspKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcCIsImltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IGV4ZWN1dGVTY2hlZHVsZSB9IGZyb20gJy4uL3V0aWwvZXhlY3V0ZVNjaGVkdWxlJztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUludGVybmFscyhzb3VyY2UsIHN1YnNjcmliZXIsIHByb2plY3QsIGNvbmN1cnJlbnQsIG9uQmVmb3JlTmV4dCwgZXhwYW5kLCBpbm5lclN1YlNjaGVkdWxlciwgYWRkaXRpb25hbEZpbmFsaXplcikge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgYWN0aXZlID0gMDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgdmFyIGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0NvbXBsZXRlICYmICFidWZmZXIubGVuZ3RoICYmICFhY3RpdmUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG91dGVyTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKGFjdGl2ZSA8IGNvbmN1cnJlbnQgPyBkb0lubmVyU3ViKHZhbHVlKSA6IGJ1ZmZlci5wdXNoKHZhbHVlKSk7IH07XG4gICAgdmFyIGRvSW5uZXJTdWIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXhwYW5kICYmIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGFjdGl2ZSsrO1xuICAgICAgICB2YXIgaW5uZXJDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBpbm5lckZyb20ocHJvamVjdCh2YWx1ZSwgaW5kZXgrKykpLnN1YnNjcmliZShjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKGlubmVyVmFsdWUpIHtcbiAgICAgICAgICAgIG9uQmVmb3JlTmV4dCA9PT0gbnVsbCB8fCBvbkJlZm9yZU5leHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQmVmb3JlTmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgICAgIGlmIChleHBhbmQpIHtcbiAgICAgICAgICAgICAgICBvdXRlck5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlubmVyQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbm5lckNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLS07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkVmFsdWUgPSBidWZmZXIuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbm5lclN1YlNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVTY2hlZHVsZShzdWJzY3JpYmVyLCBpbm5lclN1YlNjaGVkdWxlciwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9Jbm5lclN1YihidWZmZXJlZFZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb0lubmVyU3ViKGJ1ZmZlcmVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCAmJiBhY3RpdmUgPCBjb25jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIG91dGVyTmV4dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgY2hlY2tDb21wbGV0ZSgpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRpdGlvbmFsRmluYWxpemVyID09PSBudWxsIHx8IGFkZGl0aW9uYWxGaW5hbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxGaW5hbGl6ZXIoKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VJbnRlcm5hbHMuanMubWFwIiwiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi9tYXAnO1xuaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBtZXJnZUludGVybmFscyB9IGZyb20gJy4vbWVyZ2VJbnRlcm5hbHMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWwvaXNGdW5jdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBJbmZpbml0eTsgfVxuICAgIGlmIChpc0Z1bmN0aW9uKHJlc3VsdFNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VNYXAoZnVuY3Rpb24gKGEsIGkpIHsgcmV0dXJuIG1hcChmdW5jdGlvbiAoYiwgaWkpIHsgcmV0dXJuIHJlc3VsdFNlbGVjdG9yKGEsIGIsIGksIGlpKTsgfSkoaW5uZXJGcm9tKHByb2plY3QoYSwgaSkpKTsgfSwgY29uY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7IHJldHVybiBtZXJnZUludGVybmFscyhzb3VyY2UsIHN1YnNjcmliZXIsIHByb2plY3QsIGNvbmN1cnJlbnQpOyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwLmpzLm1hcCIsImltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuZXhwb3J0IGZ1bmN0aW9uIGNhdGNoRXJyb3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gb3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbm5lclN1YiA9IG51bGw7XG4gICAgICAgIHZhciBzeW5jVW5zdWIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhbmRsZWRSZXN1bHQ7XG4gICAgICAgIGlubmVyU3ViID0gc291cmNlLnN1YnNjcmliZShjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGhhbmRsZWRSZXN1bHQgPSBpbm5lckZyb20oc2VsZWN0b3IoZXJyLCBjYXRjaEVycm9yKHNlbGVjdG9yKShzb3VyY2UpKSk7XG4gICAgICAgICAgICBpZiAoaW5uZXJTdWIpIHtcbiAgICAgICAgICAgICAgICBpbm5lclN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIGlubmVyU3ViID0gbnVsbDtcbiAgICAgICAgICAgICAgICBoYW5kbGVkUmVzdWx0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN5bmNVbnN1YiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHN5bmNVbnN1Yikge1xuICAgICAgICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIGlubmVyU3ViID0gbnVsbDtcbiAgICAgICAgICAgIGhhbmRsZWRSZXN1bHQuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXRjaEVycm9yLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiBzY2FuSW50ZXJuYWxzKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkLCBlbWl0T25OZXh0LCBlbWl0QmVmb3JlQ29tcGxldGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaGFzU3RhdGUgPSBoYXNTZWVkO1xuICAgICAgICB2YXIgc3RhdGUgPSBzZWVkO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpID0gaW5kZXgrKztcbiAgICAgICAgICAgIHN0YXRlID0gaGFzU3RhdGVcbiAgICAgICAgICAgICAgICA/XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdG9yKHN0YXRlLCB2YWx1ZSwgaSlcbiAgICAgICAgICAgICAgICA6XG4gICAgICAgICAgICAgICAgICAgICgoaGFzU3RhdGUgPSB0cnVlKSwgdmFsdWUpO1xuICAgICAgICAgICAgZW1pdE9uTmV4dCAmJiBzdWJzY3JpYmVyLm5leHQoc3RhdGUpO1xuICAgICAgICB9LCBlbWl0QmVmb3JlQ29tcGxldGUgJiZcbiAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaGFzU3RhdGUgJiYgc3Vic2NyaWJlci5uZXh0KHN0YXRlKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2FuSW50ZXJuYWxzLmpzLm1hcCIsImltcG9ydCB7IG1lcmdlTWFwIH0gZnJvbSAnLi9tZXJnZU1hcCc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbC9pc0Z1bmN0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihyZXN1bHRTZWxlY3RvcikgPyBtZXJnZU1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgMSkgOiBtZXJnZU1hcChwcm9qZWN0LCAxKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdE1hcC5qcy5tYXAiLCJpbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IHNjYW5JbnRlcm5hbHMgfSBmcm9tICcuL3NjYW5JbnRlcm5hbHMnO1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW4oYWNjdW11bGF0b3IsIHNlZWQpIHtcbiAgICByZXR1cm4gb3BlcmF0ZShzY2FuSW50ZXJuYWxzKGFjY3VtdWxhdG9yLCBzZWVkLCBhcmd1bWVudHMubGVuZ3RoID49IDIsIHRydWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjYW4uanMubWFwIiwiaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5leHBvcnQgZnVuY3Rpb24gc2tpcFdoaWxlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBvcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHRha2luZyA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh0YWtpbmcgfHwgKHRha2luZyA9ICFwcmVkaWNhdGUodmFsdWUsIGluZGV4KyspKSkgJiYgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTsgfSkpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2tpcFdoaWxlLmpzLm1hcCIsImltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuZXhwb3J0IGZ1bmN0aW9uIHN3aXRjaE1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiBvcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaWJlciA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHZhciBjaGVja0NvbXBsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNDb21wbGV0ZSAmJiAhaW5uZXJTdWJzY3JpYmVyICYmIHN1YnNjcmliZXIuY29tcGxldGUoKTsgfTtcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmliZXIgPT09IG51bGwgfHwgaW5uZXJTdWJzY3JpYmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbm5lclN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHZhciBpbm5lckluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBvdXRlckluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICAgIGlubmVyRnJvbShwcm9qZWN0KHZhbHVlLCBvdXRlckluZGV4KSkuc3Vic2NyaWJlKChpbm5lclN1YnNjcmliZXIgPSBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKGlubmVyVmFsdWUpIHsgcmV0dXJuIHN1YnNjcmliZXIubmV4dChyZXN1bHRTZWxlY3RvciA/IHJlc3VsdFNlbGVjdG9yKHZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KyspIDogaW5uZXJWYWx1ZSk7IH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbm5lclN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoZWNrQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgY2hlY2tDb21wbGV0ZSgpO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXAuanMubWFwIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWwvaXNGdW5jdGlvbic7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IGlkZW50aXR5IH0gZnJvbSAnLi4vdXRpbC9pZGVudGl0eSc7XG5leHBvcnQgZnVuY3Rpb24gdGFwKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICB2YXIgdGFwT2JzZXJ2ZXIgPSBpc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSB8fCBlcnJvciB8fCBjb21wbGV0ZVxuICAgICAgICA/XG4gICAgICAgICAgICB7IG5leHQ6IG9ic2VydmVyT3JOZXh0LCBlcnJvcjogZXJyb3IsIGNvbXBsZXRlOiBjb21wbGV0ZSB9XG4gICAgICAgIDogb2JzZXJ2ZXJPck5leHQ7XG4gICAgcmV0dXJuIHRhcE9ic2VydmVyXG4gICAgICAgID8gb3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0YXBPYnNlcnZlci5zdWJzY3JpYmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRhcE9ic2VydmVyKTtcbiAgICAgICAgICAgIHZhciBpc1Vuc3ViID0gdHJ1ZTtcbiAgICAgICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0YXBPYnNlcnZlci5uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YXBPYnNlcnZlciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlzVW5zdWIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0YXBPYnNlcnZlci5jb21wbGV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGFwT2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaXNVbnN1YiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIChfYSA9IHRhcE9ic2VydmVyLmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0YXBPYnNlcnZlciwgZXJyKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbnN1Yikge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0YXBPYnNlcnZlci51bnN1YnNjcmliZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGFwT2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2IgPSB0YXBPYnNlcnZlci5maW5hbGl6ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGFwT2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KVxuICAgICAgICA6XG4gICAgICAgICAgICBpZGVudGl0eTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcC5qcy5tYXAiLCJcbi8qXG4gKiBBIHB1cmUgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBSSVBFTUQxMjggdXNpbmcgVWludDhBcnJheSBhcyBpbnB1dC9vdXRwdXQuXG4gKiBCeSBGZW5nIERpaGFpIDxmZW5nZGhAZ21haWwuY29tPiwgMjAxNS8wNy8wOVxuICpcbiAqIEJhc2VkIG9uIGNvaXNjaXIvanNkaWdlc3QgKGh0dHBzOi8vZ2l0aHViLmNvbS9jb2lzY2lyL2pzZGlnZXN0L2Jsb2IvbWFzdGVyL3NyYy9oYXNoL3JpcGVtZDEyOC5qcylcbiAqXG4gKiByaXBlbWQxMjguanMgaXMgZnJlZSBzb2Z0d2FyZSByZWxlYXNlZCB1bmRlciB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UuXG4gKiBZb3UgY2FuIGdldCBhIGNvcHkgb24gaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqXG4gKlxuICogUklQRU1ELTEyOCAoYykgMTk5NiBIYW5zIERvYmJlcnRpbiwgQW50b29uIEJvc3NlbGFlcnMsIGFuZCBCYXJ0IFByZW5lZWxcbiAqL1xuXG4vLyBjb252ZXJ0IGFycmF5IG9mIG51bWJlciB0byBVaW50MzJBcnJheVxuZnVuY3Rpb24gYXNVaW50MzJBcnJheShhcnI6IGFueSkge1xuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGFycik7XG59XG5cbi8vIGNvbmNhdCAyIHR5cGVkIGFycmF5XG5mdW5jdGlvbiBjb25jYXQoYTogYW55LCBiOiBhbnkpIHtcbiAgdmFyIGMgPSBuZXcgYS5jb25zdHJ1Y3RvcihhLmxlbmd0aCArIGIubGVuZ3RoKTtcbiAgYy5zZXQoYSk7XG4gIGMuc2V0KGIsIGEubGVuZ3RoKTtcbiAgcmV0dXJuIGM7XG59XG5cbi8vIHN3YXAgaGlnaCBhbmQgbG93IGJpdHMgb2YgYSAzMi1iaXQgaW50LlxuZnVuY3Rpb24gcm90bCh4OiBhbnksIG46IGFueSkge1xuICByZXR1cm4gKHggPj4+ICgzMiAtIG4pKSB8ICh4IDw8IG4pO1xufVxuXG52YXIgRElHRVNUID0gMTI4LFxuICBCTE9DSyA9IDY0LFxuICBTID0gW1xuICAgICAgWzExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOF0sIC8vIHJvdW5kIDFcbiAgICAgIFs3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTJdLCAvLyByb3VuZCAyXG4gICAgICBbMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1XSwgLy8gcm91bmQgM1xuICAgICAgWzExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMl0sIC8vIHJvdW5kIDRcbiAgICAgIFs4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDZdLCAvLyBwYXJhbGxlbCByb3VuZCAxXG4gICAgICBbOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExXSwgLy8gcGFyYWxsZWwgcm91bmQgMlxuICAgICAgWzksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNV0sIC8vIHBhcmFsbGVsIHJvdW5kIDNcbiAgICAgIFsxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDhdICAvLyBwYXJhbGxlbCByb3VuZCA0XG4gIF0ubWFwKGFzVWludDMyQXJyYXkpLFxuICBYID0gW1xuICAgICAgWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTVdLCAvLyByb3VuZCAxXG4gICAgICBbNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOF0sIC8vIHJvdW5kIDJcbiAgICAgIFszLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyXSwgLy8gcm91bmQgM1xuICAgICAgWzEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDJdLCAvLyByb3VuZCA0XG4gICAgICBbNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMl0sIC8vIHBhcmFsbGVsIHJvdW5kIDFcbiAgICAgIFs2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyXSwgLy8gcGFyYWxsZWwgcm91bmQgMlxuICAgICAgWzE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTNdLCAvLyBwYXJhbGxlbCByb3VuZCAzXG4gICAgICBbOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNF0gIC8vIHBhcmFsbGVsIHJvdW5kIDRcbiAgXS5tYXAoYXNVaW50MzJBcnJheSksXG4gIEsgPSBhc1VpbnQzMkFycmF5KFtcbiAgICAgIDB4MDAwMDAwMDAsIC8vIEZGXG4gICAgICAweDVhODI3OTk5LCAvLyBHR1xuICAgICAgMHg2ZWQ5ZWJhMSwgLy8gSEhcbiAgICAgIDB4OGYxYmJjZGMsIC8vIElJXG4gICAgICAweDUwYTI4YmU2LCAvLyBJSUlcbiAgICAgIDB4NWM0ZGQxMjQsIC8vIEhISFxuICAgICAgMHg2ZDcwM2VmMywgLy8gR0dHXG4gICAgICAweDAwMDAwMDAwICAvLyBGRkZcbiAgXSksXG4gIEYgPSBbXG4gICAgICBmdW5jdGlvbiAoeDogYW55LCB5OiBhbnksIHo6IGFueSkge1xuICAgICAgICAgIHJldHVybiAoeCBeIHkgXiB6KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoeDogYW55LCB5OiBhbnksIHo6IGFueSkge1xuICAgICAgICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoeDogYW55LCB5OiBhbnksIHo6IGFueSkge1xuICAgICAgICAgIHJldHVybiAoeCB8ICh+eSkpIF4gejtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoeDogYW55LCB5OiBhbnksIHo6IGFueSkge1xuICAgICAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiAofnopKTtcbiAgICAgIH1cbiAgXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmlwZW1kMTI4KGRhdGE6IGFueSkge1xuICBsZXQgYWEsIGJiLCBjYywgZGQsIGFhYSwgYmJiLCBjY2MsIGRkZCwgaSwgbCwgciwgcnIsIHQsIHRtcCwgeCxcbiAgICAgIGhhc2ggPSBuZXcgVWludDMyQXJyYXkoWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZdKSxcbiAgICAgIGJ5dGVzID0gZGF0YS5sZW5ndGg7XG5cbiAgY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KCgoYnl0ZXMgJSA2NCkgPCA1NiA/IDU2IDogMTIwKSAtIChieXRlcyAlIDY0KSk7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcGFkZGluZ1swXSA9IFsweDgwXTtcblxuICBkYXRhID0gbmV3IFVpbnQzMkFycmF5KGNvbmNhdChkYXRhLCBwYWRkaW5nKS5idWZmZXIpO1xuXG4gIC8vIGVuZGluZyB3aXRoIGNoZWNrIGJpdHMgKD0gbGl0dGxlIGVuZGlhbiA2NC1iaXQgaW50LCA4ICogZGF0YS5sZW5ndGgpXG4gIGJ5dGVzID0gYnl0ZXMgPDwgMztcbiAgeCA9IGNvbmNhdChkYXRhLCBbYnl0ZXMsIGJ5dGVzID4+IDMxID4+IDFdKTtcbiAgLy8gdXBkYXRlIGhhc2hcbiAgZm9yIChpID0gMCwgdCA9IDAsIGwgPSB4Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMTYsIHQgPSAwKSB7XG4gICAgICBhYSA9IGFhYSA9IGhhc2hbMF07XG4gICAgICBiYiA9IGJiYiA9IGhhc2hbMV07XG4gICAgICBjYyA9IGNjYyA9IGhhc2hbMl07XG4gICAgICBkZCA9IGRkZCA9IGhhc2hbM107XG5cbiAgICAgIGZvciAoOyB0IDwgNjQ7ICsrdCkge1xuICAgICAgICAgIHIgPSB+fih0IC8gMTYpO1xuICAgICAgICAgIGFhID0gcm90bChhYSArIEZbcl0oYmIsIGNjLCBkZCkgKyB4W2kgKyBYW3JdW3QgJSAxNl1dICsgS1tyXSwgU1tyXVt0ICUgMTZdKTtcblxuICAgICAgICAgIHRtcCA9IGRkO1xuICAgICAgICAgIGRkID0gY2M7XG4gICAgICAgICAgY2MgPSBiYjtcbiAgICAgICAgICBiYiA9IGFhO1xuICAgICAgICAgIGFhID0gdG1wO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgdCA8IDEyODsgKyt0KSB7XG4gICAgICAgICAgciA9IH5+KHQgLyAxNik7XG4gICAgICAgICAgcnIgPSB+figoNjMgLSAodCAlIDY0KSkgLyAxNik7XG4gICAgICAgICAgYWFhID0gcm90bChhYWEgKyBGW3JyXShiYmIsIGNjYywgZGRkKSArIHhbaSArIFhbcl1bdCAlIDE2XV0gKyBLW3JdLCBTW3JdW3QgJSAxNl0pO1xuXG4gICAgICAgICAgdG1wID0gZGRkO1xuICAgICAgICAgIGRkZCA9IGNjYztcbiAgICAgICAgICBjY2MgPSBiYmI7XG4gICAgICAgICAgYmJiID0gYWFhO1xuICAgICAgICAgIGFhYSA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgZGRkID0gaGFzaFsxXSArIGNjICsgZGRkO1xuICAgICAgaGFzaFsxXSA9IGhhc2hbMl0gKyBkZCArIGFhYTtcbiAgICAgIGhhc2hbMl0gPSBoYXNoWzNdICsgYWEgKyBiYmI7XG4gICAgICBoYXNoWzNdID0gaGFzaFswXSArIGJiICsgY2NjO1xuICAgICAgaGFzaFswXSA9IGRkZDtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShoYXNoLmJ1ZmZlcik7XG59XG4iLCJcbmltcG9ydCByaXBlbWQxMjggZnJvbSAnLi9yaXBlbWQxMjgnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZEZpbGUoZmlsZTogRmlsZSwgb2Zmc2V0OiBudW1iZXIsIGxlbjogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdClcbiAgICB9O1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0RXh0ZW5zaW9uID0gKGZpbGVuYW1lOiBzdHJpbmcsIGRlZmF1bHRFeHQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBmaWxlbmFtZSA/IC8oPzpcXC4oW14uXSspKT8kLy5leGVjKGZpbGVuYW1lKSFbMV0gOiBkZWZhdWx0RXh0O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlWG1sID0gKHN0cjogc3RyaW5nKSA9PiB7XG4gIHJldHVybiAobmV3IERPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcoc3RyLCAndGV4dC94bWwnKTtcbn1cblxuLypcbiAgICogRGVjcnlwdCBlbmNyeXB0ZWQgZGF0YSBibG9jayBvZiBrZXl3b3JkIGluZGV4IChhdHRycy5FbmNyeXB0ZWQgPSBcIjJcIikuXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3poYW5zbGl1L3dyaXRlbWRpY3QvYmxvYi9tYXN0ZXIvZmlsZWZvcm1hdC5tZCNrZXl3b3JkLWluZGV4LWVuY3J5cHRpb25cbiAgICogQHBhcmFtIGJ1ZiBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIHNvdXJjZSBkYXRhXG4gICAqIEBwYXJhbSBrZXkgYW4gQXJyYXlCdWZmZXIgaG9sZGluZyBkZWNyeXB0aW9uIGtleSwgd2hpY2ggd2lsbCBiZSBzdXBwbGllZCB0byByaXBlbWQxMjgoKSBiZWZvcmUgZGVjcnlwdGlvblxuICAgKiBAcmV0dXJuIGFuIEFycmF5QnVmZmVyIGNhcnJ5aW5nIGRlY3J5cHRlZCBkYXRhLCBvY2N1cHlpbmcgdGhlIHNhbWUgbWVtb3J5IHNwYWNlIG9mIHNvdXJjZSBidWZmZXJcbiAgICovXG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdChidWY6IFVpbnQ4QXJyYXksIGtleTogYW55KTogQXJyYXlCdWZmZXIge1xuICBrZXkgPSByaXBlbWQxMjgoa2V5KTtcbiAgbGV0IGJ5dGUsIGtleWxlbiA9IGtleS5sZW5ndGgsIHByZXYgPSAweDM2LCBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDtcbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYnl0ZSA9IGJ1ZltpXTtcbiAgICAgIGJ5dGUgPSAoKGJ5dGUgPj4gNCkgfCAoYnl0ZSA8PCA0KSk7XG4gICAgICBieXRlID0gYnl0ZSBeIHByZXYgXiAoaSAmIDB4RkYpIF4ga2V5W2kgJSBrZXlsZW5dO1xuICAgICAgcHJldiA9IGJ1ZltpXTtcbiAgICAgIGJ1ZltpXSA9IGJ5dGU7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnNlcSAoLi4uYXJnczogYW55KSB7XG4gIHJldHVybiBhcmdzWzBdO1xufVxuXG4vKipcbiAqIFRlc3QgaWYgYSB2YWx1ZSBvZiBkaWN0aW9uYXJ5IGF0dHJpYnV0ZSBpcyB0cnVlIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHJ1ZSh2OiBzdHJpbmcgfCBib29sZWFuKSB7XG4gIHYgPSAoKHYgfHwgZmFsc2UpICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB2ID09PSAneWVzJyB8fCB2ID09PSAndHJ1ZSc7XG59XG5cbi8qKlxuICogTWF0Y2ggdGhlIGZpcnN0IGVsZW1lbnQgaW4gbGlzdCB3aXRoIGdpdmVuIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoT2Zmc2V0KGxpc3Q6IGFueVtdLCBvZmZzZXQ6IG51bWJlcikge1xuICByZXR1cm4gbGlzdC5zb21lKGZ1bmN0aW9uKGVsOiBhbnkpIHsgcmV0dXJuIGVsLm9mZnNldCA9PT0gb2Zmc2V0ID8gbGlzdCA9IFtlbF0gOiBmYWxzZTsgfSkgPyBsaXN0IDogW107XG59XG4iLCJpbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUsIHNraXBXaGlsZSwgdGFwIH0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCBjb25zdCBzbGljZUZpbGUgPSAoZmlsZTogRmlsZSwgb2Zmc2V0OiBudW1iZXIsIGxlbjogbnVtYmVyKTogT2JzZXJ2YWJsZTxBcnJheUJ1ZmZlcj4gPT4ge1xuICBjb25zdCBmaWxlJCA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCBhcyB1bmtub3duIGFzIEFycmF5QnVmZmVyKTtcbiAgZmlsZSQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlLnNsaWNlKG9mZnNldCwgbGVuKSk7XG4gICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGlmKHJlYWRlci5yZXN1bHQpIHtcbiAgICAgICAgZmlsZSQubmV4dChyZWFkZXIucmVzdWx0IGFzIEFycmF5QnVmZmVyKVxuICAgICAgfVxuXG4gICAgfVxuICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiB7XG4gICAgICBmaWxlJC5jb21wbGV0ZSgpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gKGVycikgPT4ge1xuICAgICAgZmlsZSQuZXJyb3IoZXJyKVxuICAgIH1cbiAgICByZWFkZXIub25hYm9ydCA9ICgpID0+IHtcbiAgICAgIGZpbGUkLmVycm9yKFwi6YGH5Yiw5oSP5aSW6YCA5Ye6XCIpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBmaWxlJC5waXBlKFxuICAgIHNraXBXaGlsZSgoYnVmZmVyOiBBcnJheUJ1ZmZlcikgPT4gYnVmZmVyID09PSBudWxsIHx8IGJ1ZmZlciA9PT0gdW5kZWZpbmVkIHx8IGJ1ZmZlci5ieXRlTGVuZ3RoIDw9IDApLFxuICApO1xufVxuIiwiaW1wb3J0IHsgbWVyZ2VNYXAsIE9ic2VydmFibGUsIG1hcCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtzbGljZUZpbGV9IGZyb20gJy4vc2xpY2VGaWxlJztcblxuZXhwb3J0IGNvbnN0IHNsaWNlID0gKHBvcz86IG51bWJlciwgbGVuPzogbnVtYmVyKSA9PiAoc291cmNlJDogT2JzZXJ2YWJsZTxhbnk+KTogT2JzZXJ2YWJsZTxhbnk+ID0+IHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICByZXR1cm4gc291cmNlJC5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHtmaWxlLCBuZXh0ID0gMCwgb2Zmc2V0ID0gMCwgLi4ucmVzdH06IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBzdGFydCA9IHR5cGVvZiBwb3MgIT09ICd1bmRlZmluZWQnID8gcG9zIDogb2Zmc2V0O1xuICAgICAgICBjb25zdCBzaXplID0gbGVuID8gbGVuICsgbmV4dCA6IG5leHQ7XG4gICAgICAgIGNvbnN0IHN1YmplY3QkID0gc2xpY2VGaWxlKGZpbGUsIHN0YXJ0LCBzdGFydCArIHNpemUpO1xuICAgICAgICByZXR1cm4gc3ViamVjdCQucGlwZShcbiAgICAgICAgICBtYXAoKGJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IE9iamVjdC5hc3NpZ24oe2ZpbGUsIG5leHQsIG9mZnNldCwgLi4ucmVzdH0sIHtidWZmZXIsIG9mZnNldDogc3RhcnQgKyBzaXplfSkpXG4gICAgICAgIClcbiAgICAgIH0pLFxuICAgICkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChyZXM6IGFueSkgPT4ge1xuICAgICAgICBvYnNlcnZlci5uZXh0KHJlcyk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcbn1cbiIsIlxuLyohIHBha28gMi4wLjQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvIEBsaWNlbnNlIChNSVQgQU5EIFpsaWIpICovXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLXVuYXJ5LW9wcyAqL1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL2NvbnN0IFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy9jb25zdCBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vY29uc3QgWl9STEUgICAgICAgICAgICAgICA9IDM7XG5jb25zdCBaX0ZJWEVEJDEgICAgICAgICAgICAgICA9IDQ7XG4vL2NvbnN0IFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG5jb25zdCBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuY29uc3QgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vY29uc3QgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG5jb25zdCBaX1VOS05PV04kMSAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyQxKGJ1ZikgeyBsZXQgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbmNvbnN0IFNUT1JFRF9CTE9DSyA9IDA7XG5jb25zdCBTVEFUSUNfVFJFRVMgPSAxO1xuY29uc3QgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbmNvbnN0IE1JTl9NQVRDSCQxICAgID0gMztcbmNvbnN0IE1BWF9NQVRDSCQxICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG5jb25zdCBMRU5HVEhfQ09ERVMkMSAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG5jb25zdCBMSVRFUkFMUyQxICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxuY29uc3QgTF9DT0RFUyQxICAgICAgID0gTElURVJBTFMkMSArIDEgKyBMRU5HVEhfQ09ERVMkMTtcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG5jb25zdCBEX0NPREVTJDEgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG5jb25zdCBCTF9DT0RFUyQxICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG5jb25zdCBIRUFQX1NJWkUkMSAgICAgPSAyICogTF9DT0RFUyQxICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbmNvbnN0IE1BWF9CSVRTJDEgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbmNvbnN0IEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxuY29uc3QgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbmNvbnN0IFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbmNvbnN0IFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuY29uc3QgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5jb25zdCBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXSk7XG5cbmNvbnN0IGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdKTtcblxuY29uc3QgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XSk7XG5cbmNvbnN0IGJsX29yZGVyID1cbiAgbmV3IFVpbnQ4QXJyYXkoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbmNvbnN0IERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxuY29uc3Qgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyQxICsgMikgKiAyKTtcbnplcm8kMShzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG5jb25zdCBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMkMSAqIDIpO1xuemVybyQxKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbmNvbnN0IF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvJDEoX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG5jb25zdCBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCQxIC0gTUlOX01BVENIJDEgKyAxKTtcbnplcm8kMShfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG5jb25zdCBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyQxKTtcbnplcm8kMShiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG5jb25zdCBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMkMSk7XG56ZXJvJDEoYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbmxldCBzdGF0aWNfbF9kZXNjO1xubGV0IHN0YXRpY19kX2Rlc2M7XG5sZXQgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuY29uc3QgZF9jb2RlID0gKGRpc3QpID0+IHtcblxuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmNvbnN0IHB1dF9zaG9ydCA9IChzLCB3KSA9PiB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmNvbnN0IHNlbmRfYml0cyA9IChzLCB2YWx1ZSwgbGVuZ3RoKSA9PiB7XG5cbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufTtcblxuXG5jb25zdCBzZW5kX2NvZGUgPSAocywgYywgdHJlZSkgPT4ge1xuXG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmNvbnN0IGJpX3JldmVyc2UgPSAoY29kZSwgbGVuKSA9PiB7XG5cbiAgbGV0IHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5jb25zdCBiaV9mbHVzaCA9IChzKSA9PiB7XG5cbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmNvbnN0IGdlbl9iaXRsZW4gPSAocywgZGVzYykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgY29uc3QgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgY29uc3QgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgY29uc3Qgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIGNvbnN0IGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgY29uc3QgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgY29uc3QgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgY29uc3QgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgbGV0IGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIGxldCBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICBsZXQgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgbGV0IGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgbGV0IG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFMkMTsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkUkMTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmNvbnN0IGdlbl9jb2RlcyA9ICh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpID0+XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIGNvbnN0IG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyQxICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIGxldCBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICBsZXQgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgbGV0IG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFMkMTsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGxldCBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5jb25zdCB0cl9zdGF0aWNfaW5pdCA9ICgpID0+IHtcblxuICBsZXQgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICBsZXQgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIGxldCBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIGxldCBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICBsZXQgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIGNvbnN0IGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTJDEgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMkMSAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUyQxOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFMkMTsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTJDEgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTJDE7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTJDEgKyAxLCBMX0NPREVTJDEsIE1BWF9CSVRTJDEpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMkMSwgTUFYX0JJVFMkMSk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTJDEsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmNvbnN0IGluaXRfYmxvY2sgPSAocykgPT4ge1xuXG4gIGxldCBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVMkMTsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTJDE7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVMkMTsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuY29uc3QgYmlfd2luZHVwID0gKHMpID0+XG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmNvbnN0IGNvcHlfYmxvY2sgPSAocywgYnVmLCBsZW4sIGhlYWRlcikgPT5cbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHMucGVuZGluZ19idWYuc2V0KHMud2luZG93LnN1YmFycmF5KGJ1ZiwgYnVmICsgbGVuKSwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn07XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5jb25zdCBzbWFsbGVyID0gKHRyZWUsIG4sIG0sIGRlcHRoKSA9PiB7XG5cbiAgY29uc3QgX24yID0gbiAqIDI7XG4gIGNvbnN0IF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuY29uc3QgcHFkb3duaGVhcCA9IChzLCB0cmVlLCBrKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICBjb25zdCB2ID0gcy5oZWFwW2tdO1xuICBsZXQgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59O1xuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIGNvbnN0IFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuY29uc3QgY29tcHJlc3NfYmxvY2sgPSAocywgbHRyZWUsIGR0cmVlKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIGxldCBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgbGV0IGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIGxldCBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICBsZXQgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyQxICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmNvbnN0IGJ1aWxkX3RyZWUgPSAocywgZGVzYykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgY29uc3QgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICBjb25zdCBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICBjb25zdCBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIGNvbnN0IGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIGxldCBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICBsZXQgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIGxldCBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFJDE7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5jb25zdCBzY2FuX3RyZWUgPSAocywgdHJlZSwgbWF4X2NvZGUpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICBsZXQgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIGxldCBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgbGV0IGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIGxldCBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICBsZXQgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICBsZXQgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIGxldCBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuY29uc3Qgc2VuZF90cmVlID0gKHMsIHRyZWUsIG1heF9jb2RlKSA9PlxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIGxldCBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgbGV0IHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICBsZXQgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgbGV0IG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIGxldCBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIGxldCBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgbGV0IG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuY29uc3QgYnVpbGRfYmxfdHJlZSA9IChzKSA9PiB7XG5cbiAgbGV0IG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTJDEgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5jb25zdCBzZW5kX2FsbF90cmVlcyA9IChzLCBsY29kZXMsIGRjb2RlcywgYmxjb2RlcykgPT5cbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIGxldCByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmNvbnN0IGRldGVjdF9kYXRhX3R5cGUgPSAocykgPT4ge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIGxldCBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgbGV0IG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFMkMTsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufTtcblxuXG5sZXQgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuY29uc3QgX3RyX2luaXQkMSA9IChzKSA9Plxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmNvbnN0IF90cl9zdG9yZWRfYmxvY2skMSA9IChzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpID0+XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5jb25zdCBfdHJfYWxpZ24kMSA9IChzKSA9PiB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5jb25zdCBfdHJfZmx1c2hfYmxvY2skMSA9IChzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpID0+XG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBsZXQgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICBsZXQgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04kMSkge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2skMShzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCQxIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuY29uc3QgX3RyX3RhbGx5JDEgPSAocywgZGlzdCwgbGMpID0+XG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy9sZXQgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyQxICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn07XG5cbnZhciBfdHJfaW5pdF8xICA9IF90cl9pbml0JDE7XG52YXIgX3RyX3N0b3JlZF9ibG9ja18xID0gX3RyX3N0b3JlZF9ibG9jayQxO1xudmFyIF90cl9mbHVzaF9ibG9ja18xICA9IF90cl9mbHVzaF9ibG9jayQxO1xudmFyIF90cl90YWxseV8xID0gX3RyX3RhbGx5JDE7XG52YXIgX3RyX2FsaWduXzEgPSBfdHJfYWxpZ24kMTtcblxudmFyIHRyZWVzID0ge1xuXHRfdHJfaW5pdDogX3RyX2luaXRfMSxcblx0X3RyX3N0b3JlZF9ibG9jazogX3RyX3N0b3JlZF9ibG9ja18xLFxuXHRfdHJfZmx1c2hfYmxvY2s6IF90cl9mbHVzaF9ibG9ja18xLFxuXHRfdHJfdGFsbHk6IF90cl90YWxseV8xLFxuXHRfdHJfYWxpZ246IF90cl9hbGlnbl8xXG59O1xuXG4vLyBOb3RlOiBhZGxlcjMyIHRha2VzIDEyJSBmb3IgbGV2ZWwgMCBhbmQgMiUgZm9yIGxldmVsIDYuXG4vLyBJdCBpc24ndCB3b3J0aCBpdCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9ucyBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5jb25zdCBhZGxlcjMyID0gKGFkbGVyLCBidWYsIGxlbiwgcG9zKSA9PiB7XG4gIGxldCBzMSA9IChhZGxlciAmIDB4ZmZmZikgfDAsXG4gICAgICBzMiA9ICgoYWRsZXIgPj4+IDE2KSAmIDB4ZmZmZikgfDAsXG4gICAgICBuID0gMDtcblxuICB3aGlsZSAobGVuICE9PSAwKSB7XG4gICAgLy8gU2V0IGxpbWl0IH4gdHdpY2UgbGVzcyB0aGFuIDU1NTIsIHRvIGtlZXBcbiAgICAvLyBzMiBpbiAzMS1iaXRzLCBiZWNhdXNlIHdlIGZvcmNlIHNpZ25lZCBpbnRzLlxuICAgIC8vIGluIG90aGVyIGNhc2UgJT0gd2lsbCBmYWlsLlxuICAgIG4gPSBsZW4gPiAyMDAwID8gMjAwMCA6IGxlbjtcbiAgICBsZW4gLT0gbjtcblxuICAgIGRvIHtcbiAgICAgIHMxID0gKHMxICsgYnVmW3BvcysrXSkgfDA7XG4gICAgICBzMiA9IChzMiArIHMxKSB8MDtcbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgczEgJT0gNjU1MjE7XG4gICAgczIgJT0gNjU1MjE7XG4gIH1cblxuICByZXR1cm4gKHMxIHwgKHMyIDw8IDE2KSkgfDA7XG59O1xuXG5cbnZhciBhZGxlcjMyXzEgPSBhZGxlcjMyO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmNvbnN0IG1ha2VUYWJsZSA9ICgpID0+IHtcbiAgbGV0IGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59O1xuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxuY29uc3QgY3JjVGFibGUgPSBuZXcgVWludDMyQXJyYXkobWFrZVRhYmxlKCkpO1xuXG5cbmNvbnN0IGNyYzMyID0gKGNyYywgYnVmLCBsZW4sIHBvcykgPT4ge1xuICBjb25zdCB0ID0gY3JjVGFibGU7XG4gIGNvbnN0IGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn07XG5cblxudmFyIGNyYzMyXzEgPSBjcmMzMjtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgbWVzc2FnZXMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciBjb25zdGFudHMkMiA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICBaX01FTV9FUlJPUjogICAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuY29uc3QgeyBfdHJfaW5pdCwgX3RyX3N0b3JlZF9ibG9jaywgX3RyX2ZsdXNoX2Jsb2NrLCBfdHJfdGFsbHksIF90cl9hbGlnbiB9ID0gdHJlZXM7XG5cblxuXG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5jb25zdCB7XG4gIFpfTk9fRkxVU0g6IFpfTk9fRkxVU0gkMiwgWl9QQVJUSUFMX0ZMVVNILCBaX0ZVTExfRkxVU0g6IFpfRlVMTF9GTFVTSCQxLCBaX0ZJTklTSDogWl9GSU5JU0gkMywgWl9CTE9DSzogWl9CTE9DSyQxLFxuICBaX09LOiBaX09LJDMsIFpfU1RSRUFNX0VORDogWl9TVFJFQU1fRU5EJDMsIFpfU1RSRUFNX0VSUk9SOiBaX1NUUkVBTV9FUlJPUiQyLCBaX0RBVEFfRVJST1I6IFpfREFUQV9FUlJPUiQyLCBaX0JVRl9FUlJPUjogWl9CVUZfRVJST1IkMSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04kMSxcbiAgWl9GSUxURVJFRCwgWl9IVUZGTUFOX09OTFksIFpfUkxFLCBaX0ZJWEVELCBaX0RFRkFVTFRfU1RSQVRFR1k6IFpfREVGQVVMVF9TVFJBVEVHWSQxLFxuICBaX1VOS05PV04sXG4gIFpfREVGTEFURUQ6IFpfREVGTEFURUQkMlxufSA9IGNvbnN0YW50cyQyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmNvbnN0IE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG5jb25zdCBNQVhfV0JJVFMkMSA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG5jb25zdCBERUZfTUVNX0xFVkVMID0gODtcblxuXG5jb25zdCBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbmNvbnN0IExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbmNvbnN0IExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbmNvbnN0IERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuY29uc3QgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5jb25zdCBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbmNvbnN0IE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbmNvbnN0IE1JTl9NQVRDSCA9IDM7XG5jb25zdCBNQVhfTUFUQ0ggPSAyNTg7XG5jb25zdCBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG5jb25zdCBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbmNvbnN0IElOSVRfU1RBVEUgPSA0MjtcbmNvbnN0IEVYVFJBX1NUQVRFID0gNjk7XG5jb25zdCBOQU1FX1NUQVRFID0gNzM7XG5jb25zdCBDT01NRU5UX1NUQVRFID0gOTE7XG5jb25zdCBIQ1JDX1NUQVRFID0gMTAzO1xuY29uc3QgQlVTWV9TVEFURSA9IDExMztcbmNvbnN0IEZJTklTSF9TVEFURSA9IDY2NjtcblxuY29uc3QgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbmNvbnN0IEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG5jb25zdCBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG5jb25zdCBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxuY29uc3QgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmNvbnN0IGVyciA9IChzdHJtLCBlcnJvckNvZGUpID0+IHtcbiAgc3RybS5tc2cgPSBtZXNzYWdlc1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufTtcblxuY29uc3QgcmFuayA9IChmKSA9PiB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59O1xuXG5jb25zdCB6ZXJvID0gKGJ1ZikgPT4ge1xuICBsZXQgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9XG59O1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cbmxldCBIQVNIX1pMSUIgPSAocywgcHJldiwgZGF0YSkgPT4gKChwcmV2IDw8IHMuaGFzaF9zaGlmdCkgXiBkYXRhKSAmIHMuaGFzaF9tYXNrO1xuLy8gVGhpcyBoYXNoIGNhdXNlcyBsZXNzIGNvbGxpc2lvbnMsIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9pc3N1ZXMvMTM1XG4vLyBCdXQgYnJlYWtzIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vL2xldCBIQVNIX0ZBU1QgPSAocywgcHJldiwgZGF0YSkgPT4gKChwcmV2IDw8IDgpICsgKHByZXYgPj4gOCkgKyAoZGF0YSA8PCA0KSkgJiBzLmhhc2hfbWFzaztcbmxldCBIQVNIID0gSEFTSF9aTElCO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5jb25zdCBmbHVzaF9wZW5kaW5nID0gKHN0cm0pID0+IHtcbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgbGV0IGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICBzdHJtLm91dHB1dC5zZXQocy5wZW5kaW5nX2J1Zi5zdWJhcnJheShzLnBlbmRpbmdfb3V0LCBzLnBlbmRpbmdfb3V0ICsgbGVuKSwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufTtcblxuXG5jb25zdCBmbHVzaF9ibG9ja19vbmx5ID0gKHMsIGxhc3QpID0+IHtcbiAgX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59O1xuXG5cbmNvbnN0IHB1dF9ieXRlID0gKHMsIGIpID0+IHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmNvbnN0IHB1dFNob3J0TVNCID0gKHMsIGIpID0+IHtcblxuICAvLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuY29uc3QgcmVhZF9idWYgPSAoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkgPT4ge1xuXG4gIGxldCBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICBidWYuc2V0KHN0cm0uaW5wdXQuc3ViYXJyYXkoc3RybS5uZXh0X2luLCBzdHJtLm5leHRfaW4gKyBsZW4pLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMl8xKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5jb25zdCBsb25nZXN0X21hdGNoID0gKHMsIGN1cl9tYXRjaCkgPT4ge1xuXG4gIGxldCBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIGxldCBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgbGV0IG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICBsZXQgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIGxldCBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIGNvbnN0IGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgY29uc3QgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIGNvbnN0IHdtYXNrID0gcy53X21hc2s7XG4gIGNvbnN0IHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIGNvbnN0IHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIGxldCBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgbGV0IHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmNvbnN0IGZpbGxfd2luZG93ID0gKHMpID0+IHtcblxuICBjb25zdCBfd19zaXplID0gcy53X3NpemU7XG4gIGxldCBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHMud2luZG93LnNldChzLndpbmRvdy5zdWJhcnJheShfd19zaXplLCBfd19zaXplICsgX3dfc2l6ZSksIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcblxuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcblxuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3N0ciArIDFdKTtcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSk7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICBjb25zdCBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgbGV0IGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5jb25zdCBkZWZsYXRlX3N0b3JlZCA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgbGV0IG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIGNvbnN0IG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCQzKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmNvbnN0IGRlZmxhdGVfZmFzdCA9IChzLCBmbHVzaCkgPT4ge1xuXG4gIGxldCBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIGxldCBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9IEhBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKTtcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gkMykge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5jb25zdCBkZWZsYXRlX3Nsb3cgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgbGV0IGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGxldCBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCQyKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSBIQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSk7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IF90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gkMykge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuY29uc3QgZGVmbGF0ZV9ybGUgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICBsZXQgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIGxldCBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIGNvbnN0IF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIJDIpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSBfdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gkMykge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5jb25zdCBkZWZsYXRlX2h1ZmYgPSAocywgZmx1c2gpID0+IHtcblxuICBsZXQgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gkMikge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gkMykge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufTtcblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG5cbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbmNvbnN0IGNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuY29uc3QgbG1faW5pdCA9IChzKSA9PiB7XG5cbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn07XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEJDI7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyBVaW50MTZBcnJheShIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IFVpbnQxNkFycmF5KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyBVaW50MTZBcnJheSgoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgVWludDE2QXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyBVaW50MTZBcnJheSgyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IFVpbnQxNkFycmF5KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5jb25zdCBkZWZsYXRlUmVzZXRLZWVwID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SJDIpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSCQyO1xuICBfdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0skMztcbn07XG5cblxuY29uc3QgZGVmbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBjb25zdCByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LJDMpIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVTZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQyOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0skMztcbn07XG5cblxuY29uc3QgZGVmbGF0ZUluaXQyID0gKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkgPT4ge1xuXG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cbiAgbGV0IHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OJDEpIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCQyIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUiQyKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgY29uc3QgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IFVpbnQxNkFycmF5KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IFVpbnQxNkFycmF5KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyBVaW50OEFycmF5KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn07XG5cbmNvbnN0IGRlZmxhdGVJbml0ID0gKHN0cm0sIGxldmVsKSA9PiB7XG5cbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCQyLCBNQVhfV0JJVFMkMSwgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZJDEpO1xufTtcblxuXG5jb25zdCBkZWZsYXRlJDIgPSAoc3RybSwgZmx1c2gpID0+IHtcblxuICBsZXQgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLJDEgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IkMikgOiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgY29uc3QgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gkMykpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiQxIDogWl9TVFJFQU1fRVJST1IkMik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgY29uc3Qgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC50aW1lICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDgpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5vcyAmIDB4ZmYpO1xuICAgICAgICBpZiAocy5nemhlYWQuZXh0cmEgJiYgcy5nemhlYWQuZXh0cmEubGVuZ3RoKSB7XG4gICAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZik7XG4gICAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgbGV0IGhlYWRlciA9IChaX0RFRkxBVEVEJDIgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICBsZXQgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQuZXh0cmFbcy5nemluZGV4XSAmIDB4ZmYpO1xuICAgICAgICBzLmd6aW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzJfMShzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBDT01NRU5UX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmNvbW1lbnQvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyXzEoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMl8xKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0skMztcbiAgICB9XG5cbiAgICAvKiBNYWtlIHN1cmUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvIGFuZCBhdm9pZCBkdXBsaWNhdGUgY29uc2VjdXRpdmVcbiAgICAgKiBmbHVzaGVzLiBGb3IgcmVwZWF0ZWQgYW5kIHVzZWxlc3MgY2FsbHMgd2l0aCBaX0ZJTklTSCwgd2Uga2VlcFxuICAgICAqIHJldHVybmluZyBaX1NUUkVBTV9FTkQgaW5zdGVhZCBvZiBaX0JVRl9FUlJPUi5cbiAgICAgKi9cbiAgfSBlbHNlIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHJhbmsoZmx1c2gpIDw9IHJhbmsob2xkX2ZsdXNoKSAmJlxuICAgIGZsdXNoICE9PSBaX0ZJTklTSCQzKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUiQxKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SJDEpO1xuICB9XG5cbiAgLyogU3RhcnQgYSBuZXcgYmxvY2sgb3IgY29udGludWUgdGhlIGN1cnJlbnQgb25lLlxuICAgKi9cbiAgaWYgKHN0cm0uYXZhaWxfaW4gIT09IDAgfHwgcy5sb29rYWhlYWQgIT09IDAgfHxcbiAgICAoZmx1c2ggIT09IFpfTk9fRkxVU0gkMiAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIGxldCBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LJDM7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0skMSkgeyAvKiBGVUxMX0ZMVVNIIG9yIFNZTkNfRkxVU0ggKi9cblxuICAgICAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIDAsIDAsIGZhbHNlKTtcbiAgICAgICAgLyogRm9yIGEgZnVsbCBmbHVzaCwgdGhpcyBlbXB0eSBibG9jayB3aWxsIGJlIHJlY29nbml6ZWRcbiAgICAgICAgICogYXMgYSBzcGVjaWFsIG1hcmtlciBieSBpbmZsYXRlX3N5bmMoKS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9GVUxMX0ZMVVNIJDEpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0skMztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gkMykgeyByZXR1cm4gWl9PSyQzOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EJDM7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyQzIDogWl9TVFJFQU1fRU5EJDM7XG59O1xuXG5cbmNvbnN0IGRlZmxhdGVFbmQgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDI7XG4gIH1cblxuICBjb25zdCBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SJDIpO1xuICB9XG5cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG5cbiAgcmV0dXJuIHN0YXR1cyA9PT0gQlVTWV9TVEFURSA/IGVycihzdHJtLCBaX0RBVEFfRVJST1IkMikgOiBaX09LJDM7XG59O1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuY29uc3QgZGVmbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4ge1xuXG4gIGxldCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMjtcbiAgfVxuXG4gIGNvbnN0IHMgPSBzdHJtLnN0YXRlO1xuICBjb25zdCB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQyO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzJfMShzdHJtLmFkbGVyLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgfVxuXG4gIHMud3JhcCA9IDA7ICAgLyogYXZvaWQgY29tcHV0aW5nIEFkbGVyLTMyIGluIHJlYWRfYnVmICovXG5cbiAgLyogaWYgZGljdGlvbmFyeSB3b3VsZCBmaWxsIHdpbmRvdywganVzdCByZXBsYWNlIHRoZSBoaXN0b3J5ICovXG4gIGlmIChkaWN0TGVuZ3RoID49IHMud19zaXplKSB7XG4gICAgaWYgKHdyYXAgPT09IDApIHsgICAgICAgICAgICAvKiBhbHJlYWR5IGVtcHR5IG90aGVyd2lzZSAqL1xuICAgICAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG4gICAgICBzLnN0cnN0YXJ0ID0gMDtcbiAgICAgIHMuYmxvY2tfc3RhcnQgPSAwO1xuICAgICAgcy5pbnNlcnQgPSAwO1xuICAgIH1cbiAgICAvKiB1c2UgdGhlIHRhaWwgKi9cbiAgICAvLyBkaWN0aW9uYXJ5ID0gZGljdGlvbmFyeS5zbGljZShkaWN0TGVuZ3RoIC0gcy53X3NpemUpO1xuICAgIGxldCB0bXBEaWN0ID0gbmV3IFVpbnQ4QXJyYXkocy53X3NpemUpO1xuICAgIHRtcERpY3Quc2V0KGRpY3Rpb25hcnkuc3ViYXJyYXkoZGljdExlbmd0aCAtIHMud19zaXplLCBkaWN0TGVuZ3RoKSwgMCk7XG4gICAgZGljdGlvbmFyeSA9IHRtcERpY3Q7XG4gICAgZGljdExlbmd0aCA9IHMud19zaXplO1xuICB9XG4gIC8qIGluc2VydCBkaWN0aW9uYXJ5IGludG8gd2luZG93IGFuZCBoYXNoICovXG4gIGNvbnN0IGF2YWlsID0gc3RybS5hdmFpbF9pbjtcbiAgY29uc3QgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgY29uc3QgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gZGljdExlbmd0aDtcbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5pbnB1dCA9IGRpY3Rpb25hcnk7XG4gIGZpbGxfd2luZG93KHMpO1xuICB3aGlsZSAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgbGV0IHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbGV0IG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSk7XG5cbiAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG5cbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgIHN0cisrO1xuICAgIH0gd2hpbGUgKC0tbik7XG4gICAgcy5zdHJzdGFydCA9IHN0cjtcbiAgICBzLmxvb2thaGVhZCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgZmlsbF93aW5kb3cocyk7XG4gIH1cbiAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIHMuaW5zZXJ0ID0gcy5sb29rYWhlYWQ7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmlucHV0ID0gaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBhdmFpbDtcbiAgcy53cmFwID0gd3JhcDtcbiAgcmV0dXJuIFpfT0skMztcbn07XG5cblxudmFyIGRlZmxhdGVJbml0XzEgPSBkZWZsYXRlSW5pdDtcbnZhciBkZWZsYXRlSW5pdDJfMSA9IGRlZmxhdGVJbml0MjtcbnZhciBkZWZsYXRlUmVzZXRfMSA9IGRlZmxhdGVSZXNldDtcbnZhciBkZWZsYXRlUmVzZXRLZWVwXzEgPSBkZWZsYXRlUmVzZXRLZWVwO1xudmFyIGRlZmxhdGVTZXRIZWFkZXJfMSA9IGRlZmxhdGVTZXRIZWFkZXI7XG52YXIgZGVmbGF0ZV8yJDEgPSBkZWZsYXRlJDI7XG52YXIgZGVmbGF0ZUVuZF8xID0gZGVmbGF0ZUVuZDtcbnZhciBkZWZsYXRlU2V0RGljdGlvbmFyeV8xID0gZGVmbGF0ZVNldERpY3Rpb25hcnk7XG52YXIgZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUJvdW5kID0gZGVmbGF0ZUJvdW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xubW9kdWxlLmV4cG9ydHMuZGVmbGF0ZVBlbmRpbmcgPSBkZWZsYXRlUGVuZGluZztcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuXG52YXIgZGVmbGF0ZV8xJDIgPSB7XG5cdGRlZmxhdGVJbml0OiBkZWZsYXRlSW5pdF8xLFxuXHRkZWZsYXRlSW5pdDI6IGRlZmxhdGVJbml0Ml8xLFxuXHRkZWZsYXRlUmVzZXQ6IGRlZmxhdGVSZXNldF8xLFxuXHRkZWZsYXRlUmVzZXRLZWVwOiBkZWZsYXRlUmVzZXRLZWVwXzEsXG5cdGRlZmxhdGVTZXRIZWFkZXI6IGRlZmxhdGVTZXRIZWFkZXJfMSxcblx0ZGVmbGF0ZTogZGVmbGF0ZV8yJDEsXG5cdGRlZmxhdGVFbmQ6IGRlZmxhdGVFbmRfMSxcblx0ZGVmbGF0ZVNldERpY3Rpb25hcnk6IGRlZmxhdGVTZXREaWN0aW9uYXJ5XzEsXG5cdGRlZmxhdGVJbmZvOiBkZWZsYXRlSW5mb1xufTtcblxuY29uc3QgX2hhcyA9IChvYmosIGtleSkgPT4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn07XG5cbnZhciBhc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgY29uc3Qgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG52YXIgZmxhdHRlbkNodW5rcyA9IChjaHVua3MpID0+IHtcbiAgLy8gY2FsY3VsYXRlIGRhdGEgbGVuZ3RoXG4gIGxldCBsZW4gPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICB9XG5cbiAgLy8gam9pbiBjaHVua3NcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcblxuICBmb3IgKGxldCBpID0gMCwgcG9zID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZXQgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBjb21tb24gPSB7XG5cdGFzc2lnbjogYXNzaWduLFxuXHRmbGF0dGVuQ2h1bmtzOiBmbGF0dGVuQ2h1bmtzXG59O1xuXG4vLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xubGV0IFNUUl9BUFBMWV9VSUFfT0sgPSB0cnVlO1xuXG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG5jb25zdCBfdXRmOGxlbiA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG5mb3IgKGxldCBxID0gMDsgcSA8IDI1NjsgcSsrKSB7XG4gIF91dGY4bGVuW3FdID0gKHEgPj0gMjUyID8gNiA6IHEgPj0gMjQ4ID8gNSA6IHEgPj0gMjQwID8gNCA6IHEgPj0gMjI0ID8gMyA6IHEgPj0gMTkyID8gMiA6IDEpO1xufVxuX3V0ZjhsZW5bMjU0XSA9IF91dGY4bGVuWzI1NF0gPSAxOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cblxuLy8gY29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxudmFyIHN0cmluZzJidWYgPSAoc3RyKSA9PiB7XG4gIGlmICh0eXBlb2YgVGV4dEVuY29kZXIgPT09ICdmdW5jdGlvbicgJiYgVGV4dEVuY29kZXIucHJvdG90eXBlLmVuY29kZSkge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbiAgfVxuXG4gIGxldCBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyXG5jb25zdCBidWYyYmluc3RyaW5nID0gKGJ1ZiwgbGVuKSA9PiB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWYubGVuZ3RoID09PSBsZW4gPyBidWYgOiBidWYuc3ViYXJyYXkoMCwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xudmFyIGJ1ZjJzdHJpbmcgPSAoYnVmLCBtYXgpID0+IHtcbiAgY29uc3QgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG5cbiAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyAmJiBUZXh0RGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShidWYuc3ViYXJyYXkoMCwgbWF4KSk7XG4gIH1cblxuICBsZXQgaSwgb3V0O1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIGNvbnN0IHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgbGV0IGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBsZXQgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xudmFyIHV0Zjhib3JkZXIgPSAoYnVmLCBtYXgpID0+IHtcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBsZXQgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcblxudmFyIHN0cmluZ3MgPSB7XG5cdHN0cmluZzJidWY6IHN0cmluZzJidWYsXG5cdGJ1ZjJzdHJpbmc6IGJ1ZjJzdHJpbmcsXG5cdHV0Zjhib3JkZXI6IHV0Zjhib3JkZXJcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxudmFyIHpzdHJlYW0gPSBaU3RyZWFtO1xuXG5jb25zdCB0b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSDogWl9OT19GTFVTSCQxLCBaX1NZTkNfRkxVU0gsIFpfRlVMTF9GTFVTSCwgWl9GSU5JU0g6IFpfRklOSVNIJDIsXG4gIFpfT0s6IFpfT0skMiwgWl9TVFJFQU1fRU5EOiBaX1NUUkVBTV9FTkQkMixcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gIFpfREVGTEFURUQ6IFpfREVGTEFURUQkMVxufSA9IGNvbnN0YW50cyQyO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gbmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiBjb25zdCBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZSQxKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gY29tbW9uLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQkMSxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1lcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgbGV0IG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgenN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICBsZXQgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSyQyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICBkZWZsYXRlXzEkMi5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICBsZXQgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nJDEuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSBkZWZsYXRlXzEkMi5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSyQyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBmbHVzaF9tb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBmbHVzaF9tb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdFxuICogaGF2ZSBgZmx1c2hfbW9kZWAgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nXG4gKiBidWZmZXJzIGFuZCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlJDEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmx1c2hfbW9kZSkge1xuICBjb25zdCBzdHJtID0gdGhpcy5zdHJtO1xuICBjb25zdCBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICBsZXQgc3RhdHVzLCBfZmx1c2hfbW9kZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoZmx1c2hfbW9kZSA9PT0gfn5mbHVzaF9tb2RlKSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGU7XG4gIGVsc2UgX2ZsdXNoX21vZGUgPSBmbHVzaF9tb2RlID09PSB0cnVlID8gWl9GSU5JU0gkMiA6IFpfTk9fRkxVU0gkMTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmckMS5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGZvciAoOzspIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGF2YWlsX291dCA+IDYgdG8gYXZvaWQgcmVwZWF0aW5nIG1hcmtlcnNcbiAgICBpZiAoKF9mbHVzaF9tb2RlID09PSBaX1NZTkNfRkxVU0ggfHwgX2ZsdXNoX21vZGUgPT09IFpfRlVMTF9GTFVTSCkgJiYgc3RybS5hdmFpbF9vdXQgPD0gNikge1xuICAgICAgdGhpcy5vbkRhdGEoc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gZGVmbGF0ZV8xJDIuZGVmbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG5cbiAgICAvLyBFbmRlZCA9PiBmbHVzaCBhbmQgZmluaXNoXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EJDIpIHtcbiAgICAgIGlmIChzdHJtLm5leHRfb3V0ID4gMCkge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgICBzdGF0dXMgPSBkZWZsYXRlXzEkMi5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0skMjtcbiAgICB9XG5cbiAgICAvLyBGbHVzaCBpZiBvdXQgYnVmZmVyIGZ1bGxcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEZsdXNoIGlmIHJlcXVlc3RlZCBhbmQgaGFzIGRhdGFcbiAgICBpZiAoX2ZsdXNoX21vZGUgPiAwICYmIHN0cm0ubmV4dF9vdXQgPiAwKSB7XG4gICAgICB0aGlzLm9uRGF0YShzdHJtLm91dHB1dC5zdWJhcnJheSgwLCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheSk6IG91dHB1dCBkYXRhLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZSQxLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUkMS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0skMikge1xuICAgIHRoaXMucmVzdWx0ID0gY29tbW9uLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZSQxKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1lc3NhZ2VzW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXlcbiAqIC0gZGF0YSAoVWludDhBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwJDEoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbnZhciBEZWZsYXRlXzEkMSA9IERlZmxhdGUkMTtcbnZhciBkZWZsYXRlXzIgPSBkZWZsYXRlJDE7XG52YXIgZGVmbGF0ZVJhd18xJDEgPSBkZWZsYXRlUmF3JDE7XG52YXIgZ3ppcF8xJDEgPSBnemlwJDE7XG52YXIgY29uc3RhbnRzJDEgPSBjb25zdGFudHMkMjtcblxudmFyIGRlZmxhdGVfMSQxID0ge1xuXHREZWZsYXRlOiBEZWZsYXRlXzEkMSxcblx0ZGVmbGF0ZTogZGVmbGF0ZV8yLFxuXHRkZWZsYXRlUmF3OiBkZWZsYXRlUmF3XzEkMSxcblx0Z3ppcDogZ3ppcF8xJDEsXG5cdGNvbnN0YW50czogY29uc3RhbnRzJDFcbn07XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG5jb25zdCBCQUQkMSA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCBUWVBFJDEgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbnZhciBpbmZmYXN0ID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIGxldCBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIGxldCBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgbGV0IF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIGxldCBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGxldCBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIGxldCB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgbGV0IHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgbGV0IHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICBsZXQgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIGxldCBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgbGV0IGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICBsZXQgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIGxldCBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIGxldCBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgbGV0IGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIGxldCBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgbGV0IG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIGxldCBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICBsZXQgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIGxldCBmcm9tX3NvdXJjZTtcblxuXG4gIGxldCBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQkMTtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFJDE7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEJDE7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmNvbnN0IE1BWEJJVFMgPSAxNTtcbmNvbnN0IEVOT1VHSF9MRU5TJDEgPSA4NTI7XG5jb25zdCBFTk9VR0hfRElTVFMkMSA9IDU5Mjtcbi8vY29uc3QgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbmNvbnN0IENPREVTJDEgPSAwO1xuY29uc3QgTEVOUyQxID0gMTtcbmNvbnN0IERJU1RTJDEgPSAyO1xuXG5jb25zdCBsYmFzZSA9IG5ldyBVaW50MTZBcnJheShbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dKTtcblxuY29uc3QgbGV4dCA9IG5ldyBVaW50OEFycmF5KFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dKTtcblxuY29uc3QgZGJhc2UgPSBuZXcgVWludDE2QXJyYXkoWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dKTtcblxuY29uc3QgZGV4dCA9IG5ldyBVaW50OEFycmF5KFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dKTtcblxuY29uc3QgaW5mbGF0ZV90YWJsZSA9ICh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKSA9Plxue1xuICBjb25zdCBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICBsZXQgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICBsZXQgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgbGV0IG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIGxldCByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIGxldCBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIGxldCBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgbGV0IGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICBsZXQgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICBsZXQgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgbGV0IGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIGxldCBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgbGV0IGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIGxldCBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICBsZXQgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgbGV0IGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgbGV0IGJhc2VfaW5kZXggPSAwO1xuLy8gIGxldCBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgbGV0IGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIGNvbnN0IGNvdW50ID0gbmV3IFVpbnQxNkFycmF5KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIGNvbnN0IG9mZnMgPSBuZXcgVWludDE2QXJyYXkoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgbGV0IGV4dHJhID0gbnVsbDtcbiAgbGV0IGV4dHJhX2luZGV4ID0gMDtcblxuICBsZXQgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMkMSB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMkMSkge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUyQxKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyQxICYmIHVzZWQgPiBFTk9VR0hfTEVOUyQxKSB8fFxuICAgICh0eXBlID09PSBESVNUUyQxICYmIHVzZWQgPiBFTk9VR0hfRElTVFMkMSkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyQxICYmIHVzZWQgPiBFTk9VR0hfTEVOUyQxKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMkMSAmJiB1c2VkID4gRU5PVUdIX0RJU1RTJDEpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuXG5cbnZhciBpbmZ0cmVlcyA9IGluZmxhdGVfdGFibGU7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuXG5cblxuXG5cbmNvbnN0IENPREVTID0gMDtcbmNvbnN0IExFTlMgPSAxO1xuY29uc3QgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuY29uc3Qge1xuICBaX0ZJTklTSDogWl9GSU5JU0gkMSwgWl9CTE9DSywgWl9UUkVFUyxcbiAgWl9PSzogWl9PSyQxLCBaX1NUUkVBTV9FTkQ6IFpfU1RSRUFNX0VORCQxLCBaX05FRURfRElDVDogWl9ORUVEX0RJQ1QkMSwgWl9TVFJFQU1fRVJST1I6IFpfU1RSRUFNX0VSUk9SJDEsIFpfREFUQV9FUlJPUjogWl9EQVRBX0VSUk9SJDEsIFpfTUVNX0VSUk9SOiBaX01FTV9FUlJPUiQxLCBaX0JVRl9FUlJPUixcbiAgWl9ERUZMQVRFRFxufSA9IGNvbnN0YW50cyQyO1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmNvbnN0ICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbmNvbnN0ICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xuY29uc3QgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xuY29uc3QgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xuY29uc3QgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbmNvbnN0ICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbmNvbnN0ICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xuY29uc3QgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xuY29uc3QgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG5jb25zdCAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xuY29uc3QgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xuY29uc3QgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5jb25zdCAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbmNvbnN0ICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbmNvbnN0ICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbmNvbnN0ICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbmNvbnN0ICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG5jb25zdCAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuY29uc3QgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbmNvbnN0ICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG5jb25zdCAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG5jb25zdCAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xuY29uc3QgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xuY29uc3QgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xuY29uc3QgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG5jb25zdCAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xuY29uc3QgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xuY29uc3QgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG5jb25zdCAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG5jb25zdCAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbmNvbnN0ICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbmNvbnN0IEVOT1VHSF9MRU5TID0gODUyO1xuY29uc3QgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy9jb25zdCBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbmNvbnN0IE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG5jb25zdCBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuY29uc3QgenN3YXAzMiA9IChxKSA9PiB7XG5cbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59O1xuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyBVaW50MTZBcnJheSgzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyBVaW50MTZBcnJheSgyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgSW50MzJBcnJheShFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5cbmNvbnN0IGluZmxhdGVSZXNldEtlZXAgPSAoc3RybSkgPT4ge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyBJbnQzMkFycmF5KEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IEludDMyQXJyYXkoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVJlc2V0ID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufTtcblxuXG5jb25zdCBpbmZsYXRlUmVzZXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcbiAgbGV0IHdyYXA7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgY29uc3Qgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZUluaXQyID0gKHN0cm0sIHdpbmRvd0JpdHMpID0+IHtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIGNvbnN0IHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0skMSkge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBpbmZsYXRlSW5pdCA9IChzdHJtKSA9PiB7XG5cbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufTtcblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG5sZXQgdmlyZ2luID0gdHJ1ZTtcblxubGV0IGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuXG5jb25zdCBmaXhlZHRhYmxlcyA9IChzdGF0ZSkgPT4ge1xuXG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICBsZW5maXggPSBuZXcgSW50MzJBcnJheSg1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgSW50MzJBcnJheSgzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIGxldCBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZ0cmVlcyhMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZnRyZWVzKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufTtcblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuY29uc3QgdXBkYXRld2luZG93ID0gKHN0cm0sIHNyYywgZW5kLCBjb3B5KSA9PiB7XG5cbiAgbGV0IGRpc3Q7XG4gIGNvbnN0IHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyBVaW50OEFycmF5KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHN0YXRlLndpbmRvdy5zZXQoc3JjLnN1YmFycmF5KGVuZCAtIHN0YXRlLndzaXplLCBlbmQpLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgc3RhdGUud2luZG93LnNldChzcmMuc3ViYXJyYXkoZW5kIC0gY29weSwgZW5kIC0gY29weSArIGRpc3QpLCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICBzdGF0ZS53aW5kb3cuc2V0KHNyYy5zdWJhcnJheShlbmQgLSBjb3B5LCBlbmQpLCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufTtcblxuXG5jb25zdCBpbmZsYXRlJDIgPSAoc3RybSwgZmx1c2gpID0+IHtcblxuICBsZXQgc3RhdGU7XG4gIGxldCBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICBsZXQgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICBsZXQgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgbGV0IGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIGxldCBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIGxldCBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgbGV0IF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgbGV0IGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICBsZXQgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIGxldCBmcm9tX3NvdXJjZTtcbiAgbGV0IGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgbGV0IGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vbGV0IGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICBsZXQgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgbGV0IGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgbGV0IHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIGNvbnN0IGhidWYgPSBuZXcgVWludDhBcnJheSg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgbGV0IG9wdHM7XG5cbiAgbGV0IG47IC8vIHRlbXBvcmFyeSB2YXJpYWJsZSBmb3IgTkVFRF9CSVRTXG5cbiAgY29uc3Qgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBuZXcgVWludDhBcnJheShbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXSk7XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSyQxO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAhISEgcGFrbyBwYXRjaC4gRm9yY2UgdXNlIGBvcHRpb25zLndpbmRvd0JpdHNgIGlmIHBhc3NlZC5cbiAgICAgICAgLy8gUmVxdWlyZWQgdG8gYWx3YXlzIHVzZSBtYXggd2luZG93IHNpemUgYnkgZGVmYXVsdC5cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgICAgIC8vc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRkxBR1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzJfMShzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IFVpbnQ4QXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEuc2V0KFxuICAgICAgICAgICAgICAgIGlucHV0LnN1YmFycmF5KFxuICAgICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgICBuZXh0ICsgY29weVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyXzEoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMl8xKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVCQxO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgb3V0cHV0LnNldChpbnB1dC5zdWJhcnJheShuZXh0LCBuZXh0ICsgY29weSksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZ0cmVlcyhDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZnRyZWVzKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mdHJlZXMoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTl86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOOlxuICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICBpbmZmYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EJDE7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1IkMTtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBNRU06XG4gICAgICAgIHJldHVybiBaX01FTV9FUlJPUiQxO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gkMSkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkgO1xuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyXzEoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMl8xKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gkMSkgJiYgcmV0ID09PSBaX09LJDEpIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuXG5jb25zdCBpbmZsYXRlRW5kID0gKHN0cm0pID0+IHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUiQxO1xuICB9XG5cbiAgbGV0IHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LJDE7XG59O1xuXG5cbmNvbnN0IGluZmxhdGVHZXRIZWFkZXIgPSAoc3RybSwgaGVhZCkgPT4ge1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1IkMTsgfVxuICBjb25zdCBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0skMTtcbn07XG5cblxuY29uc3QgaW5mbGF0ZVNldERpY3Rpb25hcnkgPSAoc3RybSwgZGljdGlvbmFyeSkgPT4ge1xuICBjb25zdCBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgbGV0IHN0YXRlO1xuICBsZXQgZGljdGlkO1xuICBsZXQgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUiQxOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SJDE7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMl8xKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1IkMTtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1IkMTtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSyQxO1xufTtcblxuXG52YXIgaW5mbGF0ZVJlc2V0XzEgPSBpbmZsYXRlUmVzZXQ7XG52YXIgaW5mbGF0ZVJlc2V0Ml8xID0gaW5mbGF0ZVJlc2V0MjtcbnZhciBpbmZsYXRlUmVzZXRLZWVwXzEgPSBpbmZsYXRlUmVzZXRLZWVwO1xudmFyIGluZmxhdGVJbml0XzEgPSBpbmZsYXRlSW5pdDtcbnZhciBpbmZsYXRlSW5pdDJfMSA9IGluZmxhdGVJbml0MjtcbnZhciBpbmZsYXRlXzIkMSA9IGluZmxhdGUkMjtcbnZhciBpbmZsYXRlRW5kXzEgPSBpbmZsYXRlRW5kO1xudmFyIGluZmxhdGVHZXRIZWFkZXJfMSA9IGluZmxhdGVHZXRIZWFkZXI7XG52YXIgaW5mbGF0ZVNldERpY3Rpb25hcnlfMSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xudmFyIGluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xubW9kdWxlLmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5tb2R1bGUuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbm1vZHVsZS5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cblxudmFyIGluZmxhdGVfMSQyID0ge1xuXHRpbmZsYXRlUmVzZXQ6IGluZmxhdGVSZXNldF8xLFxuXHRpbmZsYXRlUmVzZXQyOiBpbmZsYXRlUmVzZXQyXzEsXG5cdGluZmxhdGVSZXNldEtlZXA6IGluZmxhdGVSZXNldEtlZXBfMSxcblx0aW5mbGF0ZUluaXQ6IGluZmxhdGVJbml0XzEsXG5cdGluZmxhdGVJbml0MjogaW5mbGF0ZUluaXQyXzEsXG5cdGluZmxhdGU6IGluZmxhdGVfMiQxLFxuXHRpbmZsYXRlRW5kOiBpbmZsYXRlRW5kXzEsXG5cdGluZmxhdGVHZXRIZWFkZXI6IGluZmxhdGVHZXRIZWFkZXJfMSxcblx0aW5mbGF0ZVNldERpY3Rpb25hcnk6IGluZmxhdGVTZXREaWN0aW9uYXJ5XzEsXG5cdGluZmxhdGVJbmZvOiBpbmZsYXRlSW5mb1xufTtcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxudmFyIGd6aGVhZGVyID0gR1poZWFkZXI7XG5cbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbmNvbnN0IHtcbiAgWl9OT19GTFVTSCwgWl9GSU5JU0gsXG4gIFpfT0ssIFpfU1RSRUFNX0VORCwgWl9ORUVEX0RJQ1QsIFpfU1RSRUFNX0VSUk9SLCBaX0RBVEFfRVJST1IsIFpfTUVNX0VSUk9SXG59ID0gY29uc3RhbnRzJDI7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqIGNvbnN0IGNodW5rMSA9IG5ldyBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiBjb25zdCBjaHVuazIgPSBuZXcgVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiBjb25zdCBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZSQxKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gY29tbW9uLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxMDI0ICogNjQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIGNvbnN0IG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyB6c3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIGxldCBzdGF0dXMgID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBnemhlYWRlcigpO1xuXG4gIGluZmxhdGVfMSQyLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG5cbiAgLy8gU2V0dXAgZGljdGlvbmFyeVxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIGZsdXNoX21vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXIpOiBpbnB1dCBkYXRhXG4gKiAtIGZsdXNoX21vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUVcbiAqICAgZmx1c2ggbW9kZXMuIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILFxuICogICBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBJZiBlbmQgb2Ygc3RyZWFtIGRldGVjdGVkLFxuICogW1tJbmZsYXRlI29uRW5kXV0gd2lsbCBiZSBjYWxsZWQuXG4gKlxuICogYGZsdXNoX21vZGVgIGlzIG5vdCBuZWVkZWQgZm9yIG5vcm1hbCBvcGVyYXRpb24sIGJlY2F1c2UgZW5kIG9mIHN0cmVhbVxuICogZGV0ZWN0ZWQgYXV0b21hdGljYWxseS4gWW91IG1heSB0cnkgdG8gdXNlIGl0IGZvciBhZHZhbmNlZCB0aGluZ3MsIGJ1dFxuICogdGhpcyBmdW5jdGlvbmFsaXR5IHdhcyBub3QgdGVzdGVkLlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlJDEucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgZmx1c2hfbW9kZSkge1xuICBjb25zdCBzdHJtID0gdGhpcy5zdHJtO1xuICBjb25zdCBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICBjb25zdCBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIGxldCBzdGF0dXMsIF9mbHVzaF9tb2RlLCBsYXN0X2F2YWlsX291dDtcblxuICBpZiAodGhpcy5lbmRlZCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChmbHVzaF9tb2RlID09PSB+fmZsdXNoX21vZGUpIF9mbHVzaF9tb2RlID0gZmx1c2hfbW9kZTtcbiAgZWxzZSBfZmx1c2hfbW9kZSA9IGZsdXNoX21vZGUgPT09IHRydWUgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0g7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSk7XG5cbiAgICAgIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZShzdHJtLCBfZmx1c2hfbW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gWl9EQVRBX0VSUk9SKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgY29kZSB3aXRoIG1vcmUgdmVyYm9zZVxuICAgICAgICBzdGF0dXMgPSBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTa2lwIHNueWMgbWFya2VycyBpZiBtb3JlIGRhdGEgZm9sbG93cyBhbmQgbm90IHJhdyBtb2RlXG4gICAgd2hpbGUgKHN0cm0uYXZhaWxfaW4gPiAwICYmXG4gICAgICAgICAgIHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EICYmXG4gICAgICAgICAgIHN0cm0uc3RhdGUud3JhcCA+IDAgJiZcbiAgICAgICAgICAgZGF0YVtzdHJtLm5leHRfaW5dICE9PSAwKVxuICAgIHtcbiAgICAgIGluZmxhdGVfMSQyLmluZmxhdGVSZXNldChzdHJtKTtcbiAgICAgIHN0YXR1cyA9IGluZmxhdGVfMSQyLmluZmxhdGUoc3RybSwgX2ZsdXNoX21vZGUpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFpfU1RSRUFNX0VSUk9SOlxuICAgICAgY2FzZSBaX0RBVEFfRVJST1I6XG4gICAgICBjYXNlIFpfTkVFRF9ESUNUOlxuICAgICAgY2FzZSBaX01FTV9FUlJPUjpcbiAgICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlbWVtYmVyIHJlYWwgYGF2YWlsX291dGAgdmFsdWUsIGJlY2F1c2Ugd2UgbWF5IHBhdGNoIG91dCBidWZmZXIgY29udGVudFxuICAgIC8vIHRvIGFsaWduIHV0Zjggc3RyaW5ncyBib3VuZGFyaWVzLlxuICAgIGxhc3RfYXZhaWxfb3V0ID0gc3RybS5hdmFpbF9vdXQ7XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gWl9TVFJFQU1fRU5EKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIGxldCBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIGxldCB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgbGV0IHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsICYgcmVhbGlnbiBjb3VudGVyc1xuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgc3RybS5vdXRwdXQuc2V0KHN0cm0ub3V0cHV0LnN1YmFycmF5KG5leHRfb3V0X3V0ZjgsIG5leHRfb3V0X3V0ZjggKyB0YWlsKSwgMCk7XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHN0cm0ub3V0cHV0Lmxlbmd0aCA9PT0gc3RybS5uZXh0X291dCA/IHN0cm0ub3V0cHV0IDogc3RybS5vdXRwdXQuc3ViYXJyYXkoMCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTXVzdCByZXBlYXQgaXRlcmF0aW9uIGlmIG91dCBidWZmZXIgaXMgZnVsbFxuICAgIGlmIChzdGF0dXMgPT09IFpfT0sgJiYgbGFzdF9hdmFpbF9vdXQgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgLy8gRmluYWxpemUgaWYgZW5kIG9mIHN0cmVhbSByZWFjaGVkLlxuICAgIGlmIChzdGF0dXMgPT09IFpfU1RSRUFNX0VORCkge1xuICAgICAgc3RhdHVzID0gaW5mbGF0ZV8xJDIuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgZWFjaCBjaHVuayB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUkMS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUkMS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSBjb21tb24uZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXkpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBwYWtvID0gcmVxdWlyZSgncGFrbycpO1xuICogY29uc3QgaW5wdXQgPSBwYWtvLmRlZmxhdGUobmV3IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSkpO1xuICogbGV0IG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKSB7XG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUkMShpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBpbmZsYXRvciA9IG5ldyBJbmZsYXRlJDEob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1lc3NhZ2VzW2luZmxhdG9yLmVycl07XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5KTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyQxKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlJDEoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheSk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG52YXIgSW5mbGF0ZV8xJDEgPSBJbmZsYXRlJDE7XG52YXIgaW5mbGF0ZV8yID0gaW5mbGF0ZSQxO1xudmFyIGluZmxhdGVSYXdfMSQxID0gaW5mbGF0ZVJhdyQxO1xudmFyIHVuZ3ppcCQxID0gaW5mbGF0ZSQxO1xudmFyIGNvbnN0YW50cyA9IGNvbnN0YW50cyQyO1xuXG52YXIgaW5mbGF0ZV8xJDEgPSB7XG5cdEluZmxhdGU6IEluZmxhdGVfMSQxLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzIsXG5cdGluZmxhdGVSYXc6IGluZmxhdGVSYXdfMSQxLFxuXHR1bmd6aXA6IHVuZ3ppcCQxLFxuXHRjb25zdGFudHM6IGNvbnN0YW50c1xufTtcblxuY29uc3QgeyBEZWZsYXRlLCBkZWZsYXRlLCBkZWZsYXRlUmF3LCBnemlwIH0gPSBkZWZsYXRlXzEkMTtcblxuY29uc3QgeyBJbmZsYXRlLCBpbmZsYXRlLCBpbmZsYXRlUmF3LCB1bmd6aXAgfSA9IGluZmxhdGVfMSQxO1xuXG5cblxudmFyIERlZmxhdGVfMSA9IERlZmxhdGU7XG52YXIgZGVmbGF0ZV8xID0gZGVmbGF0ZTtcbnZhciBkZWZsYXRlUmF3XzEgPSBkZWZsYXRlUmF3O1xudmFyIGd6aXBfMSA9IGd6aXA7XG52YXIgSW5mbGF0ZV8xID0gSW5mbGF0ZTtcbnZhciBpbmZsYXRlXzEgPSBpbmZsYXRlO1xudmFyIGluZmxhdGVSYXdfMSA9IGluZmxhdGVSYXc7XG52YXIgdW5nemlwXzEgPSB1bmd6aXA7XG52YXIgY29uc3RhbnRzXzEgPSBjb25zdGFudHMkMjtcblxudmFyIHBha28gPSB7XG5cdERlZmxhdGU6IERlZmxhdGVfMSxcblx0ZGVmbGF0ZTogZGVmbGF0ZV8xLFxuXHRkZWZsYXRlUmF3OiBkZWZsYXRlUmF3XzEsXG5cdGd6aXA6IGd6aXBfMSxcblx0SW5mbGF0ZTogSW5mbGF0ZV8xLFxuXHRpbmZsYXRlOiBpbmZsYXRlXzEsXG5cdGluZmxhdGVSYXc6IGluZmxhdGVSYXdfMSxcblx0dW5nemlwOiB1bmd6aXBfMSxcblx0Y29uc3RhbnRzOiBjb25zdGFudHNfMVxufTtcblxuZXhwb3J0IHsgRGVmbGF0ZV8xIGFzIERlZmxhdGUsIEluZmxhdGVfMSBhcyBJbmZsYXRlLCBjb25zdGFudHNfMSBhcyBjb25zdGFudHMsIHBha28gYXMgZGVmYXVsdCwgZGVmbGF0ZV8xIGFzIGRlZmxhdGUsIGRlZmxhdGVSYXdfMSBhcyBkZWZsYXRlUmF3LCBnemlwXzEgYXMgZ3ppcCwgaW5mbGF0ZV8xIGFzIGluZmxhdGUsIGluZmxhdGVSYXdfMSBhcyBpbmZsYXRlUmF3LCB1bmd6aXBfMSBhcyB1bmd6aXAgfTtcbiIsIi8qXG4gKiBtaW5pbHpvLWpzXG4gKiBKYXZhU2NyaXB0IHBvcnQgb2YgbWluaWx6byBieSBBbGlzdGFpciBCcmFpZHdvb2RcbiAqXG4gKlxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICogIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzXG4gKiAgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlciB2ZXJzaW9uIDIgb2ZcbiAqICB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogIGFsb25nIHdpdGggdGhlIG1pbmlsem8tanMgbGlicmFyeTsgc2VlIHRoZSBmaWxlIENPUFlJTkcuXG4gKiAgSWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBJbmMuLFxuICogIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSwgVVNBLlxuICovXG5cbi8qXG4gKiBvcmlnaW5hbCBtaW5pbHpvLmMgYnk6XG4gKlxuICogTWFya3VzIEYuWC5KLiBPYmVyaHVtZXJcbiAqIDxtYXJrdXNAb2Jlcmh1bWVyLmNvbT5cbiAqIGh0dHA6Ly93d3cub2Jlcmh1bWVyLmNvbS9vcGVuc291cmNlL2x6by9cbiAqL1xuXG4vKlxuICogTk9URTpcbiAqICAgdGhlIGZ1bGwgTFpPIHBhY2thZ2UgY2FuIGJlIGZvdW5kIGF0XG4gKiAgIGh0dHA6Ly93d3cub2Jlcmh1bWVyLmNvbS9vcGVuc291cmNlL2x6by9cbiAqL1xuXG5leHBvcnQgbGV0IGx6byA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IF9sem8xeCA9IGZ1bmN0aW9uKCkge1xuICB9IGFzIGFueTtcblxuICBfbHpvMXgucHJvdG90eXBlID0ge1xuICAgICAgYmxvY2tTaXplOiA0MDk2LFxuXG4gICAgICBPSzogMCxcbiAgICAgIElOUFVUX09WRVJSVU46IC00LFxuICAgICAgT1VUUFVUX09WRVJSVU46IC01LFxuICAgICAgTE9PS0JFSElORF9PVkVSUlVOOiAtNixcbiAgICAgIEVPRl9GT1VORDogLTk5OSxcblxuICAgICAgYnVmOiBudWxsLFxuICAgICAgYnVmMzI6IG51bGwsXG5cbiAgICAgIG91dDogbnVsbCxcbiAgICAgIG91dDMyOiBudWxsLFxuICAgICAgY2JsOiAwLFxuICAgICAgaXBfZW5kOiAwLFxuICAgICAgb3BfZW5kOiAwLFxuICAgICAgdDogMCxcblxuICAgICAgaXA6IDAsXG4gICAgICBvcDogMCxcbiAgICAgIG1fcG9zOiAwLFxuXG4gICAgICBza2lwVG9GaXJzdExpdGVyYWxGdW46IGZhbHNlLFxuXG4gICAgICBleHRlbmRCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsZXQgbmV3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5jYmwgKyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICAgICAgbmV3QnVmZmVyLnNldCh0aGlzLm91dCk7XG4gICAgICAgICAgdGhpcy5vdXQgPSBuZXdCdWZmZXI7XG4gICAgICAgICAgdGhpcy5vdXQzMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLm91dC5idWZmZXIpO1xuICAgICAgICAgIHRoaXMuc3RhdGUub3V0cHV0QnVmZmVyID0gdGhpcy5vdXQ7XG4gICAgICAgICAgdGhpcy5jYmwgPSB0aGlzLm91dC5sZW5ndGg7XG4gICAgICB9LFxuXG4gICAgICBtYXRjaF9uZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gaWYgKG9wX2VuZCAtIG9wIDwgdCkgcmV0dXJuIE9VVFBVVF9PVkVSUlVOO1xuICAgICAgICAgIC8vIGlmIChpcF9lbmQgLSBpcCA8IHQrMykgcmV0dXJuIElOUFVUX09WRVJSVU47XG5cbiAgICAgICAgICB3aGlsZSAodGhpcy5vcCArIDMgPiB0aGlzLmNibCkge1xuICAgICAgICAgICAgICB0aGlzLmV4dGVuZEJ1ZmZlcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSB0aGlzLmJ1Zlt0aGlzLmlwKytdO1xuICAgICAgICAgIGlmICh0aGlzLnQgPiAxKSB7XG4gICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSB0aGlzLmJ1Zlt0aGlzLmlwKytdO1xuICAgICAgICAgICAgICBpZiAodGhpcy50ID4gMikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IHRoaXMuYnVmW3RoaXMuaXArK107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnQgPSB0aGlzLmJ1Zlt0aGlzLmlwKytdO1xuICAgICAgfSxcblxuICAgICAgbWF0Y2hfZG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudCA9IHRoaXMuYnVmW3RoaXMuaXAgLSAyXSAmIDM7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudDtcbiAgICAgIH0sXG5cbiAgICAgIGNvcHlfbWF0Y2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnQgKz0gMjtcbiAgICAgICAgICB3aGlsZSAodGhpcy5vcCArIHRoaXMudCA+IHRoaXMuY2JsKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXh0ZW5kQnVmZmVyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMudCA+IDQgJiYgdGhpcy5vcCAlIDQgPT09IHRoaXMubV9wb3MgJSA0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wICUgNCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSB0aGlzLm91dFt0aGlzLm1fcG9zKytdO1xuICAgICAgICAgICAgICAgICAgdGhpcy50LS07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB3aGlsZSAodGhpcy50ID4gNCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vdXQzMlswIHwgKHRoaXMub3AgLyA0KV0gPSB0aGlzLm91dDMyWzAgfCAodGhpcy5tX3BvcyAvIDQpXTtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3AgKz0gNDtcbiAgICAgICAgICAgICAgICAgIHRoaXMubV9wb3MgKz0gNDtcbiAgICAgICAgICAgICAgICAgIHRoaXMudCAtPSA0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICB0aGlzLm91dFt0aGlzLm9wKytdID0gdGhpcy5vdXRbdGhpcy5tX3BvcysrXTtcbiAgICAgICAgICB9IHdoaWxlICgtLXRoaXMudCA+IDApO1xuICAgICAgfSxcblxuICAgICAgY29weV9mcm9tX2J1ZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdoaWxlICh0aGlzLm9wICsgdGhpcy50ID4gdGhpcy5jYmwpIHtcbiAgICAgICAgICAgICAgdGhpcy5leHRlbmRCdWZmZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy50ID4gNCAmJiB0aGlzLm9wICUgNCA9PT0gdGhpcy5pcCAlIDQpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHRoaXMub3AgJSA0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IHRoaXMuYnVmW3RoaXMuaXArK107XG4gICAgICAgICAgICAgICAgICB0aGlzLnQtLTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHdoaWxlICh0aGlzLnQgPiA0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm91dDMyWzAgfCAodGhpcy5vcCAvIDQpXSA9IHRoaXMuYnVmMzJbMCB8ICh0aGlzLmlwIC8gNCldO1xuICAgICAgICAgICAgICAgICAgdGhpcy5vcCArPSA0O1xuICAgICAgICAgICAgICAgICAgdGhpcy5pcCArPSA0O1xuICAgICAgICAgICAgICAgICAgdGhpcy50IC09IDQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSB0aGlzLmJ1Zlt0aGlzLmlwKytdO1xuICAgICAgICAgIH0gd2hpbGUgKC0tdGhpcy50ID4gMCk7XG4gICAgICB9LFxuXG4gICAgICBtYXRjaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAoOyA7KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnQgPj0gNjQpIHtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5tX3BvcyA9IHRoaXMub3AgLSAxO1xuICAgICAgICAgICAgICAgICAgdGhpcy5tX3BvcyAtPSAodGhpcy50ID4+IDIpICYgNztcbiAgICAgICAgICAgICAgICAgIHRoaXMubV9wb3MgLT0gdGhpcy5idWZbdGhpcy5pcCsrXSA8PCAzO1xuICAgICAgICAgICAgICAgICAgdGhpcy50ID0gKHRoaXMudCA+PiA1KSAtIDE7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGlmICggbV9wb3MgPCBvdXQgfHwgbV9wb3MgPj0gb3ApIHJldHVybiBMT09LQkVISU5EX09WRVJSVU47XG4gICAgICAgICAgICAgICAgICAvLyBpZiAob3BfZW5kIC0gb3AgPCB0KzMtMSkgcmV0dXJuIE9VVFBVVF9PVkVSUlVOO1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLmNvcHlfbWF0Y2goKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hfZG9uZSgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hfbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50ID49IDMyKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnQgJj0gMzE7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3RoaXMuaXBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCArPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHQgPiAtNTExKSByZXR1cm4gT1VUUFVUX09WRVJSVU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChpcF9lbmQgLSBpcCA8IDEpIHJldHVybiBJTlBVVF9PVkVSUlVOO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnQgKz0gMzEgKyB0aGlzLmJ1Zlt0aGlzLmlwKytdO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChpcF9lbmQgLSBpcCA8IDIpIHJldHVybiBJTlBVVF9PVkVSUlVOO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB0aGlzLm1fcG9zID0gdGhpcy5vcCAtIDE7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1fcG9zIC09ICh0aGlzLmJ1Zlt0aGlzLmlwXSA+PiAyKSArICh0aGlzLmJ1Zlt0aGlzLmlwICsgMV0gPDwgNik7XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuaXAgKz0gMjtcblxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudCA+PSAxNikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5tX3BvcyA9IHRoaXMub3A7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1fcG9zIC09ICh0aGlzLnQgJiA4KSA8PCAxMTtcblxuICAgICAgICAgICAgICAgICAgdGhpcy50ICY9IDc7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuYnVmW3RoaXMuaXBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCArPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHQgPiAtNTExKSByZXR1cm4gT1VUUFVUX09WRVJSVU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChpcF9lbmQgLSBpcCA8IDEpIHJldHVybiBJTlBVVF9PVkVSUlVOO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnQgKz0gNyArIHRoaXMuYnVmW3RoaXMuaXArK107XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGlwX2VuZCAtIGlwIDwgMikgcmV0dXJuIElOUFVUX09WRVJSVU47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMubV9wb3MgLT0gKHRoaXMuYnVmW3RoaXMuaXBdID4+IDIpICsgKHRoaXMuYnVmW3RoaXMuaXAgKyAxXSA8PCA2KTtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5pcCArPSAyO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubV9wb3MgPT09IHRoaXMub3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm91dHB1dEJ1ZmZlciA9IHRoaXMuc3RhdGUub3V0cHV0QnVmZmVyLnN1YmFycmF5KDAsIHRoaXMub3ApO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRl9GT1VORDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMubV9wb3MgLT0gMHg0MDAwO1xuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1fcG9zID0gdGhpcy5vcCAtIDE7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1fcG9zIC09IHRoaXMudCA+PiAyO1xuICAgICAgICAgICAgICAgICAgdGhpcy5tX3BvcyAtPSB0aGlzLmJ1Zlt0aGlzLmlwKytdIDw8IDI7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGlmIChtX3BvcyA8IG91dCB8fCBtX3BvcyA+PSBvcCkgcmV0dXJuIExPT0tCRUhJTkRfT1ZFUlJVTjtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIChvcF9lbmQgLSBvcCA8IDIpIHJldHVybiBPVVRQVVRfT1ZFUlJVTjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLm9wICsgMiA+IHRoaXMuY2JsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRlbmRCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSB0aGlzLm91dFt0aGlzLm1fcG9zKytdO1xuICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IHRoaXMub3V0W3RoaXMubV9wb3NdO1xuXG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaF9kb25lKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaF9uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBpZiAobV9wb3MgPCBvdXQgfHwgbV9wb3MgPj0gb3ApIHJldHVybiBMT09LQkVISU5EX09WRVJSVU47XG4gICAgICAgICAgICAgIC8vIGlmIChvcF9lbmQgLSBvcCA8IHQrMy0xKSByZXR1cm4gT1VUUFVUX09WRVJSVU47XG5cbiAgICAgICAgICAgICAgdGhpcy5jb3B5X21hdGNoKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hfZG9uZSgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMubWF0Y2hfbmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLk9LO1xuICAgICAgfSxcblxuICAgICAgZGVjb21wcmVzczogZnVuY3Rpb24gKHN0YXRlOiBhbnkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICAgICAgICB0aGlzLmJ1ZiA9IHRoaXMuc3RhdGUuaW5wdXRCdWZmZXI7XG4gICAgICAgICAgY29uc3QgYnVmXzRiID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWYubGVuZ3RoICsgKDQgLSB0aGlzLmJ1Zi5sZW5ndGggJSA0KSk7XG4gICAgICAgICAgYnVmXzRiLnNldCh0aGlzLmJ1Zik7XG4gICAgICAgICAgdGhpcy5idWYzMiA9IG5ldyBVaW50MzJBcnJheShidWZfNGIuYnVmZmVyKTtcblxuICAgICAgICAgIHRoaXMub3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWYubGVuZ3RoICsgKHRoaXMuYmxvY2tTaXplIC0gdGhpcy5idWYubGVuZ3RoICUgdGhpcy5ibG9ja1NpemUpKTtcbiAgICAgICAgICB0aGlzLm91dDMyID0gbmV3IFVpbnQzMkFycmF5KHRoaXMub3V0LmJ1ZmZlcik7XG4gICAgICAgICAgdGhpcy5jYmwgPSB0aGlzLm91dC5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5vdXRwdXRCdWZmZXIgPSB0aGlzLm91dDtcbiAgICAgICAgICB0aGlzLmlwX2VuZCA9IHRoaXMuYnVmLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLm9wX2VuZCA9IHRoaXMub3V0Lmxlbmd0aDtcbiAgICAgICAgICB0aGlzLnQgPSAwO1xuXG4gICAgICAgICAgdGhpcy5pcCA9IDA7XG4gICAgICAgICAgdGhpcy5vcCA9IDA7XG4gICAgICAgICAgdGhpcy5tX3BvcyA9IDA7XG5cbiAgICAgICAgICB0aGlzLnNraXBUb0ZpcnN0TGl0ZXJhbEZ1biA9IGZhbHNlO1xuXG4gICAgICAgICAgbGV0IHJldDtcbiAgICAgICAgICAvLyBpZiAoaXBfZW5kIC0gaXAgPCAxKSByZXR1cm4gSU5QVVRfT1ZFUlJVTjtcbiAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5pcF0gPiAxNykge1xuICAgICAgICAgICAgICB0aGlzLnQgPSB0aGlzLmJ1Zlt0aGlzLmlwKytdIC0gMTc7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnQgPCA0KSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoX25leHQoKTtcbiAgICAgICAgICAgICAgICAgIHJldCA9IHRoaXMubWF0Y2goKTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHRoaXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09PSB0aGlzLkVPRl9GT1VORCA/IHRoaXMuT0sgOiByZXQ7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIChvcF9lbmQgLSBvcCA8IHQpIHJldHVybiBPVVRQVVRfT1ZFUlJVTjtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIChpcF9lbmQgLSBpcCA8IHQrMykgcmV0dXJuIElOUFVUX09WRVJSVU47XG4gICAgICAgICAgICAgICAgICB0aGlzLmNvcHlfZnJvbV9idWYoKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcFRvRmlyc3RMaXRlcmFsRnVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoOyA7KSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5za2lwVG9GaXJzdExpdGVyYWxGdW4pIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIChpcF9lbmQgLSBpcCA8IDMpIHJldHVybiBJTlBVVF9PVkVSUlVOO1xuICAgICAgICAgICAgICAgICAgdGhpcy50ID0gdGhpcy5idWZbdGhpcy5pcCsrXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudCA+PSAxNikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHRoaXMubWF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSB0aGlzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgPT09IHRoaXMuRU9GX0ZPVU5EID8gdGhpcy5PSyA6IHJldDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZbdGhpcy5pcF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ICs9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodCA+IDUxMSkgcmV0dXJuIElOUFVUX09WRVJSVU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIChpcF9lbmQgLSBpcCA8IDEpIHJldHVybiBJTlBVVF9PVkVSUlVOO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnQgKz0gMTUgKyB0aGlzLmJ1Zlt0aGlzLmlwKytdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gaWYgKG9wX2VuZCAtIG9wIDwgdCszKSByZXR1cm4gT1VUUFVUX09WRVJSVU47XG4gICAgICAgICAgICAgICAgICAvLyBpZiAoaXBfZW5kIC0gaXAgPCB0KzYpIHJldHVybiBJTlBVVF9PVkVSUlVOO1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLnQgKz0gMztcbiAgICAgICAgICAgICAgICAgIHRoaXMuY29weV9mcm9tX2J1ZigpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5za2lwVG9GaXJzdExpdGVyYWxGdW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMudCA9IHRoaXMuYnVmW3RoaXMuaXArK107XG4gICAgICAgICAgICAgIGlmICh0aGlzLnQgPCAxNikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5tX3BvcyA9IHRoaXMub3AgLSAoMSArIDB4MDgwMCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLm1fcG9zIC09IHRoaXMudCA+PiAyO1xuICAgICAgICAgICAgICAgICAgdGhpcy5tX3BvcyAtPSB0aGlzLmJ1Zlt0aGlzLmlwKytdIDw8IDI7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGlmICggbV9wb3MgPCAgb3V0IHx8IG1fcG9zID49IG9wKSByZXR1cm4gTE9PS0JFSElORF9PVkVSUlVOO1xuICAgICAgICAgICAgICAgICAgLy8gaWYgKG9wX2VuZCAtIG9wIDwgMykgcmV0dXJuIE9VVFBVVF9PVkVSUlVOO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMub3AgKyAzID4gdGhpcy5jYmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IHRoaXMub3V0W3RoaXMubV9wb3MrK107XG4gICAgICAgICAgICAgICAgICB0aGlzLm91dFt0aGlzLm9wKytdID0gdGhpcy5vdXRbdGhpcy5tX3BvcysrXTtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSB0aGlzLm91dFt0aGlzLm1fcG9zXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hfZG9uZSgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hfbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0ID0gdGhpcy5tYXRjaCgpO1xuICAgICAgICAgICAgICBpZiAocmV0ICE9PSB0aGlzLk9LKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0ID09PSB0aGlzLkVPRl9GT1VORCA/IHRoaXMuT0sgOiByZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcy5PSztcbiAgICAgIH0sXG5cbiAgICAgIF9jb21wcmVzc0NvcmU6IGZ1bmN0aW9uIChpbl9sZW46IGFueSwgdGk6IGFueSkge1xuICAgICAgICAgIGxldCBpcF9zdGFydCA9IHRoaXMuaXA7XG4gICAgICAgICAgbGV0IGlwX2VuZCA9IHRoaXMuaXAgKyBpbl9sZW4gLSAyMDtcbiAgICAgICAgICBsZXQgaWkgPSB0aGlzLmlwO1xuXG4gICAgICAgICAgdGhpcy5pcCArPSB0aSA8IDQgPyA0IC0gdGkgOiAwO1xuXG4gICAgICAgICAgbGV0IG1fcG9zO1xuICAgICAgICAgIGxldCBtX29mZjtcbiAgICAgICAgICBsZXQgbV9sZW47XG4gICAgICAgICAgbGV0IGR2X2hpO1xuICAgICAgICAgIGxldCBkdl9sbztcbiAgICAgICAgICBsZXQgZGluZGV4O1xuXG5cbiAgICAgICAgICB0aGlzLmlwICs9IDEgKyAoKHRoaXMuaXAgLSBpaSkgPj4gNSk7XG5cbiAgICAgICAgICBmb3IgKDsgOykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pcCA+PSBpcF9lbmQpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gZHYgPSB0aGlzLmJ1Zlt0aGlzLmlwXSB8ICh0aGlzLmJ1Zlt0aGlzLmlwICsgMV0gPDwgOCkgfCAodGhpcy5idWZbdGhpcy5pcCArIDJdIDw8IDE2KSB8ICh0aGlzLmJ1Zlt0aGlzLmlwICsgM10gPDwgMjQpO1xuICAgICAgICAgICAgICAvLyBkaW5kZXggPSAoKDB4MTgyNDQyOWQgKiBkdikgPj4gMTgpICYgMTYzODM7XG4gICAgICAgICAgICAgIC8vIFRoZSBhYm92ZSBjb2RlIGRvZXNuJ3Qgd29yayBpbiBKYXZhU2NyaXB0IGR1ZSB0byBhIGxhY2sgb2YgNjQgYml0IGJpdHdpc2Ugb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAvLyBJbnN0ZWFkLCB1c2UgKG9wdGltaXNlZCB0d28ncyBjb21wbGVtZW50IGludGVnZXIgYXJpdGhtZXRpYylcbiAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIGlzIGJhc2VkIG9uIHVzIG9ubHkgbmVlZGluZyB0aGUgaGlnaCAxNiBiaXRzIG9mIHRoZSBsb3dlciAzMiBiaXQgaW50ZWdlci5cbiAgICAgICAgICAgICAgZHZfbG8gPSB0aGlzLmJ1Zlt0aGlzLmlwXSB8ICh0aGlzLmJ1Zlt0aGlzLmlwICsgMV0gPDwgOCk7XG4gICAgICAgICAgICAgIGR2X2hpID0gdGhpcy5idWZbdGhpcy5pcCArIDJdIHwgKHRoaXMuYnVmW3RoaXMuaXAgKyAzXSA8PCA4KTtcbiAgICAgICAgICAgICAgZGluZGV4ID0gKCgoZHZfbG8gKiAweDQyOWQpID4+PiAxNikgKyAoZHZfaGkgKiAweDQyOWQpICsgKGR2X2xvICogMHgxODI0KSAmIDB4RkZGRikgPj4+IDI7XG5cbiAgICAgICAgICAgICAgbV9wb3MgPSBpcF9zdGFydCArIHRoaXMuZGljdFtkaW5kZXhdO1xuXG4gICAgICAgICAgICAgIHRoaXMuZGljdFtkaW5kZXhdID0gdGhpcy5pcCAtIGlwX3N0YXJ0O1xuICAgICAgICAgICAgICBpZiAoKGR2X2hpIDw8IDE2KSArIGR2X2xvICE9PSAodGhpcy5idWZbbV9wb3NdIHwgKHRoaXMuYnVmW21fcG9zICsgMV0gPDwgOCkgfCAodGhpcy5idWZbbV9wb3MgKyAyXSA8PCAxNikgfCAodGhpcy5idWZbbV9wb3MgKyAzXSA8PCAyNCkpKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmlwICs9IDEgKyAoKHRoaXMuaXAgLSBpaSkgPj4gNSk7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpaSAtPSB0aTtcbiAgICAgICAgICAgICAgdGkgPSAwO1xuICAgICAgICAgICAgICBsZXQgdCA9IHRoaXMuaXAgLSBpaTtcblxuICAgICAgICAgICAgICBpZiAodCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHQgPD0gMykge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3AgLSAyXSB8PSB0O1xuICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IHRoaXMuYnVmW2lpKytdO1xuICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tdCA+IDApO1xuXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0IDw9IDE4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSB0IC0gMztcblxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0dCA9IHQgLSAxODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0dCA+IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHQgLT0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IHR0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IHRoaXMuYnVmW2lpKytdO1xuICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tdCA+IDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbV9sZW4gPSA0O1xuXG4gICAgICAgICAgICAgIC8vIGxldCBza2lwVG9fbV9sZW5fZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5pcCArIG1fbGVuXSA9PT0gdGhpcy5idWZbbV9wb3MgKyBtX2xlbl0pIHtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBtX2xlbiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLmlwICsgbV9sZW5dICE9PSB0aGlzLmJ1ZlttX3BvcyArIG1fbGVuXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgbV9sZW4gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5pcCArIG1fbGVuXSAhPT0gdGhpcy5idWZbbV9wb3MgKyBtX2xlbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG1fbGVuICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMuaXAgKyBtX2xlbl0gIT09IHRoaXMuYnVmW21fcG9zICsgbV9sZW5dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBtX2xlbiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLmlwICsgbV9sZW5dICE9PSB0aGlzLmJ1ZlttX3BvcyArIG1fbGVuXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgbV9sZW4gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5pcCArIG1fbGVuXSAhPT0gdGhpcy5idWZbbV9wb3MgKyBtX2xlbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIG1fbGVuICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMuaXAgKyBtX2xlbl0gIT09IHRoaXMuYnVmW21fcG9zICsgbV9sZW5dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBtX2xlbiArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLmlwICsgbV9sZW5dICE9PSB0aGlzLmJ1ZlttX3BvcyArIG1fbGVuXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgbV9sZW4gKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5pcCArIG1fbGVuXSAhPT0gdGhpcy5idWZbbV9wb3MgKyBtX2xlbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlwICsgbV9sZW4gPj0gaXBfZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXBUb19tX2xlbl9kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5pcCArIG1fbGVuXSA9PT0gdGhpcy5idWZbbV9wb3MgKyBtX2xlbl0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gaWYgKCFza2lwVG9fbV9sZW5fZG9uZSkge1xuICAgICAgICAgICAgICAvLyAgICAgbGV0IGluYyA9IHRoaXMuY3R6bCh0aGlzLmJ1Zlt0aGlzLmlwICsgbV9sZW5dIF4gdGhpcy5idWZbbV9wb3MgKyBtX2xlbl0pID4+IDM7XG4gICAgICAgICAgICAgIC8vICAgICBtX2xlbiArPSBpbmM7XG4gICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICBtX29mZiA9IHRoaXMuaXAgLSBtX3BvcztcbiAgICAgICAgICAgICAgdGhpcy5pcCArPSBtX2xlbjtcbiAgICAgICAgICAgICAgaWkgPSB0aGlzLmlwO1xuICAgICAgICAgICAgICBpZiAobV9sZW4gPD0gOCAmJiBtX29mZiA8PSAweDA4MDApIHtcblxuICAgICAgICAgICAgICAgICAgbV9vZmYgLT0gMTtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9ICgobV9sZW4gLSAxKSA8PCA1KSB8ICgobV9vZmYgJiA3KSA8PCAyKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSBtX29mZiA+PiAzO1xuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobV9vZmYgPD0gMHg0MDAwKSB7XG4gICAgICAgICAgICAgICAgICBtX29mZiAtPSAxO1xuICAgICAgICAgICAgICAgICAgaWYgKG1fbGVuIDw9IDMzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IDMyIHwgKG1fbGVuIC0gMik7XG5cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbV9sZW4gLT0gMzM7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IDMyO1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChtX2xlbiA+IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtX2xlbiAtPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dFt0aGlzLm9wKytdID0gbV9sZW47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLm91dFt0aGlzLm9wKytdID0gbV9vZmYgPDwgMjtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSBtX29mZiA+PiA2O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbV9vZmYgLT0gMHg0MDAwO1xuICAgICAgICAgICAgICAgICAgaWYgKG1fbGVuIDw9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dFt0aGlzLm9wKytdID0gMTYgfCAoKG1fb2ZmID4+IDExKSAmIDgpIHwgKG1fbGVuIC0gMik7XG5cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgbV9sZW4gLT0gOTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dFt0aGlzLm9wKytdID0gMTYgfCAoKG1fb2ZmID4+IDExKSAmIDgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1fbGVuID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1fbGVuIC09IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSBtX2xlbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSBtX29mZiA8PCAyO1xuICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IG1fb2ZmID4+IDY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluX2xlbiAtICgoaWkgLSBpcF9zdGFydCkgLSB0aSk7XG4gICAgICB9LFxuXG4gICAgICBjb21wcmVzczogZnVuY3Rpb24gKHN0YXRlOiBhbnkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgdGhpcy5pcCA9IDA7XG4gICAgICAgICAgdGhpcy5idWYgPSB0aGlzLnN0YXRlLmlucHV0QnVmZmVyO1xuICAgICAgICAgIGxldCBpbl9sZW4gPSB0aGlzLmJ1Zi5sZW5ndGg7XG4gICAgICAgICAgbGV0IG1heF9sZW4gPSBpbl9sZW4gKyBNYXRoLmNlaWwoaW5fbGVuIC8gMTYpICsgNjQgKyAzO1xuICAgICAgICAgIHRoaXMuc3RhdGUub3V0cHV0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobWF4X2xlbik7XG4gICAgICAgICAgdGhpcy5vdXQgPSB0aGlzLnN0YXRlLm91dHB1dEJ1ZmZlcjtcbiAgICAgICAgICB0aGlzLm9wID0gMDtcbiAgICAgICAgICB0aGlzLmRpY3QgPSBuZXcgVWludDMyQXJyYXkoMTYzODQpO1xuICAgICAgICAgIGxldCBsID0gaW5fbGVuO1xuICAgICAgICAgIGxldCB0ID0gMDtcblxuICAgICAgICAgIHdoaWxlIChsID4gMjApIHtcbiAgICAgICAgICAgICAgbGV0IGxsID0gKGwgPD0gNDkxNTIpID8gbCA6IDQ5MTUyO1xuICAgICAgICAgICAgICBpZiAoKHQgKyBsbCkgPj4gNSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuZGljdCA9IG5ldyBVaW50MzJBcnJheSgxNjM4NCk7XG5cbiAgICAgICAgICAgICAgbGV0IHByZXZfaXAgPSB0aGlzLmlwO1xuICAgICAgICAgICAgICB0ID0gdGhpcy5fY29tcHJlc3NDb3JlKGxsLCB0KTtcbiAgICAgICAgICAgICAgdGhpcy5pcCA9IHByZXZfaXAgKyBsbDtcbiAgICAgICAgICAgICAgbCAtPSBsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdCArPSBsO1xuXG4gICAgICAgICAgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICAgIGxldCBpaSA9IGluX2xlbiAtIHQ7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMub3AgPT09IDAgJiYgdCA8PSAyMzgpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSAxNyArIHQ7XG5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0IDw9IDMpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3AgLSAyXSB8PSB0O1xuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA8PSAxOCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IHQgLSAzO1xuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBsZXQgdHQgPSB0IC0gMTg7XG4gICAgICAgICAgICAgICAgICB0aGlzLm91dFt0aGlzLm9wKytdID0gMDtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICh0dCA+IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgIHR0IC09IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dFt0aGlzLm9wKytdID0gMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSB0dDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSB0aGlzLmJ1ZltpaSsrXTtcbiAgICAgICAgICAgICAgfSB3aGlsZSAoLS10ID4gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vdXRbdGhpcy5vcCsrXSA9IDE3O1xuICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSAwO1xuICAgICAgICAgIHRoaXMub3V0W3RoaXMub3ArK10gPSAwO1xuXG4gICAgICAgICAgdGhpcy5zdGF0ZS5vdXRwdXRCdWZmZXIgPSB0aGlzLm91dC5zdWJhcnJheSgwLCB0aGlzLm9wKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5PSztcbiAgICAgIH1cbiAgfTtcblxuICBsZXQgaW5zdGFuY2UgPSBuZXcgX2x6bzF4KCk7XG5cbiAgcmV0dXJuIHtcbiAgICAgIGNvbXByZXNzOiAoc3RhdGU6IGFueSkgPT4gaW5zdGFuY2UuY29tcHJlc3Moc3RhdGUpLFxuICAgICAgZGVjb21wcmVzczogKHN0YXRlOiBhbnkpID0+IGluc3RhbmNlLmRlY29tcHJlc3Moc3RhdGUpXG4gIH07XG59KSgpO1xuIiwiLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gc3RyaXAga2V5IGlmIGRpY3Rpb25hcnkncyBcIlN0cmlwS2V5XCIgYXR0cmlidXRlIGlzIHRydWUuIFxuICovXG5leHBvcnQgY29uc3QgUkVHRVhQX1NUUklQS0VZOiBSZWNvcmQ8c3RyaW5nLCBSZWdFeHA+ID0ge1xuJ21keCcgOiAvWygpLiwgJy9cXFxcQF8tXSgpL2csXG4nbWRkJyA6IC8oWy5dW14uXSokKXxbKCkuLCAnL1xcXFxAXy1dL2dcbn1cblxuZXhwb3J0IGNvbnN0IFVOREVGSU5FRCA9IHZvaWQgMDsiLCJpbXBvcnQge2luZmxhdGV9IGZyb20gJ3Bha28nO1xuaW1wb3J0IHtsem99IGZyb20gJy4uL3V0aWxzL2x6bzF4JztcbmltcG9ydCB7Y29uc2VxfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSAnLi4vY29uc3RhbnQnO1xuXG5pbnRlcmZhY2UgU2Nhbm5lck9wdGlvbnMge1xuICBsZW4/OiBudW1iZXI7XG4gIHYyPzogYm9vbGVhbjtcbiAgYnB1PzogbnVtYmVyO1xuICBkZWNvZGVyPzogYW55O1xuICB0YWlsPzogbnVtYmVyO1xuICBzZWFyY2hUZXh0TGVuPzogYW55O1xufVxuXG5leHBvcnQgY29uc3Qgc2Nhbm5lciA9IChcbiAgYnVmZmVyOiBBcnJheUJ1ZmZlcixcbiAge1xuICAgIGxlbixcbiAgICB2MixcbiAgICBicHUgPSAxLFxuICAgIGRlY29kZXIsXG4gICAgdGFpbCA9IDAsXG4gICAgc2VhcmNoVGV4dExlblxuICB9OiBTY2FubmVyT3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCBtZXRob2RzID0ge1xuICAgIGZvcndhcmQ6IChsZW46IG51bWJlcikgPT57IHJldHVybiBvZmZzZXQgKz0gbGVuOyB9LFxuICAgIG9mZnNldDogKCkgPT4geyByZXR1cm4gb2Zmc2V0OyB9LFxuICAgIHJlYWRJbnQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGR2LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgIG1ldGhvZHMuZm9yd2FyZCg0KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICByZWFkTnVtOiAoKSA9PiB7XG4gICAgICBtZXRob2RzLmZvcndhcmQoNCk7XG4gICAgICByZXR1cm4gbWV0aG9kcy5yZWFkSW50KCk7XG4gICAgfSxcbiAgICByZWFkVWludDg6ICgpID0+IHtcbiAgICAgIHJldHVybiBjb25zZXEoZHYuZ2V0VWludDgob2Zmc2V0KSwgIG1ldGhvZHMuZm9yd2FyZCgxKSk7XG4gICAgfSxcbiAgICByZWFkVWludDE2OiAoKSA9PiB7XG4gICAgICByZXR1cm4gY29uc2VxKGR2LmdldFVpbnQxNihvZmZzZXQsIGZhbHNlKSwgbWV0aG9kcy5mb3J3YXJkKDIpKTtcbiAgICB9LFxuICAgIGNoZWNrc3VtX3YyOiAoKSA9PiB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9LFxuICAgIHJlYWRCbG9jazogKGxlbjogbnVtYmVyLCBleHBlY3RlZEJ1ZlNpemU6IG51bWJlciwgZGVjcnlwdG9yOiBGdW5jdGlvbikgPT4ge1xuICAgICAgY29uc3QgY29tcF90eXBlID0gZHYuZ2V0VWludDgob2Zmc2V0KTtcbiAgICAgIGlmKGNvbXBfdHlwZSA9PT0gMCl7XG4gICAgICAgIGlmKHYyKXtcbiAgICAgICAgICBtZXRob2RzLmZvcndhcmQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgbGVuIC09IDg7XG4gICAgICAgIGxldCB0bXAgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgbGVuKTtcbiAgICAgICAgaWYgKGRlY3J5cHRvcikge1xuICAgICAgICAgIHZhciBwYXNza2V5ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgICAgcGFzc2tleS5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQgLSA0LCA0KSk7XG4gICAgICAgICAgcGFzc2tleS5zZXQoWzB4OTUsIDB4MzYsIDB4MDAsIDB4MDBdLCA0KTtcbiAgICAgICAgICB0bXAgPSBkZWNyeXB0b3IodG1wLCBwYXNza2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0bXAgPSBjb21wX3R5cGUgPT09IDIgPyBpbmZsYXRlKHRtcCkgOiBsem8uZGVjb21wcmVzcyh0bXApO1xuICAgICAgICBtZXRob2RzLmZvcndhcmQobGVuKTtcbiAgICAgICAgcmV0dXJuIHNjYW5uZXIodG1wLmJ1ZmZlciwge1xuICAgICAgICAgIGxlbjogdG1wLmxlbmd0aCxcbiAgICAgICAgICB2MixcbiAgICAgICAgICBicHUsXG4gICAgICAgICAgZGVjb2RlcixcbiAgICAgICAgICB0YWlsLFxuICAgICAgICAgIHNlYXJjaFRleHRMZW5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWFkVGV4dDogKCkgPT4ge1xuICAgICAgY29uc3QgbGVuID0gc2VhcmNoVGV4dExlbihkdiwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IHJlcyA9IGNvbnNlcShcbiAgICAgICAgZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIGxlbikpLFxuICAgICAgICBtZXRob2RzLmZvcndhcmQobGVuICsgYnB1KVxuICAgICAgKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICByZWFkVGV4dFNpemVkOiAobGVuOiBudW1iZXIpID0+IHtcbiAgICAgIGxlbiAqPSBicHU7XG4gICAgICBjb25zdCByZXMgPSBkZWNvZGVyID8gZGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIGxlbikpIDogJyc7XG4gICAgICBtZXRob2RzLmZvcndhcmQobGVuICsgdGFpbCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgcmVhZFNob3J0OiAoKSA9PiB7XG4gICAgICBpZih2Mikge1xuICAgICAgICByZXR1cm4gbWV0aG9kcy5yZWFkVWludDE2KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzLnJlYWRVaW50OCgpXG4gICAgICB9XG4gICAgfSxcbiAgICByZWFkUmF3OiBmdW5jdGlvbihsZW46IG51bWJlcikge1xuICAgICAgcmV0dXJuIGNvbnNlcShcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIGxlbiksXG4gICAgICAgIG1ldGhvZHMuZm9yd2FyZChsZW4gPT09IFVOREVGSU5FRCA/IGJ1ZmZlci5ieXRlTGVuZ3RoIC0gb2Zmc2V0IDogbGVuKVxuICAgICAgKTtcbiAgICB9LFxuICB9XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKG1ldGhvZHMpXG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3NjYW5uZXJ9IGZyb20gJy4vc2Nhbm5lcic7XG5cbmV4cG9ydCBjb25zdCByZWFkSGVhZCA9IChzb3VyY2UkOiBPYnNlcnZhYmxlPEFycmF5QnVmZmVyPik6IE9ic2VydmFibGU8YW55PiA9PiB7XG4gIHJldHVybiBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc291cmNlJC5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKHtidWZmZXIsIG5leHQsIC4uLnJlc3R9OiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBzY2EgPSBzY2FubmVyKGJ1ZmZlcik7XG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgbmV4dDogc2NhLnJlYWRJbnQoKVxuICAgICAgICAgIH0pO1xuXG4gICAgICB9LFxuICAgICAgZXJyb3I6IGVyciA9PiBvYnNlcnZlci5lcnJvcihlcnIpLFxuICAgICAgY29tcGxldGU6ICgpID0+IG9ic2VydmVyLmNvbXBsZXRlKCksXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3BhcnNlWG1sLCBkZWNyeXB0LCBpc1RydWUsIGdldEV4dGVuc2lvbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtSRUdFWFBfU1RSSVBLRVl9IGZyb20gJy4uL2NvbnN0YW50JztcblxuZXhwb3J0IGNvbnN0IHJlYWRIZWFkZXIgPSAoc291cmNlJDogT2JzZXJ2YWJsZTxBcnJheUJ1ZmZlcj4pOiBPYnNlcnZhYmxlPGFueT4gPT4ge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNvdXJjZSQuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICh7YnVmZmVyLCBmaWxlLCBuZXh0LCAuLi5yZXN0fTogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgVVRGXzE2TEUgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNmxlJyk7XG4gICAgICAgICAgY29uc3QgaGVhZGVyX3N0ciA9IFVURl8xNkxFLmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIsIDAsIG5leHQpKS5yZXBsYWNlKC9cXDAkLywgJycpO1xuICAgICAgICAgIGNvbnN0IHhtbDogYW55ID0gcGFyc2VYbWwoaGVhZGVyX3N0cikucXVlcnlTZWxlY3RvcignRGljdGlvbmFyeSwgTGlicmFyeV9EYXRhJykhLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgY29uc3QgYXR0cnM6IGFueSA9IHt9O1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpdGVtOiBhbnk7IGkgPCB4bWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSB4bWwuaXRlbShpKTtcbiAgICAgICAgICAgIGF0dHJzW2l0ZW0ubm9kZU5hbWVdID0gaXRlbS5ub2RlVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0cnMuRW5jcnlwdGVkID0gcGFyc2VJbnQoYXR0cnMuRW5jcnlwdGVkLCAxMCkgfHwgMDtcbiAgICAgICAgICBhdHRycy5FbmNvZGluZyA9IGF0dHJzLkVuY29kaW5nIHx8ICdVVEYtMTYnO1xuICAgICAgICAgIGNvbnN0IGlzVjIgPSBwYXJzZUludChhdHRycy5HZW5lcmF0ZWRCeUVuZ2luZVZlcnNpb24sIDEwKSA+PSAyLjA7XG4gICAgICAgICAgY29uc3QgYnB1ID0gKGF0dHJzLkVuY29kaW5nID09PSAnVVRGLTE2JykgPyAyIDogMTtcbiAgICAgICAgICBsZXQgYWRhcHRLZXkgPSBmdW5jdGlvbihrZXk6IHN0cmluZykge3JldHVybiBrZXk7fTtcbiAgICAgICAgICBjb25zdCBleHQgPSBnZXRFeHRlbnNpb24oZmlsZS5uYW1lLCAnbWR4Jyk7XG4gICAgICAgICAgY29uc3QgcmVnZXhwID0gUkVHRVhQX1NUUklQS0VZW2V4dF07XG4gICAgICAgICAgaWYoaXNUcnVlKGF0dHJzLktleUNhc2VTZW5zaXRpdmUpKSB7XG4gICAgICAgICAgICBhZGFwdEtleSA9IGlzVHJ1ZShhdHRycy5TdHJpcEtleSkgPyBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGtleS5yZXBsYWNlKHJlZ2V4cCwgJyQxJyk7IH0gOiBhZGFwdEtleVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGFwdEtleSA9IGlzVHJ1ZShhdHRycy5TdHJpcEtleSB8fCAoaXNWMiA/ICcnIDogJ3llcycpKSA/IGZ1bmN0aW9uKGtleTogc3RyaW5nKSB7IHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHJlZ2V4cCwgJyQxJykgOiBrZXk7IH0gOiBmdW5jdGlvbihrZXk6IHN0cmluZykgeyByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkgOiBrZXk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBvZmZzZXQ6IG5leHQgKyA0LFxuICAgICAgICAgICAgdjI6IGlzVjIsXG4gICAgICAgICAgICBkZWNyeXB0b3JzOiBhdHRycy5FbmNyeXB0ZWQgJiAweDAyID8gW2ZhbHNlLCBkZWNyeXB0XSA6IFtmYWxzZSwgZmFsc2VdLFxuICAgICAgICAgICAgYnB1LFxuICAgICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgICBkZWNvZGVyOiBuZXcgVGV4dERlY29kZXIoYXR0cnMuRW5jb2RpbmcgfHwgJ1VURi0xNkxFJyksXG4gICAgICAgICAgICB0YWlsOiBpc1YyID8gYnB1IDogMCxcbiAgICAgICAgICAgIHNlYXJjaFRleHRMZW46IGF0dHJzLkVuY29kaW5nID09PSAnVVRGLTE2JyA/IGZ1bmN0aW9uKGR2OiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICB2YXIgbWFyayA9IG9mZnNldDtcbiAgICAgICAgICAgICAgd2hpbGUgKGR2LmdldFVpbnQxNihvZmZzZXQpKSB7IG9mZnNldCs9IGJwdTsgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCAtIG1hcms7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24oZHY6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlcikge1xuICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgIHZhciBtYXJrID0gb2Zmc2V0O1xuICAgICAgICAgICAgICB3aGlsZSAoZHYuZ2V0VWludDgob2Zmc2V0KyspKSB7IC8qIHNjYW4gZm9yIE5VTCAqLyB9XG4gICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgLSBtYXJrIC0gMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGFwdEtleVxuICAgICAgICAgIH0pO1xuXG4gICAgICB9LFxuICAgICAgZXJyb3I6IGVyciA9PiBvYnNlcnZlci5lcnJvcihlcnIpLFxuICAgICAgY29tcGxldGU6ICgpID0+IG9ic2VydmVyLmNvbXBsZXRlKCksXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3NjYW5uZXJ9IGZyb20gJy4vc2Nhbm5lcic7XG5cbmV4cG9ydCBjb25zdCByZWFkS2V5d29yZFN1bW1hcnkgPSAoc291cmNlJDogT2JzZXJ2YWJsZTxBcnJheUJ1ZmZlcj4pOiBPYnNlcnZhYmxlPGFueT4gPT4ge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNvdXJjZSQuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICh7YnVmZmVyLCBmaWxlLCBuZXh0ID0gMCwgb2Zmc2V0LCAuLi5yZXN0fTogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhID0gc2Nhbm5lcihidWZmZXIpO1xuICAgICAgICAgIHNjYS5mb3J3YXJkKG9mZnNldCk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIG51bV9ibG9ja3M6IHNjYS5yZWFkTnVtKCksXG4gICAgICAgICAgICBudW1fZW50cmllczogc2NhLnJlYWROdW0oKSxcbiAgICAgICAgICAgIGtleV9pbmRleF9kZWNvbXBfbGVuOiBzY2EucmVhZE51bSgpLFxuICAgICAgICAgICAga2V5X2luZGV4X2NvbXBfbGVuOiBzY2EucmVhZE51bSgpLFxuICAgICAgICAgICAga2V5X2Jsb2Nrc19sZW46IHNjYS5yZWFkTnVtKCksXG4gICAgICAgICAgICBjaGtzdW06IHNjYS5jaGVja3N1bV92MigpLFxuICAgICAgICAgICAgbGVuOiBzY2Eub2Zmc2V0KCkgLSBuZXh0LFxuICAgICAgICAgIH1cbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgbmV4dDogZGF0YS5rZXlfaW5kZXhfY29tcF9sZW4sXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgKyBkYXRhLmxlbixcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICB9KTtcblxuICAgICAgfSxcbiAgICAgIGVycm9yOiBlcnIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiBvYnNlcnZlci5jb21wbGV0ZSgpLFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH0pXG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCBtYXAsIHN3aXRjaE1hcCwgc2tpcFdoaWxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3NjYW5uZXJ9IGZyb20gJy4vc2Nhbm5lcic7XG5pbXBvcnQge2NvbnNlcX0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtzbGljZUZpbGV9IGZyb20gJy4vc2xpY2VGaWxlJztcblxuZXhwb3J0IGNvbnN0IHJlYWRLZXl3b3JkSW5kZXggPSAoc291cmNlJDogT2JzZXJ2YWJsZTxBcnJheUJ1ZmZlcj4pOiBPYnNlcnZhYmxlPGFueT4gPT4ge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNvdXJjZSQucGlwZShcbiAgICAgIHN3aXRjaE1hcCgoe2ZpbGUsIG9mZnNldCwga2V5X2Jsb2Nrc19sZW4sIC4uLnJlc3R9OiBhbnkpID0+IHtcbiAgICAgICAgY29uc3Qgc3ViamVjdCQgPSBzbGljZUZpbGUoZmlsZSwgb2Zmc2V0LCAgb2Zmc2V0ICsga2V5X2Jsb2Nrc19sZW4pO1xuICAgICAgICByZXR1cm4gc3ViamVjdCQucGlwZShcbiAgICAgICAgICBtYXAoKGJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IE9iamVjdC5hc3NpZ24oe2ZpbGUsIG9mZnNldCwga2V5X2Jsb2Nrc19sZW4sIC4uLnJlc3R9LCB7c2xpY2VkS2V5QmxvY2s6IHtidWZmZXIsIG9mZnNldDogb2Zmc2V0ICsga2V5X2Jsb2Nrc19sZW59fSkpLFxuICAgICAgICAgIHNraXBXaGlsZSgoe3NsaWNlZEtleUJsb2NrfTogYW55KSA9PiBzbGljZWRLZXlCbG9jay5idWZmZXIgPT09IG51bGwgfHwgc2xpY2VkS2V5QmxvY2suYnVmZmVyID09PSB1bmRlZmluZWQpXG4gICAgICAgIClcbiAgICAgIH0pLFxuICAgICkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICh7XG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAga2V5X2luZGV4X2NvbXBfbGVuLFxuICAgICAgICBrZXlfaW5kZXhfZGVjb21wX2xlbixcbiAgICAgICAgZGVjcnlwdG9ycyA9IFtmYWxzZSwgZmFsc2VdLFxuICAgICAgICBzZWFyY2hUZXh0TGVuLFxuICAgICAgICBudW1fYmxvY2tzLFxuICAgICAgICB2MixcbiAgICAgICAgYnB1LFxuICAgICAgICBkZWNvZGVyLFxuICAgICAgICB0YWlsLFxuICAgICAgICBmaWxlLFxuICAgICAgLi4ucmVzdH06IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYSA9IHNjYW5uZXIoYnVmZmVyLCB7djIsIGJwdSwgZGVjb2RlciwgdGFpbCwgc2VhcmNoVGV4dExlbn0pLnJlYWRCbG9jayhrZXlfaW5kZXhfY29tcF9sZW4sIGtleV9pbmRleF9kZWNvbXBfbGVuLCBkZWNyeXB0b3JzWzFdKTtcbiAgICAgICAgICBjb25zdCBrZXl3b3JkSW5kZXggPSBBcnJheShudW1fYmxvY2tzKTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgc2l6ZTsgaSA8IG51bV9ibG9ja3M7IGkrKykge1xuICAgICAgICAgICAga2V5d29yZEluZGV4W2ldID0ge1xuICAgICAgICAgICAgICBudW1fZW50cmllczogY29uc2VxKHNjYS5yZWFkTnVtKCksIHNpemUgPSBzY2EucmVhZFNob3J0KCkpLFxuICAgICAgICAgICAgICBmaXJzdF93b3JkOiAgY29uc2VxKHNjYS5yZWFkVGV4dFNpemVkKHNpemUpLCBzaXplID0gc2NhLnJlYWRTaG9ydCgpKSxcbiAgICAgICAgICAgICAgbGFzdF93b3JkOiAgIHNjYS5yZWFkVGV4dFNpemVkKHNpemUpLFxuICAgICAgICAgICAgICBjb21wX3NpemU6ICAgc2l6ZSA9IHNjYS5yZWFkTnVtKCksXG4gICAgICAgICAgICAgIGRlY29tcF9zaXplOiBzY2EucmVhZE51bSgpLFxuICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIGtleV9pbmRleF9jb21wX2xlbixcbiAgICAgICAgICAgIGtleV9pbmRleF9kZWNvbXBfbGVuLFxuICAgICAgICAgICAgZGVjcnlwdG9ycyxcbiAgICAgICAgICAgIHNlYXJjaFRleHRMZW4sXG4gICAgICAgICAgICBudW1fYmxvY2tzLFxuICAgICAgICAgICAgdjIsXG4gICAgICAgICAgICBicHUsXG4gICAgICAgICAgICBkZWNvZGVyLFxuICAgICAgICAgICAgdGFpbCxcbiAgICAgICAgICAgIGtleXdvcmRJbmRleCxcbiAgICAgICAgICAgIG9mZnNldDogcmVzdC5vZmZzZXQgKyByZXN0LmtleV9ibG9ja3NfbGVuLFxuICAgICAgICAgICAgcG9zOiByZXN0Lm9mZnNldCArIHJlc3Qua2V5X2Jsb2Nrc19sZW4sXG4gICAgICAgICAgICBuZXh0OiAwXG4gICAgICAgICAgfSk7XG5cbiAgICAgIH0sXG4gICAgICBlcnJvcjogZXJyID0+IG9ic2VydmVyLmVycm9yKGVyciksXG4gICAgICBjb21wbGV0ZTogKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSxcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9KVxufVxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtzY2FubmVyfSBmcm9tICcuL3NjYW5uZXInO1xuXG5leHBvcnQgY29uc3QgcmVhZFJlY29yZFN1bW1hcnkgPSAoc291cmNlJDogT2JzZXJ2YWJsZTxBcnJheUJ1ZmZlcj4pOiBPYnNlcnZhYmxlPGFueT4gPT4ge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNvdXJjZSQuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICh7YnVmZmVyLCBwb3MsIG9mZnNldCwgLi4ucmVzdH06IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYSA9IHNjYW5uZXIoYnVmZmVyKTtcbiAgICAgICAgICBjb25zdCByZWNvcmRfc3VtbWFyeTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAgICAgICAgIG51bV9ibG9ja3M6ICAgc2NhLnJlYWROdW0oKSxcbiAgICAgICAgICAgIG51bV9lbnRyaWVzOiAgc2NhLnJlYWROdW0oKSxcbiAgICAgICAgICAgIGluZGV4X2xlbjogICAgc2NhLnJlYWROdW0oKSxcbiAgICAgICAgICAgIGJsb2Nrc19sZW46ICAgc2NhLnJlYWROdW0oKSxcbiAgICAgICAgICAgIGxlbjogICAgICAgICAgc2NhLm9mZnNldCgpLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVjb3JkX3N1bW1hcnkuYmxvY2tfcG9zID0gcG9zICsgcmVjb3JkX3N1bW1hcnkuaW5kZXhfbGVuICsgcmVjb3JkX3N1bW1hcnkubGVuO1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIHJlY29yZF9zdW1tYXJ5LFxuICAgICAgICAgICAgb2Zmc2V0OiBwb3MgKyByZWNvcmRfc3VtbWFyeS5sZW4sXG4gICAgICAgICAgICBuZXh0OiByZWNvcmRfc3VtbWFyeS5pbmRleF9sZW4sXG4gICAgICAgICAgICBidWZmZXJcbiAgICAgICAgICB9KTtcblxuICAgICAgfSxcbiAgICAgIGVycm9yOiBlcnIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiBvYnNlcnZlci5jb21wbGV0ZSgpLFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH0pXG59XG4iLCIvKlxuICogQ3JlYXRlIGEgUmVjb3JkIEJsb2NrIFRhYmxlIG9iamVjdCB0byBsb2FkIHJlY29yZCBibG9jayBpbmZvIGZyb20gcmVjb3JkIHNlY3Rpb24gaW4gbWR4L21kZCBmaWxlLlxuICogUmV0cml2ZWQgZGF0YSBpcyBzdG9yZWQgaW4gYW4gVWludDMyQXJyYXkgd2hpY2ggY29udGFpbnMgTiBwYWlycyBvZiAob2Zmc2V0X2NvbXAsIG9mZnNldF9kZWNvbXApIHZhbHVlLFxuICogd2hlcmUgTiBpcyBudW1iZXIgb2YgcmVjb3JkIGJsb2Nrcy5cbiAqXG4gKiBXaGVuIGxvb2tpbmcgdXAgYSBnaXZlbiBrZXkgZm9yIGl0cyBkZWZpbml0aW9uOlxuICogICAxLiBTZWFyY2ggS0VZX0lOREVYIHRvIGxvY2F0ZSBrZXl3b3JkIGJsb2NrIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGtleS5cbiAqICAgMi4gU2Nhbm5pbmcgdGhlIGZvdW5kIGtleXdvcmQgYmxvY2sgdG8gZ2V0IGl0cyByZWNvcmQgb2Zmc2V0IGFuZCBzaXplLlxuICogICAzLiBTZWFyY2ggUkVDT1JEX0JMT0NLX1RBQkxFIHRvIGdldCByZWNvcmQgYmxvY2sgY29udGFpbmluZyB0aGUgcmVjb3JkLlxuICogICA0LiBMb2FkIHRoZSBmb3VuZCByZWNvcmQgYmxvY2ssIHVzaW5nIGl0cyBvZmZzZXQgYW5kIHNpemUgdG8gcmV0cmlldmUgcmVjb3JkIGNvbnRlbnQuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vemhhbnNsaXUvd3JpdGVtZGljdC9ibG9iL21hc3Rlci9maWxlZm9ybWF0Lm1kI3JlY29yZC1zZWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWNvcmRCbG9ja1RhYmxlKCkge1xuICBsZXQgcG9zID0gMCwgLy8gY3VycmVudCBwb3NpdGlvblxuICAgICAgYXJyOiBhbnk7ICAgICAvLyBiYWNrZWQgVWludDMyQXJyYXlcbiAgcmV0dXJuIHtcbiAgICAgIC8vIEFsbG9jYXRlIHJlcXVpcmVkIEFycmF5QnVmZmVyIGZvciBzdG9yaW5nIHJlY29yZCBibG9jayB0YWJsZSwgd2hlcmUgbGVuIGlzIG51bWJlciBvZiByZWNvcmQgYmxvY2tzLlxuICAgICAgYWxsb2M6IGZ1bmN0aW9uIChsZW46IG51bWJlcikge1xuICAgICAgICAgIGFyciA9IG5ldyBVaW50MzJBcnJheShsZW4gKiAyKTtcbiAgICAgIH0sXG4gICAgICAvLyBTdG9yZSBvZmZzZXQgcGFpciB2YWx1ZSAoY29tcHJlc3NlZCAmIGRlY29tcHJlc3NlZCkgZm9yIGEgcmVjb3JkIGJsb2NrXG4gICAgICAvLyBOT1RFOiBvZmZzZXRfY29tcCBpcyBhYnNvbHV0ZSBvZmZzZXQgY291bnRlZCBmcm9tIHN0YXJ0IG9mIG1keC9tZGQgZmlsZS5cbiAgICAgIHB1dDogZnVuY3Rpb24gKG9mZnNldF9jb21wOiBhbnksIG9mZnNldF9kZWNvbXA6IGFueSkge1xuICAgICAgICBpZihhcnIpIHtcbiAgICAgICAgICBhcnJbcG9zKytdID0gb2Zmc2V0X2NvbXA7XG4gICAgICAgICAgYXJyW3BvcysrXSA9IG9mZnNldF9kZWNvbXA7XG4gICAgICAgIH1cblxuICAgICAgfSxcbiAgICAgIC8vIEdpdmVuIG9mZnNldCBvZiBhIGtleXdvcmQgYWZ0ZXIgZGVjb21wcmVzc2lvbiwgcmV0dXJuIGEgcmVjb3JkIGJsb2NrIGluZm8gY29udGFpbmluZyBpdCwgZWxzZSB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAgZmluZDogZnVuY3Rpb24gKGtleUF0OiBudW1iZXIpIHtcbiAgICAgICAgICBsZXQgaGkgPSAoYXJyLmxlbmd0aCA+PiAxKSAtIDEsIGxvID0gMCwgaSA9IChsbyArIGhpKSA+PiAxLCB2YWwgPSBhcnJbKGkgPDwgMSkgKyAxXTtcblxuICAgICAgICAgIGlmIChrZXlBdCA+IGFyclsoaGkgPDwgMSkgKyAxXSB8fCBrZXlBdCA8IDApIHJldHVybjtcblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGlmIChoaSAtIGxvIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpIDwgaGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja19ubzogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcF9vZmZzZXQ6IGFycltpIDw8PSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcF9zaXplOiBhcnJbaSArIDJdIC0gYXJyW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvbXBfb2Zmc2V0OiBhcnJbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvbXBfc2l6ZTogYXJyW2kgKyAzXSAtIGFycltpICsgMV1cbiAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAoa2V5QXQgPCB2YWwpID8gaGkgPSBpIDogbG8gPSBpO1xuICAgICAgICAgICAgICBpID0gKGxvICsgaGkpID4+IDE7XG4gICAgICAgICAgICAgIHZhbCA9IGFyclsoaSA8PCAxKSArIDFdO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3NjYW5uZXJ9IGZyb20gJy4vc2Nhbm5lcic7XG5pbXBvcnQge2NyZWF0ZVJlY29yZEJsb2NrVGFibGV9IGZyb20gJy4uL3V0aWxzL2NyZWF0ZVJlY29yZEJsb2NrVGFibGUnO1xuXG5leHBvcnQgY29uc3QgcmVhZFJlY29yZEJsb2NrID0gKHNvdXJjZSQ6IE9ic2VydmFibGU8QXJyYXlCdWZmZXI+KTogT2JzZXJ2YWJsZTxhbnk+ID0+IHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2UkLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe2J1ZmZlciwgb2Zmc2V0LCByZWNvcmRfc3VtbWFyeSwgLi4ucmVzdH06IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYSA9IHNjYW5uZXIoYnVmZmVyKTtcbiAgICAgICAgICBjb25zdCBzaXplID0gcmVjb3JkX3N1bW1hcnkubnVtX2Jsb2NrcztcbiAgICAgICAgICBjb25zdCByZWNvcmRJbmRleCA9IEFycmF5KHNpemUpO1xuICAgICAgICAgIGxldCBwb3MwID0gcmVjb3JkX3N1bW1hcnkuYmxvY2tfcG9zXG4gICAgICAgICAgbGV0IHBvczEgPSAwO1xuICAgICAgICAgIGNvbnN0IGJsb2NrVGFibGUgPSBjcmVhdGVSZWNvcmRCbG9ja1RhYmxlKCk7XG4gICAgICAgICAgYmxvY2tUYWJsZS5hbGxvYyhzaXplICsgMSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHJkeDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgcmVjb3JkSW5kZXhbaV0gPSByZHggPSB7XG4gICAgICAgICAgICAgIGNvbXBfc2l6ZTogICBzY2EucmVhZE51bSgpLFxuICAgICAgICAgICAgICBkZWNvbXBfc2l6ZTogc2NhLnJlYWROdW0oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJsb2NrVGFibGUucHV0KHBvczAsIHBvczEpO1xuICAgICAgICAgICAgcG9zMCArPSByZHguY29tcF9zaXplO1xuICAgICAgICAgICAgcG9zMSArPSByZHguZGVjb21wX3NpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJsb2NrVGFibGUucHV0KHBvczAsIHBvczEpO1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIGJsb2NrVGFibGUsXG4gICAgICAgICAgICByZWNvcmRJbmRleCxcbiAgICAgICAgICAgIGJ1ZmZlciwgb2Zmc2V0LCByZWNvcmRfc3VtbWFyeVxuICAgICAgICAgIH0pO1xuXG4gICAgICB9LFxuICAgICAgZXJyb3I6IGVyciA9PiBvYnNlcnZlci5lcnJvcihlcnIpLFxuICAgICAgY29tcGxldGU6ICgpID0+IG9ic2VydmVyLmNvbXBsZXRlKCksXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyLCBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7c2xpY2V9IGZyb20gJy4vc2xpY2UnO1xuaW1wb3J0IHtyZWFkSGVhZH0gZnJvbSAnLi9yZWFkSGVhZCc7XG5pbXBvcnQge3JlYWRIZWFkZXJ9IGZyb20gJy4vcmVhZEhlYWRlcic7XG5pbXBvcnQge3JlYWRLZXl3b3JkU3VtbWFyeX0gZnJvbSAnLi9yZWFkS2V5d29yZFN1bW1hcnknO1xuaW1wb3J0IHtyZWFkS2V5d29yZEluZGV4fSBmcm9tICcuL3JlYWRLZXl3b3JkSW5kZXgnO1xuaW1wb3J0IHtyZWFkUmVjb3JkU3VtbWFyeX0gZnJvbSAnLi9yZWFkUmVjb3JkU3VtbWFyeSc7XG5pbXBvcnQge3JlYWRSZWNvcmRCbG9ja30gZnJvbSAnLi9yZWFkUmVjb3JkQmxvY2snO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoZmlsZTogRmlsZSwgZXh0OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGFueT4ge1xuICBjb25zdCBmaWxlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Qoe2ZpbGV9KTtcbiAgcmV0dXJuIGZpbGUkLnBpcGUoXG4gICAgc2xpY2UoMCwgNCksXG4gICAgcmVhZEhlYWQsXG4gICAgc2xpY2UoNCwgNDgpLFxuICAgIHJlYWRIZWFkZXIsXG4gICAgcmVhZEtleXdvcmRTdW1tYXJ5LFxuICAgIHNsaWNlKCksXG4gICAgcmVhZEtleXdvcmRJbmRleCxcbiAgICBzbGljZSh1bmRlZmluZWQsIDMyKSxcbiAgICByZWFkUmVjb3JkU3VtbWFyeSxcbiAgICBzbGljZSgpLFxuICAgIHJlYWRSZWNvcmRCbG9ja1xuICApO1xufVxuIiwiZXhwb3J0IGNvbnN0IHJlZHVjZSA9IChhZGFwdEtleTogRnVuY3Rpb24sIGFycjogYW55W10sIHBocmFzZTogc3RyaW5nKTogYW55ID0+IHtcbiAgbGV0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGlmIChsZW4gPiAxKSB7XG4gICAgbGVuID0gbGVuID4+IDE7XG4gICAgcmV0dXJuIHBocmFzZSA+IGFkYXB0S2V5KGFycltsZW4gLSAxXS5sYXN0X3dvcmQpXG4gICAgICAgICAgICAgID8gcmVkdWNlKGFkYXB0S2V5LCBhcnIuc2xpY2UobGVuKSwgcGhyYXNlKVxuICAgICAgICAgICAgICA6IHJlZHVjZShhZGFwdEtleSwgYXJyLnNsaWNlKDAsIGxlbiksIHBocmFzZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyclswXTtcbiAgfVxufSIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7cmVkdWNlfSBmcm9tICcuL3JlZHVjZSc7XG5cbmV4cG9ydCBjb25zdCBzZWVrVmFuZ3VhcmQgPSAocXVlcnk6IHN0cmluZykgPT4gKHNvdXJjZSQ6IE9ic2VydmFibGU8QXJyYXlCdWZmZXI+KTogT2JzZXJ2YWJsZTxhbnk+ID0+IHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2UkLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe2FkYXB0S2V5LCBrZXl3b3JkSW5kZXgsIC4uLnJlc3R9OiBhbnkpID0+IHtcbiAgICAgICAgY29uc3Qgd29yZCA9IHF1ZXJ5LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwaHJhc2UgPSBhZGFwdEtleSh3b3JkKTtcbiAgICAgICAgbGV0IGtkeCA9IHJlZHVjZShhZGFwdEtleSwga2V5d29yZEluZGV4LCBwaHJhc2UpO1xuICAgICAgICAvLyBsb29rIGJhY2sgZm9yIHRoZSBmaXJzdCByZWNvcmQgYmxvY2sgY29udGFpbmluZyBrZXl3b3JkIGZvciB0aGUgc3BlY2lmaWVkIHBocmFzZVxuICAgICAgICBpZiAocGhyYXNlIDw9IGFkYXB0S2V5KGtkeC5sYXN0X3dvcmQpKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0ga2R4LmluZGV4IC0gMSwgcHJldjtcbiAgICAgICAgICB3aGlsZSAocHJldiA9IGtleXdvcmRJbmRleFtpbmRleF0pIHtcbiAgICAgICAgICAgIGlmIChhZGFwdEtleShwcmV2Lmxhc3Rfd29yZCkgIT09IGFkYXB0S2V5KGtkeC5sYXN0X3dvcmQpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2R4ID0gcHJldjtcbiAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAga2R4LFxuICAgICAgICAgIHBocmFzZSxcbiAgICAgICAgICBhZGFwdEtleSxcbiAgICAgICAgICBrZXl3b3JkSW5kZXgsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgd29yZFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZXJyID0+IG9ic2VydmVyLmVycm9yKGVyciksXG4gICAgICBjb21wbGV0ZTogKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSxcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9KVxufVxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgdGFwIH0gZnJvbSAncnhqcyc7XG5cblxuZXhwb3J0IGNvbnN0IGxvYWRLZXlzID0gKHNvdXJjZSQ6IE9ic2VydmFibGU8QXJyYXlCdWZmZXI+KTogT2JzZXJ2YWJsZTxhbnk+ID0+IHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2UkLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe2NhY2hlZEtleXMsIGtkeCwgc2xpY2VkS2V5QmxvY2ssIC4uLnJlc3R9OiBhbnkpID0+IHtcbiAgICAgICAgaWYgKGNhY2hlZEtleXMgJiYgY2FjaGVkS2V5cy5waWxvdCA9PT0ga2R4LmZpcnN0X3dvcmQpIHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICBjYWNoZWRLZXlzLFxuICAgICAgICAgICAga2R4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG9kbyBnZXQgc2xpY2VkS2V5QmxvY2sncyB2YWx1ZVxuICAgICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICAgIC4uLnNsaWNlZEtleUJsb2NrLFxuICAgICAgICAgICAgY2FjaGVkS2V5cyxcbiAgICAgICAgICAgIGtkeFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIH0sXG4gICAgICBlcnJvcjogZXJyID0+IG9ic2VydmVyLmVycm9yKGVyciksXG4gICAgICBjb21wbGV0ZTogKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSxcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9KVxufVxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtzY2FubmVyfSBmcm9tICcuLi9wYXJzZS9zY2FubmVyJztcblxuZXhwb3J0IGNvbnN0IHNsaWNlZEtleUJsb2NrVGhlbiA9IChzb3VyY2UkOiBPYnNlcnZhYmxlPEFycmF5QnVmZmVyPik6IE9ic2VydmFibGU8YW55PiA9PiB7XG4gIHJldHVybiBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc291cmNlJC5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKHtidWZmZXIsIGtkeCA9IHt9LCBzZWFyY2hUZXh0TGVuLCBkZWNvZGVyLCBicHUsIC4uLnJlc3R9OiBhbnkpID0+IHtcbiAgICAgICAgbGV0IHNjYSA9IHNjYW5uZXIoYnVmZmVyLCB7c2VhcmNoVGV4dExlbiwgZGVjb2RlciwgYnB1fSk7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBrZHgubnVtX2VudHJpZXMgPyBBcnJheShrZHgubnVtX2VudHJpZXMpIDogW107XG4gICAgICAgIHNjYS5mb3J3YXJkKGtkeC5vZmZzZXQpO1xuICAgICAgICBzY2EgPSBzY2EucmVhZEJsb2NrKGtkeC5jb21wX3NpemUsIGtkeC5kZWNvbXBfc2l6ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2R4Lm51bV9lbnRyaWVzOyBpKyspIHtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gc2NhLnJlYWROdW0oKTtcbiAgICAgICAgICBsaXN0W2ldID0gbmV3IE9iamVjdChzY2EucmVhZFRleHQoKSk7XG4gICAgICAgICAgbGlzdFtpXS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBsaXN0W2kgLSAxXS5zaXplID0gb2Zmc2V0IC0gbGlzdFtpIC0gMV0ub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZWRLZXlzID0ge2xpc3Q6IGxpc3QsIHBpbG90OiBrZHguZmlyc3Rfd29yZH07XG4gICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgYnVmZmVyLCBrZHgsIHNlYXJjaFRleHRMZW4sIGRlY29kZXIsIGJwdSxcbiAgICAgICAgICBjYWNoZWRLZXlzXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBlcnIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiBvYnNlcnZlci5jb21wbGV0ZSgpLFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH0pXG59XG4iLCJleHBvcnQgY29uc3Qgc2hyaW5rID0gKGFkYXB0S2V5OiBGdW5jdGlvbiwgYXJyOiBhbnksIHBocmFzZTogc3RyaW5nKTogYW55ID0+IHtcbiAgICBsZXQgbGVuID0gYXJyLmxlbmd0aDtcbiAgICBsZXQgc3ViOiBhbnk7XG4gICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgIGxlbiA9IGxlbiA+PiAxO1xuICAgICAgdmFyIGtleSA9IGFkYXB0S2V5KGFycltsZW5dKTtcbiAgICAgIGlmIChwaHJhc2UgPCBrZXkpIHtcbiAgICAgICAgc3ViID0gYXJyLnNsaWNlKDAsIGxlbik7XG4gICAgICAgIHN1Yi5wb3MgPSBhcnIucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViID0gYXJyLnNsaWNlKGxlbik7XG4gICAgICAgIHN1Yi5wb3MgPSAoYXJyLnBvcyB8fCAwKSArIGxlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaHJpbmsoYWRhcHRLZXksIHN1YiwgcGhyYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChhcnIucG9zIHx8IDApICsgKHBocmFzZSA8PSBhZGFwdEtleShhcnJbMF0pID8gMCA6IDEpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge3Nocmlua30gZnJvbSAnLi9zaHJpbmsnO1xuXG5leHBvcnQgY29uc3Qgc2Vla1Zhbmd1YXJkVGhlbiA9IChzb3VyY2UkOiBPYnNlcnZhYmxlPEFycmF5QnVmZmVyPik6IE9ic2VydmFibGU8YW55PiA9PiB7XG4gIHJldHVybiBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc291cmNlJC5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKHtidWZmZXIsIGtkeCwgYWRhcHRLZXksIHBocmFzZSwgY2FjaGVkS2V5cywgLi4ucmVzdH06IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ID0gY2FjaGVkS2V5cy5saXN0XG4gICAgICAgIGxldCBpZHggPSBzaHJpbmsoYWRhcHRLZXksIGxpc3QsIHBocmFzZSk7XG4gICAgICAgIHdoaWxlIChpZHggPiAwKSB7XG4gICAgICAgICAgaWYgKGFkYXB0S2V5KGxpc3RbLS1pZHhdKSAhPT0gYWRhcHRLZXkocGhyYXNlKSkge1xuICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICBjYWNoZWRLZXlzLFxuICAgICAgICAgIGlkeFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZXJyID0+IG9ic2VydmVyLmVycm9yKGVyciksXG4gICAgICBjb21wbGV0ZTogKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSxcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9KVxufSIsImltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge21hdGNoT2Zmc2V0fSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSAnLi4vY29uc3RhbnQnO1xuXG5leHBvcnQgY29uc3Qgc2Vla1Zhbmd1YXJkU3ByZWFkTWR4ID0gKHNvdXJjZSQ6IE9ic2VydmFibGU8QXJyYXlCdWZmZXI+KTogT2JzZXJ2YWJsZTxhbnk+ID0+IHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2UkLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe3F1ZXJ5ID0ge30sIGtkeCwgd29yZCwgaWR4LCBjYWNoZWRLZXlzLCAuLi5yZXN0fTogYW55KSA9PiB7XG4gICAgICAgIGxldCBsaXN0ID0gY2FjaGVkS2V5cy5saXN0LnNsaWNlKGlkeCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHF1ZXJ5Lm9mZnNldDtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gVU5ERUZJTkVEKSB7XG4gICAgICAgICAgbGlzdCA9IG1hdGNoT2Zmc2V0KGxpc3QsIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uKGVsOiBhbnkpIHsgcmV0dXJuIGVsLnRvTG93ZXJDYXNlKCkgPT09IHdvcmQ7IH0pO1xuICAgICAgICB9XG4gICAgICAgIG9ic2VydmVyLm5leHQoe1xuICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgbGlzdFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZXJyID0+IG9ic2VydmVyLmVycm9yKGVyciksXG4gICAgICBjb21wbGV0ZTogKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSxcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9KVxufVxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc2Vla1Zhbmd1YXJkIH0gZnJvbSAnLi9zZWVrVmFuZ3VhcmQnO1xuaW1wb3J0IHsgbG9hZEtleXMgfSBmcm9tICcuL2xvYWRLZXlzJztcbmltcG9ydCB7c2xpY2VkS2V5QmxvY2tUaGVufSBmcm9tICcuL3NsaWNlZEtleUJsb2NrVGhlbic7XG5pbXBvcnQge3NlZWtWYW5ndWFyZFRoZW59IGZyb20gJy4vc2Vla1Zhbmd1YXJkVGhlbic7XG5pbXBvcnQge3NlZWtWYW5ndWFyZFNwcmVhZE1keH0gZnJvbSAnLi9zZWVrVmFuZ3VhcmRTcHJlYWRNZHgnO1xuXG5leHBvcnQgY29uc3QgbWR4ID0gKHF1ZXJ5OiBzdHJpbmcpID0+IChzb3VyY2UkOiBPYnNlcnZhYmxlPEFycmF5QnVmZmVyPik6IE9ic2VydmFibGU8YW55PiA9PiB7XG4gIHJldHVybiBzb3VyY2UkLnBpcGUoXG4gICAgc2Vla1Zhbmd1YXJkKHF1ZXJ5KSxcbiAgICBsb2FkS2V5cyxcbiAgICBzbGljZWRLZXlCbG9ja1RoZW4sXG4gICAgc2Vla1Zhbmd1YXJkVGhlbixcbiAgICBzZWVrVmFuZ3VhcmRTcHJlYWRNZHgsXG4gIClcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGUsIHN3aXRjaE1hcCwgbWFwIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzY2FubmVyIH0gZnJvbSAnLi4vcGFyc2Uvc2Nhbm5lcic7XG5cbmV4cG9ydCBjb25zdCBmaW5kV29yZCA9IChzb3VyY2UkOiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPGFueT4gPT4ge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNvdXJjZSQuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICh7c2xpY2VkS2V5QmxvY2ssIGJsb2NrLCBkZWNyeXB0b3JzLCBvZmZzZXQsIHNlYXJjaFRleHRMZW4sIGRlY29kZXIsIGJwdSwgLi4ucmVzdH06IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBzY2EgPSBzY2FubmVyKHNsaWNlZEtleUJsb2NrLmJ1ZmZlciwge3NlYXJjaFRleHRMZW4sIGRlY29kZXIsIGJwdX0pLnJlYWRCbG9jayhibG9jay5jb21wX3NpemUsIGJsb2NrLmRlY29tcF9zaXplKTtcbiAgICAgICAgc2NhLmZvcndhcmQob2Zmc2V0IC0gYmxvY2suZGVjb21wX29mZnNldCk7XG4gICAgICAgIGxldCBkZWZpbml0aW9uID0gc2NhLnJlYWRUZXh0KCk7XG4gICAgICAgIGNvbnN0IGlzTGluayA9IGRlZmluaXRpb24uc3Vic3RyaW5nKDAsIDgpICE9PSAnQEBATElOSz0nO1xuICAgICAgICBkZWZpbml0aW9uID0gaXNMaW5rID8gZGVmaW5pdGlvbiA6IG51bGw7XG4gICAgICAgIGxldCBuZXdRdWVyeSA9IGlzTGluayA/IG51bGwgOiBkZWZpbml0aW9uLnN1YnN0cmluZyg4KTtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICBkZWZpbml0aW9uLFxuICAgICAgICAgIG5ld1F1ZXJ5LFxuICAgICAgICAgIHNsaWNlZEtleUJsb2NrLCBibG9jaywgZGVjcnlwdG9ycywgb2Zmc2V0XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiBlcnIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSxcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiBvYnNlcnZlci5jb21wbGV0ZSgpLFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH0pXG59XG4iLCJpbXBvcnQgeyBjb25jYXRNYXAsIE9ic2VydmFibGUsIGZyb20sIG1hcCwgdGFwLCBjYXRjaEVycm9yLCBzY2FuIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge21keH0gZnJvbSAnLi9tZHgnO1xuaW1wb3J0IHtmaW5kV29yZH0gZnJvbSAnLi9maW5kV29yZCc7XG5pbXBvcnQge3NsaWNlRmlsZX0gZnJvbSAnLi4vcGFyc2Uvc2xpY2VGaWxlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaChtZHgkOiBPYnNlcnZhYmxlPGFueT4sIHF1ZXJ5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGFueT4ge1xuICByZXR1cm4gbWR4JC5waXBlKFxuICAgIG1keChxdWVyeSksXG4gICAgY29uY2F0TWFwKCh7bGlzdCwgYmxvY2tUYWJsZSwgc2xpY2VkS2V5QmxvY2ssIGRlY3J5cHRvcnMsIGZpbGUsIHNlYXJjaFRleHRMZW4sIGRlY29kZXIsIGJwdX06IGFueSkgPT4gZnJvbShsaXN0KS5waXBlKFxuICAgICAgbWFwKChyZXM6IGFueSkgPT4gT2JqZWN0LmFzc2lnbihyZXMsIHtibG9ja1RhYmxlLCBzbGljZWRLZXlCbG9jaywgZGVjcnlwdG9ycywgZmlsZSwgc2VhcmNoVGV4dExlbiwgZGVjb2RlciwgYnB1fSkpLFxuICAgICAgbWFwKChyZXM6IGFueSkgPT4gT2JqZWN0LmFzc2lnbihyZXMsIHtibG9jazogcmVzLmJsb2NrVGFibGUuZmluZChyZXMub2Zmc2V0KX0pKSxcbiAgICAgIGNvbmNhdE1hcCgoe2ZpbGUsIGJsb2NrLCAuLi5yZXN0fTogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YmplY3QkID0gc2xpY2VGaWxlKGZpbGUsIGJsb2NrLmNvbXBfb2Zmc2V0LCBibG9jay5jb21wX29mZnNldCArIGJsb2NrLmNvbXBfc2l6ZSk7XG4gICAgICAgIHJldHVybiBzdWJqZWN0JC5waXBlKFxuICAgICAgICAgIG1hcCgoYnVmZmVyOiBBcnJheUJ1ZmZlcikgPT4gT2JqZWN0LmFzc2lnbih7ZmlsZSwgYmxvY2ssIC4uLnJlc3R9LCB7c2xpY2VkS2V5QmxvY2s6IHtidWZmZXIsIG9mZnNldDogYmxvY2suY29tcF9vZmZzZXQgKyBibG9jay5jb21wX3NpemV9fSkpLFxuICAgICAgICAgIGZpbmRXb3JkLFxuICAgICAgICAgIG1hcCgocmVzOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmKHJlcy5uZXdRdWVyeSkge1xuICAgICAgICAgICAgICB0aHJvdyByZXMubmV3UXVlcnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiBtZHgoZXJyb3IpKG1keCQpKSxcblxuICAgICAgICApXG4gICAgICB9KSxcbiAgICAgIHNjYW4oKHByZTogYW55LCBjdXI6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwcmUucmVzdWx0IHx8IFtwcmUuZGVmaW5pdGlvbl07XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1ci5kZWZpbml0aW9uKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJlLCB7cmVzdWx0fSk7XG4gICAgICB9KSxcbiAgICAgIG1hcCgocmVzOiBhbnkpID0+IE9iamVjdC5hc3NpZ24ocmVzLCB7cmVzdWx0OiByZXMucmVzdWx0ICYmIHJlcy5yZXN1bHQubGVuZ3RoID8gcmVzLnJlc3VsdCA6IFtyZXMuZGVmaW5pdGlvbl19KSksXG4gICAgKSksXG4gIClcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge21hdGNoT2Zmc2V0fSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge1VOREVGSU5FRH0gZnJvbSAnLi4vY29uc3RhbnQnO1xuXG5leHBvcnQgY29uc3Qgc2Vla1Zhbmd1YXJkU3ByZWFkTWRkID0gKHNvdXJjZSQ6IE9ic2VydmFibGU8QXJyYXlCdWZmZXI+KTogT2JzZXJ2YWJsZTxhbnk+ID0+IHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2UkLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe3F1ZXJ5ID0ge30sIGtkeCwgd29yZCwgaWR4LCBjYWNoZWRLZXlzLCAuLi5yZXN0fTogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBjYWNoZWRLZXlzLmxpc3Quc2xpY2UoaWR4KS5maWx0ZXIoKGl0ZW06IGFueSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdzZWVrVmFuZ3VhcmRTcHJlYWRNZGQnLCBpdGVtKTtcbiAgICAgICAgICByZXR1cm4gaXRlbS50b0xvd2VyQ2FzZSgpID09PSB3b3JkO1xuICAgICAgICB9KTtcblxuICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgIGNhbmRpZGF0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGVyciA9PiBvYnNlcnZlci5lcnJvcihlcnIpLFxuICAgICAgY29tcGxldGU6ICgpID0+IG9ic2VydmVyLmNvbXBsZXRlKCksXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHNlZWtWYW5ndWFyZCB9IGZyb20gJy4vc2Vla1Zhbmd1YXJkJztcbmltcG9ydCB7IGxvYWRLZXlzIH0gZnJvbSAnLi9sb2FkS2V5cyc7XG5pbXBvcnQge3NsaWNlZEtleUJsb2NrVGhlbn0gZnJvbSAnLi9zbGljZWRLZXlCbG9ja1RoZW4nO1xuaW1wb3J0IHtzZWVrVmFuZ3VhcmRUaGVufSBmcm9tICcuL3NlZWtWYW5ndWFyZFRoZW4nO1xuaW1wb3J0IHtzZWVrVmFuZ3VhcmRTcHJlYWRNZGR9IGZyb20gJy4vc2Vla1Zhbmd1YXJkU3ByZWFkTWRkJztcblxuZXhwb3J0IGNvbnN0IG1kZCA9IChxdWVyeTogc3RyaW5nKSA9PiAoc291cmNlJDogT2JzZXJ2YWJsZTxBcnJheUJ1ZmZlcj4pOiBPYnNlcnZhYmxlPGFueT4gPT4ge1xuICB2YXIgd29yZCA9IHF1ZXJ5LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICB3b3JkID0gJ1xcXFwnICsgd29yZC5yZXBsYWNlKC8oXlsvXFxcXF0pfChbL10kKS8sICcnKTtcbiAgd29yZCA9IHdvcmQucmVwbGFjZSgvXFwvL2csICdcXFxcJyk7XG4gIHJldHVybiBzb3VyY2UkLnBpcGUoXG4gICAgc2Vla1Zhbmd1YXJkKHdvcmQpLFxuICAgIGxvYWRLZXlzLFxuICAgIHNsaWNlZEtleUJsb2NrVGhlbixcbiAgICBzZWVrVmFuZ3VhcmRUaGVuLFxuICAgIHNlZWtWYW5ndWFyZFNwcmVhZE1kZFxuICApXG59XG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc2Nhbm5lciB9IGZyb20gJy4uL3BhcnNlL3NjYW5uZXInO1xuXG5leHBvcnQgY29uc3QgZmluZFJlc291cmNlID0gKHNvdXJjZSQ6IE9ic2VydmFibGU8QXJyYXlCdWZmZXI+KTogT2JzZXJ2YWJsZTxhbnk+ID0+IHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2UkLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe3NsaWNlZEtleUJsb2NrLCBibG9jaywgY2FuZGlkYXRlcywgLi4ucmVzdH06IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBzY2EgPSBzY2FubmVyKHNsaWNlZEtleUJsb2NrLmJ1ZmZlcikucmVhZEJsb2NrKGJsb2NrLmNvbXBfc2l6ZSwgYmxvY2suZGVjb21wX3NpemUpO1xuICAgICAgICBzY2EuZm9yd2FyZChjYW5kaWRhdGVzLm9mZnNldCAtIGJsb2NrLmRlY29tcF9vZmZzZXQpO1xuICAgICAgICBjb25zdCBibG9iID0gc2NhLnJlYWRSYXcoY2FuZGlkYXRlcy5zaXplKTtcbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgIHNsaWNlZEtleUJsb2NrLCBibG9jaywgY2FuZGlkYXRlcyxcbiAgICAgICAgICByZXNvdXJjZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBlcnJvcjogZXJyID0+IG9ic2VydmVyLmVycm9yKGVyciksXG4gICAgICBjb21wbGV0ZTogKCkgPT4gb2JzZXJ2ZXIuY29tcGxldGUoKSxcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9KVxufVxuIiwiaW1wb3J0IHsgY29uY2F0TWFwLCBPYnNlcnZhYmxlLCBmcm9tLCBtYXAsIHRhcCwgY2F0Y2hFcnJvciwgc2Nhbiwgb2YsIHNraXBXaGlsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHttZGR9IGZyb20gJy4vbWRkJztcbmltcG9ydCB7c2xpY2VGaWxlfSBmcm9tICcuLi9wYXJzZS9zbGljZUZpbGUnO1xuaW1wb3J0IHtmaW5kUmVzb3VyY2V9IGZyb20gJy4vZmluZFJlc291cmNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc291cmNlKG1kZCQ6IE9ic2VydmFibGU8YW55PiwgcXVlcnk6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gIHJldHVybiBtZGQkLnBpcGUoXG4gICAgbWRkKHF1ZXJ5KSxcbiAgICB0YXAocmVzID0+IGNvbnNvbGUubG9nKCdyZXNvdXJjZSAxJywgcmVzKSksXG4gICAgbWFwKChyZXM6IGFueSkgPT4ge1xuICAgICAgaWYocmVzLmNhbmRpZGF0ZXMgJiYgcmVzLmNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlcywge2NhbmRpZGF0ZXM6IHJlcy5jYW5kaWRhdGVzWzBdfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IE9iamVjdC5hc3NpZ24ocmVzLCB7bWVzc2FnZTogYCpSRVNPVVJDRSBOT1QgRk9VTkQqICR7cXVlcnl9YCwgbm9SZXNvdXJjZTogdHJ1ZSwgY2FuZGlkYXRlczogbnVsbH0pXG4gICAgICB9XG4gICAgfSksXG4gICAgY2F0Y2hFcnJvcigoZXJyb3IpID0+IG9mKGVycm9yKS5waXBlKFxuICAgICAgdGFwKCh7bWVzc2FnZX06IGFueSkgPT4gY29uc29sZS5sb2cobWVzc2FnZSkpLFxuICAgICkpLFxuICAgIGNvbmNhdE1hcCgoe2ZpbGUsIGNhbmRpZGF0ZXMsIGJsb2NrVGFibGUsIC4uLnJlc3R9OiBhbnkpID0+IHtcbiAgICAgIGlmKGNhbmRpZGF0ZXMpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBibG9ja1RhYmxlLmZpbmQoY2FuZGlkYXRlcy5vZmZzZXQpO1xuICAgICAgICBjb25zdCBzdWJqZWN0JCA9IHNsaWNlRmlsZShmaWxlLCBibG9jay5jb21wX29mZnNldCwgYmxvY2suY29tcF9vZmZzZXQgKyBibG9jay5jb21wX3NpemUpO1xuICAgICAgICByZXR1cm4gc3ViamVjdCQucGlwZShcbiAgICAgICAgICBtYXAoKGJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7ZmlsZSwgYmxvY2ssIC4uLnJlc3R9LFxuICAgICAgICAgICAge3NsaWNlZEtleUJsb2NrOiB7YnVmZmVyLCBvZmZzZXQ6IGJsb2NrLmNvbXBfb2Zmc2V0ICsgYmxvY2suY29tcF9zaXplfX1cbiAgICAgICAgICApKSxcbiAgICAgICAgICBmaW5kUmVzb3VyY2VcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9mKHtmaWxlLCBjYW5kaWRhdGVzLCBibG9ja1RhYmxlLCAuLi5yZXN0fSlcbiAgICAgIH1cblxuICAgIH0pLFxuICApXG59XG4iLCJpbXBvcnQge21lcmdlTWFwLCBPYnNlcnZhYmxlLCBtYXAsIHRhcH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2dldEV4dGVuc2lvbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge3BhcnNlfSBmcm9tICcuL3BhcnNlL2luZGV4JztcbmltcG9ydCB7c2VhcmNofSBmcm9tICcuL3NlYXJjaC9pbmRleCc7XG5pbXBvcnQge3Jlc291cmNlfSBmcm9tICcuL3NlYXJjaC9yZXNvdXJjZSc7XG5cbmV4cG9ydCB0eXBlIFJlc291cmNlcyA9IFJlY29yZDxzdHJpbmcgfCBudW1iZXIsIE9ic2VydmFibGU8RmlsZT4+IHwgT2JzZXJ2YWJsZTxGaWxlPltdO1xuY29uc3QgZGVmYXVsdFJlc291cmNlOiBPYnNlcnZhYmxlPEZpbGU+W10gPSBbXTtcblxuY2xhc3MgTWRpY3Qge1xuICByZXNvdXJjZXM6IFJlc291cmNlcyA9IGRlZmF1bHRSZXNvdXJjZTtcbiAgY29uc3RydWN0b3IoZmlsZXM6IEZpbGVMaXN0KSB7XG4gICAgdGhpcy5yZXNvdXJjZXMgPSB0aGlzLmxvYWQoZmlsZXMpO1xuXG4gIH1cbiAgZ2V0PFQ+KGtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIChyZXNvdXJjZTogUmVzb3VyY2VzKTogVCB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQocmVzb3VyY2UsIGtleSk7XG4gICAgfVxuICB9XG4gIGxvYWQoZmlsZXM6IEZpbGVMaXN0KSB7XG4gICAgcmV0dXJuIFsuLi5maWxlc10ucmVkdWNlKChhY2M6IFJlc291cmNlcywgZmlsZTogRmlsZSkgPT4ge1xuICAgICAgY29uc3QgZXh0ID0gZ2V0RXh0ZW5zaW9uKGZpbGUubmFtZSwgJ21keCcpO1xuICAgICAgY29uc3Qgb2JzZXJ2YWJsZSQgPSBwYXJzZShmaWxlLCBleHQpO1xuICAgICAgT2JqZWN0LmFzc2lnbihhY2MsIHtcbiAgICAgICAgW2V4dF06IG9ic2VydmFibGUkLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgfVxuICBzZWFyY2gocXVlcnk6IHN0cmluZykge1xuICAgIGNvbnN0IG1keCQgPSB0aGlzLmdldDxPYnNlcnZhYmxlPGFueT4+KCdtZHgnKSh0aGlzLnJlc291cmNlcykgfHwgbmV3IE9ic2VydmFibGU7XG4gICAgY29uc3QgbWRkJCA9IHRoaXMuZ2V0PE9ic2VydmFibGU8YW55Pj4oJ21kZCcpKHRoaXMucmVzb3VyY2VzKTtcbiAgICBjb25zdCBzZWFyY2gkID0gc2VhcmNoKG1keCQsIHF1ZXJ5KTtcbiAgICBpZihtZGQkKSB7XG4gICAgICBjb25zdCByZXNvdXJjZSQgPSByZXNvdXJjZShtZGQkLCBxdWVyeSk7XG4gICAgICByZXR1cm4gc2VhcmNoJC5waXBlKFxuICAgICAgICB0YXAoKHJlcykgPT4gY29uc29sZS5sb2coJ3NlYXJjaCcsIHJlcykpLFxuICAgICAgICBtZXJnZU1hcCgocmVzOiBhbnkpID0+IHJlc291cmNlJC5waXBlKFxuICAgICAgICAgIHRhcCgoZGF0YTogYW55KSA9PiBjb25zb2xlLmxvZygncmVzb3VyY2UnLCBkYXRhLCBPYmplY3QuYXNzaWduKHJlcywge3Jlc291cmNlOiBkYXRhLnJlc291cmNlfSkpKSxcbiAgICAgICAgICBtYXAoKHtyZXNvdXJjZX06IGFueSkgPT4gT2JqZWN0LmFzc2lnbihyZXMsIHtyZXNvdXJjZX0pKVxuICAgICAgICApKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlYXJjaCQ7XG4gICAgfVxuXG5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZGljdDtcbiJdLCJuYW1lcyI6WyJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9fZXh0ZW5kcyIsIlR5cGVFcnJvciIsIlN0cmluZyIsIl9fIiwiY29uc3RydWN0b3IiLCJjcmVhdGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidCIsInRyeXMiLCJvcHMiLCJmIiwieSIsImciLCJ2ZXJiIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuIiwidiIsIm9wIiwicG9wIiwibGVuZ3RoIiwicHVzaCIsIl9fdmFsdWVzIiwibyIsInMiLCJtIiwiaSIsIl9fcmVhZCIsInIiLCJhciIsImVycm9yIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJhcmd1bWVudHMiLCJsIiwic2xpY2UiLCJjb25jYXQiLCJfX2F3YWl0IiwiX19hc3luY0dlbmVyYXRvciIsImFzeW5jSXRlcmF0b3IiLCJxIiwiYSIsInJlc3VtZSIsInNldHRsZSIsImZ1bGZpbGwiLCJzaGlmdCIsIl9fYXN5bmNWYWx1ZXMiLCJpc0Z1bmN0aW9uIiwiY3JlYXRlRXJyb3JDbGFzcyIsImNyZWF0ZUltcGwiLCJfc3VwZXIiLCJpbnN0YW5jZSIsIkVycm9yIiwic3RhY2siLCJjdG9yRnVuYyIsIlVuc3Vic2NyaXB0aW9uRXJyb3IiLCJVbnN1YnNjcmlwdGlvbkVycm9ySW1wbCIsImVycm9ycyIsIm1lc3NhZ2UiLCJtYXAiLCJlcnIiLCJ0b1N0cmluZyIsImpvaW4iLCJuYW1lIiwiYXJyUmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsIlN1YnNjcmlwdGlvbiIsImluaXRpYWxUZWFyZG93biIsImNsb3NlZCIsIl9wYXJlbnRhZ2UiLCJfZmluYWxpemVycyIsInVuc3Vic2NyaWJlIiwiaXNBcnJheSIsIl9wYXJlbnRhZ2VfMSIsIl9wYXJlbnRhZ2VfMV8xIiwicGFyZW50XzEiLCJyZW1vdmUiLCJpbml0aWFsRmluYWxpemVyIiwiX2ZpbmFsaXplcnNfMSIsIl9maW5hbGl6ZXJzXzFfMSIsImZpbmFsaXplciIsImV4ZWNGaW5hbGl6ZXIiLCJhZGQiLCJ0ZWFyZG93biIsIl9oYXNQYXJlbnQiLCJfYWRkUGFyZW50IiwiX2EiLCJwYXJlbnQiLCJpbmNsdWRlcyIsIl9yZW1vdmVQYXJlbnQiLCJFTVBUWSIsImVtcHR5IiwiRU1QVFlfU1VCU0NSSVBUSU9OIiwiaXNTdWJzY3JpcHRpb24iLCJjb25maWciLCJvblVuaGFuZGxlZEVycm9yIiwib25TdG9wcGVkTm90aWZpY2F0aW9uIiwidW5kZWZpbmVkIiwidXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyIsInVzZURlcHJlY2F0ZWROZXh0Q29udGV4dCIsInRpbWVvdXRQcm92aWRlciIsInNldFRpbWVvdXQiLCJoYW5kbGVyIiwidGltZW91dCIsImFyZ3MiLCJfaSIsImRlbGVnYXRlIiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlIiwicmVwb3J0VW5oYW5kbGVkRXJyb3IiLCJub29wIiwiZXJyb3JDb250ZXh0IiwiY2IiLCJTdWJzY3JpYmVyIiwiZGVzdGluYXRpb24iLCJfdGhpcyIsImlzU3RvcHBlZCIsIkVNUFRZX09CU0VSVkVSIiwiY29tcGxldGUiLCJTYWZlU3Vic2NyaWJlciIsIl9uZXh0IiwiX2Vycm9yIiwiX2NvbXBsZXRlIiwiX2JpbmQiLCJGdW5jdGlvbiIsImJpbmQiLCJmbiIsIkNvbnN1bWVyT2JzZXJ2ZXIiLCJwYXJ0aWFsT2JzZXJ2ZXIiLCJoYW5kbGVVbmhhbmRsZWRFcnJvciIsIm9ic2VydmVyT3JOZXh0IiwiY29udGV4dF8xIiwiZGVmYXVsdEVycm9ySGFuZGxlciIsIm9ic2VydmFibGUiLCJpZGVudGl0eSIsIngiLCJwaXBlRnJvbUFycmF5IiwiZm5zIiwicGlwZWQiLCJpbnB1dCIsInJlZHVjZSIsInByZXYiLCJPYnNlcnZhYmxlIiwic3Vic2NyaWJlIiwiX3N1YnNjcmliZSIsImxpZnQiLCJvcGVyYXRvciIsInNvdXJjZSIsInN1YnNjcmliZXIiLCJpc1N1YnNjcmliZXIiLCJfdHJ5U3Vic2NyaWJlIiwic2luayIsImZvckVhY2giLCJwcm9taXNlQ3RvciIsImdldFByb21pc2VDdG9yIiwiU3ltYm9sX29ic2VydmFibGUiLCJwaXBlIiwib3BlcmF0aW9ucyIsInRvUHJvbWlzZSIsImlzT2JzZXJ2ZXIiLCJoYXNMaWZ0Iiwib3BlcmF0ZSIsImluaXQiLCJsaWZ0ZWRTb3VyY2UiLCJjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIiLCJvbk5leHQiLCJvbkNvbXBsZXRlIiwib25FcnJvciIsIm9uRmluYWxpemUiLCJPcGVyYXRvclN1YnNjcmliZXIiLCJzaG91bGRVbnN1YnNjcmliZSIsImNsb3NlZF8xIiwiT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IiLCJPYmplY3RVbnN1YnNjcmliZWRFcnJvckltcGwiLCJTdWJqZWN0IiwiY3VycmVudE9ic2VydmVycyIsIm9ic2VydmVycyIsImhhc0Vycm9yIiwidGhyb3duRXJyb3IiLCJzdWJqZWN0IiwiQW5vbnltb3VzU3ViamVjdCIsIl90aHJvd0lmQ2xvc2VkIiwiX2IiLCJfYyIsIm9ic2VydmVyIiwiZGVmaW5lUHJvcGVydHkiLCJfY2hlY2tGaW5hbGl6ZWRTdGF0dXNlcyIsIl9pbm5lclN1YnNjcmliZSIsImFzT2JzZXJ2YWJsZSIsIkJlaGF2aW9yU3ViamVjdCIsIl92YWx1ZSIsImdldFZhbHVlIiwic3Vic2NyaXB0aW9uIiwiaXNTY2hlZHVsZXIiLCJzY2hlZHVsZSIsImxhc3QiLCJwb3BTY2hlZHVsZXIiLCJpc0FycmF5TGlrZSIsImlzUHJvbWlzZSIsImlzSW50ZXJvcE9ic2VydmFibGUiLCJpc0FzeW5jSXRlcmFibGUiLCJvYmoiLCJjcmVhdGVJbnZhbGlkT2JzZXJ2YWJsZVR5cGVFcnJvciIsImdldFN5bWJvbEl0ZXJhdG9yIiwiaXNJdGVyYWJsZSIsIlN5bWJvbF9pdGVyYXRvciIsInJlYWRhYmxlU3RyZWFtTGlrZVRvQXN5bmNHZW5lcmF0b3IiLCJyZWFkYWJsZVN0cmVhbSIsInJlYWRlciIsImdldFJlYWRlciIsInJlYWQiLCJyZWxlYXNlTG9jayIsImlzUmVhZGFibGVTdHJlYW1MaWtlIiwiaW5uZXJGcm9tIiwiZnJvbUludGVyb3BPYnNlcnZhYmxlIiwiZnJvbUFycmF5TGlrZSIsImZyb21Qcm9taXNlIiwiZnJvbUFzeW5jSXRlcmFibGUiLCJmcm9tSXRlcmFibGUiLCJmcm9tUmVhZGFibGVTdHJlYW1MaWtlIiwib2JzIiwiYXJyYXkiLCJwcm9taXNlIiwiaXRlcmFibGUiLCJpdGVyYWJsZV8xIiwiaXRlcmFibGVfMV8xIiwiYXN5bmNJdGVyYWJsZSIsInByb2Nlc3MiLCJjYXRjaCIsImFzeW5jSXRlcmFibGVfMSIsImFzeW5jSXRlcmFibGVfMV8xIiwiZXhlY3V0ZVNjaGVkdWxlIiwicGFyZW50U3Vic2NyaXB0aW9uIiwic2NoZWR1bGVyIiwid29yayIsImRlbGF5IiwicmVwZWF0Iiwic2NoZWR1bGVTdWJzY3JpcHRpb24iLCJvYnNlcnZlT24iLCJzdWJzY3JpYmVPbiIsInNjaGVkdWxlT2JzZXJ2YWJsZSIsInNjaGVkdWxlUHJvbWlzZSIsInNjaGVkdWxlQXJyYXkiLCJzY2hlZHVsZUl0ZXJhYmxlIiwicmV0dXJuIiwic2NoZWR1bGVBc3luY0l0ZXJhYmxlIiwic2NoZWR1bGVSZWFkYWJsZVN0cmVhbUxpa2UiLCJzY2hlZHVsZWQiLCJvZiIsInByb2plY3QiLCJtZXJnZUludGVybmFscyIsImNvbmN1cnJlbnQiLCJvbkJlZm9yZU5leHQiLCJleHBhbmQiLCJpbm5lclN1YlNjaGVkdWxlciIsImFkZGl0aW9uYWxGaW5hbGl6ZXIiLCJidWZmZXIiLCJhY3RpdmUiLCJpc0NvbXBsZXRlIiwiY2hlY2tDb21wbGV0ZSIsIm91dGVyTmV4dCIsImRvSW5uZXJTdWIiLCJpbm5lckNvbXBsZXRlIiwiaW5uZXJWYWx1ZSIsImJ1ZmZlcmVkVmFsdWUiLCJtZXJnZU1hcCIsInJlc3VsdFNlbGVjdG9yIiwiSW5maW5pdHkiLCJpaSIsImNhdGNoRXJyb3IiLCJzZWxlY3RvciIsImlubmVyU3ViIiwic3luY1Vuc3ViIiwiaGFuZGxlZFJlc3VsdCIsInNjYW5JbnRlcm5hbHMiLCJhY2N1bXVsYXRvciIsInNlZWQiLCJoYXNTZWVkIiwiZW1pdE9uTmV4dCIsImVtaXRCZWZvcmVDb21wbGV0ZSIsImhhc1N0YXRlIiwic3RhdGUiLCJjb25jYXRNYXAiLCJzY2FuIiwic2tpcFdoaWxlIiwicHJlZGljYXRlIiwidGFraW5nIiwic3dpdGNoTWFwIiwiaW5uZXJTdWJzY3JpYmVyIiwiaW5uZXJJbmRleCIsIm91dGVySW5kZXgiLCJ0YXAiLCJ0YXBPYnNlcnZlciIsImlzVW5zdWIiLCJmaW5hbGl6ZSIsImFzVWludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsImMiLCJzZXQiLCJyb3RsIiwiRElHRVNUIiwiUyIsIlgiLCJLIiwiRiIsInoiLCJyaXBlbWQxMjgiLCJkYXRhIiwiYWEiLCJiYiIsImNjIiwiZGQiLCJhYWEiLCJiYmIiLCJjY2MiLCJkZGQiLCJyciIsInRtcCIsImhhc2giLCJieXRlcyIsInBhZGRpbmciLCJVaW50OEFycmF5IiwiZ2V0RXh0ZW5zaW9uIiwiZmlsZW5hbWUiLCJkZWZhdWx0RXh0IiwiZXhlYyIsInBhcnNlWG1sIiwic3RyIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiZGVjcnlwdCIsImJ1ZiIsImtleSIsImJ5dGUiLCJrZXlsZW4iLCJsZW4iLCJjb25zZXEiLCJpc1RydWUiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoT2Zmc2V0IiwibGlzdCIsIm9mZnNldCIsInNvbWUiLCJlbCIsInNsaWNlRmlsZSIsImZpbGUiLCJmaWxlJCIsIkZpbGVSZWFkZXIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsIm9ubG9hZCIsIm9ubG9hZGVuZCIsIm9uZXJyb3IiLCJvbmFib3J0IiwiYnl0ZUxlbmd0aCIsInBvcyIsInNvdXJjZSQiLCJfcmVmIiwiX3JlZiRuZXh0IiwiX3JlZiRvZmZzZXQiLCJyZXN0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiX2V4Y2x1ZGVkIiwic3RhcnQiLCJzaXplIiwic3ViamVjdCQiLCJhc3NpZ24iLCJfb2JqZWN0U3ByZWFkIiwicmVzIiwibHpvIiwiX2x6bzF4IiwiYmxvY2tTaXplIiwiT0siLCJJTlBVVF9PVkVSUlVOIiwiT1VUUFVUX09WRVJSVU4iLCJMT09LQkVISU5EX09WRVJSVU4iLCJFT0ZfRk9VTkQiLCJidWYzMiIsIm91dCIsIm91dDMyIiwiY2JsIiwiaXBfZW5kIiwib3BfZW5kIiwiaXAiLCJtX3BvcyIsInNraXBUb0ZpcnN0TGl0ZXJhbEZ1biIsImV4dGVuZEJ1ZmZlciIsIm5ld0J1ZmZlciIsIm91dHB1dEJ1ZmZlciIsIm1hdGNoX25leHQiLCJtYXRjaF9kb25lIiwiY29weV9tYXRjaCIsImNvcHlfZnJvbV9idWYiLCJtYXRjaCIsInN1YmFycmF5IiwiZGVjb21wcmVzcyIsImlucHV0QnVmZmVyIiwiYnVmXzRiIiwicmV0IiwiX2NvbXByZXNzQ29yZSIsImluX2xlbiIsInRpIiwiaXBfc3RhcnQiLCJtX29mZiIsIm1fbGVuIiwiZHZfaGkiLCJkdl9sbyIsImRpbmRleCIsImRpY3QiLCJ0dCIsImNvbXByZXNzIiwibWF4X2xlbiIsIk1hdGgiLCJjZWlsIiwibGwiLCJwcmV2X2lwIiwiUkVHRVhQX1NUUklQS0VZIiwiVU5ERUZJTkVEIiwic2Nhbm5lciIsInYyIiwiX3JlZiRicHUiLCJicHUiLCJkZWNvZGVyIiwiX3JlZiR0YWlsIiwidGFpbCIsInNlYXJjaFRleHRMZW4iLCJkdiIsIkRhdGFWaWV3IiwibWV0aG9kcyIsImZvcndhcmQiLCJyZWFkSW50IiwiZ2V0VWludDMyIiwicmVhZE51bSIsInJlYWRVaW50OCIsImdldFVpbnQ4IiwicmVhZFVpbnQxNiIsImdldFVpbnQxNiIsImNoZWNrc3VtX3YyIiwicmVhZEJsb2NrIiwiZXhwZWN0ZWRCdWZTaXplIiwiZGVjcnlwdG9yIiwiY29tcF90eXBlIiwicGFzc2tleSIsImluZmxhdGUiLCJyZWFkVGV4dCIsImRlY29kZSIsInJlYWRUZXh0U2l6ZWQiLCJyZWFkU2hvcnQiLCJyZWFkUmF3IiwicmVhZEhlYWQiLCJzY2EiLCJyZWFkSGVhZGVyIiwiVVRGXzE2TEUiLCJUZXh0RGVjb2RlciIsImhlYWRlcl9zdHIiLCJyZXBsYWNlIiwieG1sIiwicXVlcnlTZWxlY3RvciIsImF0dHJpYnV0ZXMiLCJhdHRycyIsIm5vZGVOYW1lIiwibm9kZVZhbHVlIiwiRW5jcnlwdGVkIiwicGFyc2VJbnQiLCJFbmNvZGluZyIsImlzVjIiLCJHZW5lcmF0ZWRCeUVuZ2luZVZlcnNpb24iLCJhZGFwdEtleSIsImV4dCIsInJlZ2V4cCIsIktleUNhc2VTZW5zaXRpdmUiLCJTdHJpcEtleSIsImRlY3J5cHRvcnMiLCJtYXJrIiwicmVhZEtleXdvcmRTdW1tYXJ5IiwibnVtX2Jsb2NrcyIsIm51bV9lbnRyaWVzIiwia2V5X2luZGV4X2RlY29tcF9sZW4iLCJrZXlfaW5kZXhfY29tcF9sZW4iLCJrZXlfYmxvY2tzX2xlbiIsImNoa3N1bSIsInJlYWRLZXl3b3JkSW5kZXgiLCJzbGljZWRLZXlCbG9jayIsIl9yZWYyIiwiX3JlZjMiLCJfcmVmMyRkZWNyeXB0b3JzIiwiX2V4Y2x1ZGVkMiIsImtleXdvcmRJbmRleCIsImZpcnN0X3dvcmQiLCJsYXN0X3dvcmQiLCJjb21wX3NpemUiLCJkZWNvbXBfc2l6ZSIsInJlYWRSZWNvcmRTdW1tYXJ5IiwicmVjb3JkX3N1bW1hcnkiLCJpbmRleF9sZW4iLCJibG9ja3NfbGVuIiwiYmxvY2tfcG9zIiwiY3JlYXRlUmVjb3JkQmxvY2tUYWJsZSIsImFsbG9jIiwicHV0Iiwib2Zmc2V0X2NvbXAiLCJvZmZzZXRfZGVjb21wIiwiZmluZCIsImtleUF0IiwiaGkiLCJsbyIsInZhbCIsImJsb2NrX25vIiwiY29tcF9vZmZzZXQiLCJkZWNvbXBfb2Zmc2V0IiwiZ2V0IiwicmVhZFJlY29yZEJsb2NrIiwicmVjb3JkSW5kZXgiLCJwb3MwIiwicG9zMSIsImJsb2NrVGFibGUiLCJyZHgiLCJwYXJzZSIsInBocmFzZSIsInNlZWtWYW5ndWFyZCIsInF1ZXJ5Iiwid29yZCIsInRyaW0iLCJrZHgiLCJsb2FkS2V5cyIsImNhY2hlZEtleXMiLCJwaWxvdCIsInNsaWNlZEtleUJsb2NrVGhlbiIsIl9yZWYka2R4Iiwic2hyaW5rIiwic3ViIiwic2Vla1Zhbmd1YXJkVGhlbiIsImlkeCIsInNlZWtWYW5ndWFyZFNwcmVhZE1keCIsIl9yZWYkcXVlcnkiLCJmaWx0ZXIiLCJtZHgiLCJmaW5kV29yZCIsImJsb2NrIiwiZGVmaW5pdGlvbiIsImlzTGluayIsInN1YnN0cmluZyIsIm5ld1F1ZXJ5Iiwic2VhcmNoIiwibWR4JCIsInByZSIsImN1ciIsInNlZWtWYW5ndWFyZFNwcmVhZE1kZCIsImNhbmRpZGF0ZXMiLCJjb25zb2xlIiwibG9nIiwibWRkIiwiZmluZFJlc291cmNlIiwiYmxvYiIsInJlc291cmNlIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwibWRkJCIsIm5vUmVzb3VyY2UiLCJkZWZhdWx0UmVzb3VyY2UiLCJNZGljdCIsImZpbGVzIiwiX2NsYXNzQ2FsbENoZWNrIiwiX2RlZmluZVByb3BlcnR5IiwicmVzb3VyY2VzIiwibG9hZCIsIl9jcmVhdGVDbGFzcyIsIlJlZmxlY3QiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJhY2MiLCJvYnNlcnZhYmxlJCIsInNlYXJjaCQiLCJyZXNvdXJjZSQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Q0EsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFBRTtBQUMxRCxFQUFBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO0FBQUU7QUFDMUQsRUFBQSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUFFO0FBQzFELEVBQUEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7QUFBRTtBQUMxRCxFQUFBLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQUU7QUFDMUQsRUFBQSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztBQUFFO0FBQzFELEVBQUEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFBRTtBQUMxRCxFQUFBLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQUUsR0FDN0QsQ0FBQ3RQLEdBQUcsQ0FBQ2dQLGFBQWEsQ0FBQyxDQUFBO0FBQ3BCTyxFQUFBQSxDQUFDLEdBQUcsQ0FDQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztBQUFFO0FBQ3hELEVBQUEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFBRTtBQUN4RCxFQUFBLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO0FBQUU7QUFDeEQsRUFBQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUFFO0FBQ3hELEVBQUEsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7QUFBRTtBQUN4RCxFQUFBLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQUU7QUFDeEQsRUFBQSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUFFO0FBQ3hELEVBQUEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7QUFBRSxHQUMzRCxDQUFDdlAsR0FBRyxDQUFDZ1AsYUFBYSxDQUFDLENBQUE7QUFDcEJRLEVBQUFBLENBQUMsR0FBR1IsYUFBYSxDQUFDLENBQ2QsVUFBVTtBQUFFO0VBQ1osVUFBVTtBQUFFO0VBQ1osVUFBVTtBQUFFO0VBQ1osVUFBVTtBQUFFO0VBQ1osVUFBVTtBQUFFO0VBQ1osVUFBVTtBQUFFO0VBQ1osVUFBVTtBQUFFO0FBQ1osRUFBQSxVQUFVO0FBQUUsR0FDZixDQUFDLENBQUE7RUFDRlMsQ0FBQyxHQUFHLENBQ0EsVUFBVXpLLENBQU0sRUFBRWxJLENBQU0sRUFBRTRTLENBQU0sRUFBRTtBQUM5QixJQUFBLE9BQVExSyxDQUFDLEdBQUdsSSxDQUFDLEdBQUc0UyxDQUFDLENBQUE7QUFDckIsR0FBQyxFQUNELFVBQVUxSyxDQUFNLEVBQUVsSSxDQUFNLEVBQUU0UyxDQUFNLEVBQUU7QUFDOUIsSUFBQSxPQUFRMUssQ0FBQyxHQUFHbEksQ0FBQyxHQUFNLENBQUNrSSxDQUFDLEdBQUkwSyxDQUFFLENBQUE7QUFDL0IsR0FBQyxFQUNELFVBQVUxSyxDQUFNLEVBQUVsSSxDQUFNLEVBQUU0UyxDQUFNLEVBQUU7QUFDOUIsSUFBQSxPQUFPLENBQUMxSyxDQUFDLEdBQUksQ0FBQ2xJLENBQUUsSUFBSTRTLENBQUMsQ0FBQTtBQUN6QixHQUFDLEVBQ0QsVUFBVTFLLENBQU0sRUFBRWxJLENBQU0sRUFBRTRTLENBQU0sRUFBRTtBQUM5QixJQUFBLE9BQVExSyxDQUFDLEdBQUcwSyxDQUFDLEdBQUs1UyxDQUFDLEdBQUksQ0FBQzRTLENBQUcsQ0FBQTtBQUMvQixHQUFDLEVBQ0o7QUFFWSxTQUFTQyxTQUFTQSxDQUFDQyxJQUFTLEVBQUU7QUFDM0MsRUFBQSxJQUFJQyxFQUFFO0lBQUVDLEVBQUU7SUFBRUMsRUFBRTtJQUFFQyxFQUFFO0lBQUVDLEdBQUc7SUFBRUMsR0FBRztJQUFFQyxHQUFHO0lBQUVDLEdBQUc7SUFBRXZTLENBQUM7SUFBRVUsQ0FBQztJQUFFUixDQUFDO0lBQUVzUyxFQUFFO0lBQUUzVCxDQUFDO0lBQUU0VCxHQUFHO0lBQUV0TCxDQUFDO0FBQzFEdUwsSUFBQUEsSUFBSSxHQUFHLElBQUl0QixXQUFXLENBQUMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUN4RXVCLEtBQUssR0FBR1osSUFBSSxDQUFDclMsTUFBTSxDQUFBO0FBRXZCLEVBQUEsSUFBTWtULE9BQU8sR0FBRyxJQUFJQyxVQUFVLENBQUMsQ0FBRUYsS0FBSyxHQUFHLEVBQUUsR0FBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLEdBQUcsSUFBS0EsS0FBSyxHQUFHLEVBQUcsQ0FBQyxDQUFBO0FBQzdFO0FBQ0FDLEVBQUFBLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFBO0FBRW5CYixFQUFBQSxJQUFJLEdBQUcsSUFBSVgsV0FBVyxDQUFDeFEsTUFBTSxDQUFDbVIsSUFBSSxFQUFFYSxPQUFPLENBQUMsQ0FBQ2hFLE1BQU0sQ0FBQyxDQUFBOztBQUVwRDtFQUNBK0QsS0FBSyxHQUFHQSxLQUFLLElBQUksQ0FBQyxDQUFBO0FBQ2xCeEwsRUFBQUEsQ0FBQyxHQUFHdkcsTUFBTSxDQUFDbVIsSUFBSSxFQUFFLENBQUNZLEtBQUssRUFBRUEsS0FBSyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQzNDO0VBQ0EsS0FBSzNTLENBQUMsR0FBRyxDQUFDLEVBQUVuQixDQUFDLEdBQUcsQ0FBQyxFQUFFNkIsQ0FBQyxHQUFHeUcsQ0FBQyxDQUFDekgsTUFBTSxFQUFFTSxDQUFDLEdBQUdVLENBQUMsRUFBRVYsQ0FBQyxJQUFJLEVBQUUsRUFBRW5CLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDcERtVCxJQUFBQSxFQUFFLEdBQUdJLEdBQUcsR0FBR00sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ2xCVCxJQUFBQSxFQUFFLEdBQUdJLEdBQUcsR0FBR0ssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ2xCUixJQUFBQSxFQUFFLEdBQUdJLEdBQUcsR0FBR0ksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBQ2xCUCxJQUFBQSxFQUFFLEdBQUdJLEdBQUcsR0FBR0csSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFBO0FBRWxCLElBQUEsT0FBTzdULENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRUEsQ0FBQyxFQUFFO0FBQ2hCcUIsTUFBQUEsQ0FBQyxHQUFHLENBQUMsRUFBRXJCLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQTtNQUNkbVQsRUFBRSxHQUFHVCxJQUFJLENBQUNTLEVBQUUsR0FBR0osQ0FBQyxDQUFDMVIsQ0FBQyxDQUFDLENBQUMrUixFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxDQUFDLEdBQUdoTCxDQUFDLENBQUNuSCxDQUFDLEdBQUcwUixDQUFDLENBQUN4UixDQUFDLENBQUMsQ0FBQ3JCLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxHQUFHOFMsQ0FBQyxDQUFDelIsQ0FBQyxDQUFDLEVBQUV1UixDQUFDLENBQUN2UixDQUFDLENBQUMsQ0FBQ3JCLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFBO0FBRTNFNFQsTUFBQUEsR0FBRyxHQUFHTixFQUFFLENBQUE7QUFDUkEsTUFBQUEsRUFBRSxHQUFHRCxFQUFFLENBQUE7QUFDUEEsTUFBQUEsRUFBRSxHQUFHRCxFQUFFLENBQUE7QUFDUEEsTUFBQUEsRUFBRSxHQUFHRCxFQUFFLENBQUE7QUFDUEEsTUFBQUEsRUFBRSxHQUFHUyxHQUFHLENBQUE7QUFDWixLQUFBO0FBRUEsSUFBQSxPQUFPNVQsQ0FBQyxHQUFHLEdBQUcsRUFBRSxFQUFFQSxDQUFDLEVBQUU7QUFDakJxQixNQUFBQSxDQUFDLEdBQUcsQ0FBQyxFQUFFckIsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFBO01BQ2QyVCxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFJM1QsQ0FBQyxHQUFHLEVBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQTtNQUM3QnVULEdBQUcsR0FBR2IsSUFBSSxDQUFDYSxHQUFHLEdBQUdSLENBQUMsQ0FBQ1ksRUFBRSxDQUFDLENBQUNILEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLENBQUMsR0FBR3BMLENBQUMsQ0FBQ25ILENBQUMsR0FBRzBSLENBQUMsQ0FBQ3hSLENBQUMsQ0FBQyxDQUFDckIsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLEdBQUc4UyxDQUFDLENBQUN6UixDQUFDLENBQUMsRUFBRXVSLENBQUMsQ0FBQ3ZSLENBQUMsQ0FBQyxDQUFDckIsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUE7QUFFakY0VCxNQUFBQSxHQUFHLEdBQUdGLEdBQUcsQ0FBQTtBQUNUQSxNQUFBQSxHQUFHLEdBQUdELEdBQUcsQ0FBQTtBQUNUQSxNQUFBQSxHQUFHLEdBQUdELEdBQUcsQ0FBQTtBQUNUQSxNQUFBQSxHQUFHLEdBQUdELEdBQUcsQ0FBQTtBQUNUQSxNQUFBQSxHQUFHLEdBQUdLLEdBQUcsQ0FBQTtBQUNiLEtBQUE7SUFFQUYsR0FBRyxHQUFHRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUdSLEVBQUUsR0FBR0ssR0FBRyxDQUFBO0lBQ3hCRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUdBLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBR1AsRUFBRSxHQUFHQyxHQUFHLENBQUE7SUFDNUJNLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBR0EsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHVixFQUFFLEdBQUdLLEdBQUcsQ0FBQTtJQUM1QkssSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHQSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUdULEVBQUUsR0FBR0ssR0FBRyxDQUFBO0FBQzVCSSxJQUFBQSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUdILEdBQUcsQ0FBQTtBQUNqQixHQUFBO0FBRUEsRUFBQSxPQUFPLElBQUlNLFVBQVUsQ0FBQ0gsSUFBSSxDQUFDOUQsTUFBTSxDQUFDLENBQUE7QUFDcEM7O0FDdEhPLElBQU1rRSxZQUFZLEdBQUcsU0FBZkEsWUFBWUEsQ0FBSUMsUUFBZ0IsRUFBRUMsVUFBa0IsRUFBYTtBQUM1RSxFQUFBLE9BQU9ELFFBQVEsR0FBRyxpQkFBaUIsQ0FBQ0UsSUFBSSxDQUFDRixRQUFRLENBQUMsQ0FBRSxDQUFDLENBQUMsR0FBR0MsVUFBVSxDQUFBO0FBQ3JFLENBQUMsQ0FBQTtBQUVNLElBQU1FLFFBQVEsR0FBRyxTQUFYQSxRQUFRQSxDQUFJQyxHQUFXLEVBQUs7RUFDdkMsT0FBUSxJQUFJQyxTQUFTLEVBQUUsQ0FBRUMsZUFBZSxDQUFDRixHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUE7QUFDM0QsQ0FBQyxDQUFBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0csT0FBT0EsQ0FBQ0MsR0FBZSxFQUFFQyxHQUFRLEVBQWU7QUFDOURBLEVBQUFBLEdBQUcsR0FBRzFCLFNBQVMsQ0FBQzBCLEdBQUcsQ0FBQyxDQUFBO0FBQ3BCLEVBQUEsSUFBSUMsS0FBSTtJQUFFQyxNQUFNLEdBQUdGLEdBQUcsQ0FBQzlULE1BQU07QUFBRStILElBQUFBLElBQUksR0FBRyxJQUFJO0FBQUV6SCxJQUFBQSxDQUFDLEdBQUcsQ0FBQztJQUFFMlQsR0FBRyxHQUFHSixHQUFHLENBQUM3VCxNQUFNLENBQUE7QUFDbkUsRUFBQSxPQUFPTSxDQUFDLEdBQUcyVCxHQUFHLEVBQUUzVCxDQUFDLEVBQUUsRUFBRTtBQUNqQnlULElBQUFBLEtBQUksR0FBR0YsR0FBRyxDQUFDdlQsQ0FBQyxDQUFDLENBQUE7QUFDYnlULElBQUFBLEtBQUksR0FBS0EsS0FBSSxJQUFJLENBQUMsR0FBS0EsS0FBSSxJQUFJLENBQUcsQ0FBQTtBQUNsQ0EsSUFBQUEsS0FBSSxHQUFHQSxLQUFJLEdBQUdoTSxJQUFJLEdBQUl6SCxDQUFDLEdBQUcsSUFBSyxHQUFHd1QsR0FBRyxDQUFDeFQsQ0FBQyxHQUFHMFQsTUFBTSxDQUFDLENBQUE7QUFDakRqTSxJQUFBQSxJQUFJLEdBQUc4TCxHQUFHLENBQUN2VCxDQUFDLENBQUMsQ0FBQTtBQUNidVQsSUFBQUEsR0FBRyxDQUFDdlQsQ0FBQyxDQUFDLEdBQUd5VCxLQUFJLENBQUE7QUFDakIsR0FBQTtBQUNBLEVBQUEsT0FBT0YsR0FBRyxDQUFBO0FBQ1osQ0FBQTtBQUVPLFNBQVNLLE1BQU1BLEdBQWdCO0FBQ3BDLEVBQUEsT0FBQW5ULFNBQUEsQ0FBQWYsTUFBQSxJQUFBbUYsQ0FBQUEsR0FBQUEsU0FBQSxHQUFBcEUsU0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0YsQ0FBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTyxTQUFTb1QsTUFBTUEsQ0FBQ3RVLENBQW1CLEVBQUU7RUFDMUNBLENBQUMsR0FBRyxDQUFDLENBQUNBLENBQUMsSUFBSSxLQUFLLElBQUksRUFBRSxFQUFFdVUsV0FBVyxFQUFFLENBQUE7QUFDckMsRUFBQSxPQUFPdlUsQ0FBQyxLQUFLLEtBQUssSUFBSUEsQ0FBQyxLQUFLLE1BQU0sQ0FBQTtBQUNwQyxDQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLFNBQVN3VSxXQUFXQSxDQUFDQyxJQUFXLEVBQUVDLE1BQWMsRUFBRTtBQUN2RCxFQUFBLE9BQU9ELElBQUksQ0FBQ0UsSUFBSSxDQUFDLFVBQVNDLEVBQU8sRUFBRTtBQUFFLElBQUEsT0FBT0EsRUFBRSxDQUFDRixNQUFNLEtBQUtBLE1BQU0sR0FBR0QsSUFBSSxHQUFHLENBQUNHLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQTtBQUFFLEdBQUMsQ0FBQyxHQUFHSCxJQUFJLEdBQUcsRUFBRSxDQUFBO0FBQ3hHOztBQ3hETyxJQUFNSSxTQUFTLEdBQUcsU0FBWkEsU0FBU0EsQ0FBSUMsSUFBVSxFQUFFSixNQUFjLEVBQUVOLEdBQVcsRUFBOEI7QUFDN0YsRUFBQSxJQUFNVyxLQUFLLEdBQUcsSUFBSTdKLGVBQWUsQ0FBQyxJQUE4QixDQUFDLENBQUE7RUFDakU2SixLQUFLLENBQUMzTSxTQUFTLENBQUMsWUFBTTtBQUNwQixJQUFBLElBQU1pRSxNQUFNLEdBQUcsSUFBSTJJLFVBQVUsRUFBRSxDQUFBO0lBQy9CM0ksTUFBTSxDQUFDNEksaUJBQWlCLENBQUNILElBQUksQ0FBQzFULEtBQUssQ0FBQ3NULE1BQU0sRUFBRU4sR0FBRyxDQUFDLENBQUMsQ0FBQTtJQUNqRC9ILE1BQU0sQ0FBQzZJLE1BQU0sR0FBRyxZQUFNO01BQ3BCLElBQUc3SSxNQUFNLENBQUN4TixNQUFNLEVBQUU7QUFDaEJrVyxRQUFBQSxLQUFLLENBQUNyVyxJQUFJLENBQUMyTixNQUFNLENBQUN4TixNQUFxQixDQUFDLENBQUE7QUFDMUMsT0FBQTtLQUVELENBQUE7SUFDRHdOLE1BQU0sQ0FBQzhJLFNBQVMsR0FBRyxZQUFNO01BQ3ZCSixLQUFLLENBQUNwTyxRQUFRLEVBQUUsQ0FBQTtLQUNqQixDQUFBO0FBQ0QwRixJQUFBQSxNQUFNLENBQUMrSSxPQUFPLEdBQUcsVUFBQ3ZTLEdBQUcsRUFBSztBQUN4QmtTLE1BQUFBLEtBQUssQ0FBQ2xVLEtBQUssQ0FBQ2dDLEdBQUcsQ0FBQyxDQUFBO0tBQ2pCLENBQUE7SUFDRHdKLE1BQU0sQ0FBQ2dKLE9BQU8sR0FBRyxZQUFNO0FBQ3JCTixNQUFBQSxLQUFLLENBQUNsVSxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUE7S0FDdEIsQ0FBQTtBQUNILEdBQUMsQ0FBQyxDQUFBO0FBRUYsRUFBQSxPQUFPa1UsS0FBSyxDQUFDOUwsSUFBSSxDQUNmZ0ksU0FBUyxDQUFDLFVBQUM1QixNQUFtQixFQUFBO0FBQUEsSUFBQSxPQUFLQSxNQUFNLEtBQUssSUFBSSxJQUFJQSxNQUFNLEtBQUsvSixTQUFTLElBQUkrSixNQUFNLENBQUNpRyxVQUFVLElBQUksQ0FBQyxDQUFBO0FBQUEsR0FBQSxDQUN0RyxDQUFDLENBQUE7QUFDSCxDQUFDOzs7QUN4Qk0sSUFBTWxVLEtBQUssR0FBRyxTQUFSQSxLQUFLQSxDQUFJbVUsR0FBWSxFQUFFbkIsR0FBWSxFQUFBO0VBQUEsT0FBSyxVQUFDb0IsT0FBd0IsRUFBc0I7QUFDbEcsSUFBQSxPQUFPLElBQUlyTixVQUFVLENBQUMsVUFBQTBDLFFBQVEsRUFBSTtNQUNoQyxPQUFPMkssT0FBTyxDQUFDdk0sSUFBSSxDQUNqQjZHLFFBQVEsQ0FBQyxVQUFBMkYsSUFBQSxFQUFnRDtBQUFBLFFBQUEsSUFBOUNYLElBQUksR0FBQVcsSUFBQSxDQUFKWCxJQUFJO1VBQUFZLFNBQUEsR0FBQUQsSUFBQSxDQUFFL1csSUFBSTtBQUFKQSxVQUFBQSxJQUFJLEdBQUFnWCxTQUFBLEtBQUcsS0FBQSxDQUFBLEdBQUEsQ0FBQyxHQUFBQSxTQUFBO1VBQUFDLFdBQUEsR0FBQUYsSUFBQSxDQUFFZixNQUFNO0FBQU5BLFVBQUFBLE1BQU0sR0FBQWlCLFdBQUEsS0FBRyxLQUFBLENBQUEsR0FBQSxDQUFDLEdBQUFBLFdBQUE7QUFBS0MsVUFBQUEsSUFBSSxHQUFBQyx3QkFBQSxDQUFBSixJQUFBLEVBQUFLLFdBQUEsQ0FBQSxDQUFBO1FBQzVDLElBQU1DLEtBQUssR0FBRyxPQUFPUixHQUFHLEtBQUssV0FBVyxHQUFHQSxHQUFHLEdBQUdiLE1BQU0sQ0FBQTtRQUN2RCxJQUFNc0IsSUFBSSxHQUFHNUIsR0FBRyxHQUFHQSxHQUFHLEdBQUcxVixJQUFJLEdBQUdBLElBQUksQ0FBQTtRQUNwQyxJQUFNdVgsUUFBUSxHQUFHcEIsU0FBUyxDQUFDQyxJQUFJLEVBQUVpQixLQUFLLEVBQUVBLEtBQUssR0FBR0MsSUFBSSxDQUFDLENBQUE7QUFDckQsUUFBQSxPQUFPQyxRQUFRLENBQUNoTixJQUFJLENBQ2xCckcsR0FBRyxDQUFDLFVBQUN5TSxNQUFtQixFQUFBO0FBQUEsVUFBQSxPQUFLclMsTUFBTSxDQUFDa1osTUFBTSxDQUFBQyxjQUFBLENBQUE7QUFBRXJCLFlBQUFBLElBQUksRUFBSkEsSUFBSTtBQUFFcFcsWUFBQUEsSUFBSSxFQUFKQSxJQUFJO0FBQUVnVyxZQUFBQSxNQUFNLEVBQU5BLE1BQUFBO0FBQU0sV0FBQSxFQUFLa0IsSUFBSSxDQUFHLEVBQUE7QUFBQ3ZHLFlBQUFBLE1BQU0sRUFBTkEsTUFBTTtZQUFFcUYsTUFBTSxFQUFFcUIsS0FBSyxHQUFHQyxJQUFBQTtBQUFJLFdBQUMsQ0FBQyxDQUFBO0FBQUEsU0FBQSxDQUMzRyxDQUFDLENBQUE7QUFDSCxPQUFDLENBQ0gsQ0FBQyxDQUFDNU4sU0FBUyxDQUFDO0FBQ1YxSixRQUFBQSxJQUFJLEVBQUUsU0FBQUEsSUFBQzBYLENBQUFBLEdBQVEsRUFBSztBQUNsQnZMLFVBQUFBLFFBQVEsQ0FBQ25NLElBQUksQ0FBQzBYLEdBQUcsQ0FBQyxDQUFBO0FBQ3BCLFNBQUE7QUFDRixPQUFDLENBQUMsQ0FBQTtBQUNKLEtBQUMsQ0FBQyxDQUFBO0dBQ0gsQ0FBQTtBQUFBLENBQUE7O0FDbkJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsaUJBQWlCLENBQUMsQ0FBQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVEsZ0JBQWdCLENBQUMsQ0FBQztBQUNoQyxNQUFNLE1BQU0sa0JBQWtCLENBQUMsQ0FBQztBQUNoQztBQUNBLE1BQU0sV0FBVyxlQUFlLENBQUMsQ0FBQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBTSxDQUFDLEdBQUcsRUFBRSxFQUFFLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWSxHQUFHLENBQUMsQ0FBQztBQUN2QixNQUFNLFlBQVksR0FBRyxDQUFDLENBQUM7QUFDdkIsTUFBTSxTQUFTLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZCO0FBQ0E7QUFDQSxNQUFNLFdBQVcsTUFBTSxDQUFDLENBQUM7QUFDekIsTUFBTSxXQUFXLE1BQU0sR0FBRyxDQUFDO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxjQUFjLElBQUksRUFBRSxDQUFDO0FBQzNCO0FBQ0E7QUFDQSxNQUFNLFVBQVUsUUFBUSxHQUFHLENBQUM7QUFDNUI7QUFDQTtBQUNBLE1BQU0sU0FBUyxTQUFTLFVBQVUsR0FBRyxDQUFDLEdBQUcsY0FBYyxDQUFDO0FBQ3hEO0FBQ0E7QUFDQSxNQUFNLFNBQVMsU0FBUyxFQUFFLENBQUM7QUFDM0I7QUFDQTtBQUNBLE1BQU0sVUFBVSxRQUFRLEVBQUUsQ0FBQztBQUMzQjtBQUNBO0FBQ0EsTUFBTSxXQUFXLE9BQU8sQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFDMUM7QUFDQTtBQUNBLE1BQU0sVUFBVSxRQUFRLEVBQUUsQ0FBQztBQUMzQjtBQUNBO0FBQ0EsTUFBTSxRQUFRLFFBQVEsRUFBRSxDQUFDO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ3RCO0FBQ0E7QUFDQSxNQUFNLFNBQVMsS0FBSyxHQUFHLENBQUM7QUFDeEI7QUFDQTtBQUNBLE1BQU0sT0FBTyxPQUFPLEVBQUUsQ0FBQztBQUN2QjtBQUNBO0FBQ0EsTUFBTSxTQUFTLEtBQUssRUFBRSxDQUFDO0FBQ3ZCO0FBQ0E7QUFDQSxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxXQUFXO0FBQ2pCLEVBQUUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5RTtBQUNBLE1BQU0sV0FBVztBQUNqQixFQUFFLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3hGO0FBQ0EsTUFBTSxZQUFZO0FBQ2xCLEVBQUUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFEO0FBQ0EsTUFBTSxRQUFRO0FBQ2QsRUFBRSxJQUFJLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxhQUFhLEdBQUcsR0FBRyxDQUFDO0FBQzFCO0FBQ0E7QUFDQSxNQUFNLFlBQVksSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDckQsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWSxJQUFJLElBQUksS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUMvQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFVBQVUsTUFBTSxJQUFJLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUMvQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWSxJQUFJLElBQUksS0FBSyxDQUFDLFdBQVcsR0FBRyxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDL0QsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNLFdBQVcsS0FBSyxJQUFJLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUNoRCxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDcEI7QUFDQTtBQUNBLE1BQU0sU0FBUyxPQUFPLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzNDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLGNBQWMsQ0FBQyxXQUFXLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFO0FBQ2hGO0FBQ0EsRUFBRSxJQUFJLENBQUMsV0FBVyxJQUFJLFdBQVcsQ0FBQztBQUNsQyxFQUFFLElBQUksQ0FBQyxVQUFVLEtBQUssVUFBVSxDQUFDO0FBQ2pDLEVBQUUsSUFBSSxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQUM7QUFDakMsRUFBRSxJQUFJLENBQUMsS0FBSyxVQUFVLEtBQUssQ0FBQztBQUM1QixFQUFFLElBQUksQ0FBQyxVQUFVLEtBQUssVUFBVSxDQUFDO0FBQ2pDO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxTQUFTLE1BQU0sV0FBVyxJQUFJLFdBQVcsQ0FBQyxNQUFNLENBQUM7QUFDeEQsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJLGFBQWEsQ0FBQztBQUNsQixJQUFJLGFBQWEsQ0FBQztBQUNsQixJQUFJLGNBQWMsQ0FBQztBQUNuQjtBQUNBO0FBQ0EsU0FBUyxRQUFRLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRTtBQUN2QyxFQUFFLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQzNCLEVBQUUsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFDcEIsRUFBRSxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztBQUM3QixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFNLEdBQUcsQ0FBQyxJQUFJLEtBQUs7QUFDekI7QUFDQSxFQUFFLE9BQU8sSUFBSSxHQUFHLEdBQUcsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLEdBQUcsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4RSxDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUs7QUFDNUI7QUFDQTtBQUNBLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDMUMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDaEQsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sS0FBSztBQUN4QztBQUNBLEVBQUUsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUMsRUFBRTtBQUN4QyxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUM7QUFDL0MsSUFBSSxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMzQixJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsS0FBSyxLQUFLLFFBQVEsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDaEQsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFDcEMsR0FBRyxNQUFNO0FBQ1QsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxRQUFRLElBQUksTUFBTSxDQUFDO0FBQy9DLElBQUksQ0FBQyxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUM7QUFDekIsR0FBRztBQUNILENBQUMsQ0FBQztBQUNGO0FBQ0E7QUFDQSxNQUFNLFNB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QyxDQUFDO0FBQ3RCLE1BQU0sSUFBSSxDQUFDLEdBQUcsUUFBUSxFQUFFLEVBQUUsU0FBUyxFQUFFO0FBQ3JDLE1BQU0sSUFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsYUFBYSxJQUFJLEVBQUU7QUFDNUM7QUFDQSxRQUFRLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsVUFBVTtBQUM3RSxRQUFRLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLElBQUksQ0FBQztBQUN2QyxPQUFPO0FBQ1AsTUFBTSxDQUFDLEVBQUUsQ0FBQztBQUNWLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsR0FBRyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsTUFBTSxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzlDLEVBQUUsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsRUFBRSxJQUFJLElBQUksQ0FBQztBQUNYLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBSyxJQUFJLEdBQUcsQ0FBQyxFQUFFLElBQUksSUFBSSxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUU7QUFDN0MsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDbkQ7QUFDQTtBQUNBLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxTQUFTLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDbEMsSUFBSSxZQUFZLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDeEMsSUFBSSxZQUFZLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxZQUFZLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDcEQsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLGFBQWEsR0FBRyxJQUFJLGNBQWMsQ0FBQyxZQUFZLEVBQUUsV0FBVyxFQUFFLFVBQVUsR0FBRyxDQUFDLEVBQUUsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQ3ZHLEVBQUUsYUFBYSxHQUFHLElBQUksY0FBYyxDQUFDLFlBQVksRUFBRSxXQUFXLEVBQUUsQ0FBQyxXQUFXLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUNuRyxFQUFFLGNBQWMsR0FBRyxJQUFJLGNBQWMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxZQUFZLEVBQUUsQ0FBQyxVQUFVLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQztBQUN0RztBQUNBO0FBQ0EsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxLQUFLO0FBQzFCO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNSO0FBQ0E7QUFDQSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUU7QUFDdkUsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLEVB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R0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDO0FBQ3BFLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7QUFDNUQ7QUFDQSxFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztBQUNsRCxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUNmO0FBQ0EsRUFBRSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7QUFDbEI7QUFDQSxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxXQUFXLENBQUM7QUFDbkMsR0FBRyxNQUFNO0FBQ1QsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDaEI7QUFDQSxJQUFJLElBQUksRUFBRSxDQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDO0FBQ3BFLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsQ0FBQztBQUM3QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxRQUFRLENBQUMsQ0FBQyxRQUFRLEtBQUssQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUM7QUFDRjtBQUNBLElBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQztBQUM3QixJQUFJLGtCQUFrQixHQUFHLGtCQUFrQixDQUFDO0FBQzVDLElBQUksaUJBQWlCLElBQUksaUJBQWlCLENBQUM7QUFDM0MsSUFBSSxXQUFXLEdBQUcsV0FBVyxDQUFDO0FBQzlCLElBQUksV0FBVyxHQUFHLFdBQVcsQ0FBQztBQUM5QjtBQUNBLElBQUksS0FBSyxHQUFHO0FBQ1osQ0FBQyxRQUFRLEVBQUUsVUFBVTtBQUNyQixDQUFDLGdCQUFnQixFQUFFLGtCQUFrQjtBQUNyQyxDQUFDLGVBQWUsRUFBRSxpQkFBaUI7QUFDbkMsQ0FBQyxTQUFTLEVBQUUsV0FBVztBQUN2QixDQUFDLFNBQVMsRUFBRSxXQUFXO0FBQ3ZCLENBQUMsQ0FBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTyxHQUFHLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxLQUFLO0FBQzFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxLQUFLLEdBQUcsTUFBTSxHQUFHLENBQUM7QUFDOUIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFFLElBQUksTUFBTSxHQUFHLENBQUM7QUFDdkMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1o7QUFDQSxFQUFFLE9BQU8sR0FBRyxLQUFLLENBQUMsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxHQUFHLENBQUM7QUFDaEMsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ2I7QUFDQSxJQUFJLEdBQUc7QUFDUCxNQUFNLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDaEMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN4QixLQUFLLFFBQVEsRUFBRSxDQUFDLEVBQUU7QUFDbEI7QUFDQSxJQUFJLEVBQUUsSUFBSSxLQUFLLENBQUM7QUFDaEIsSUFBSSxFQUFFLElBQUksS0FBSyxDQUFDO0FBQ2hCLEdBQUc7QUFDSDtBQUNBLEVBQUUsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQztBQUNGO0FBQ0E7QUFDQSxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsR0FBRyxNQUFNO0FBQ3hCLEVBQUUsSUFBSSxDQUFDLEVBQUUsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNwQjtBQUNBLEVBQUUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNoQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDVixJQUFJLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDaEMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFVBQVUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0QsS0FBSztBQUNMLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNqQixHQUFHO0FBQ0g7QUFDQSxFQUFFLE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBLE1BQU0sUUFBUSxHQUFHLElBQUksV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7QUFDOUM7QUFDQTtBQUNBLE1BQU0sS0FBSyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxLQUFLO0FBQ3RDLEVBQUUsTUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDO0FBQ3JCLEVBQUUsTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUN4QjtBQUNBLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ1o7QUFDQSxFQUFFLEtBQUssSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDbEMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUM7QUFDakQsR0FBRztBQUNIO0FBQ0EsRUFBRSxRQUFRLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ3RCLENBQUMsQ0FBQztBQUNGO0FBQ0E7QUFDQSxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksUUFBUSxHQUFHO0FBQ2YsRUFBRSxDQUFDLE9BQU8saUJBQWlCO0FBQzNCLEVBQUUsQ0FBQyxPQUFPLFlBQVk7QUFDdEIsRUFBRSxDQUFDLE9BQU8sRUFBRTtBQUNaLEVBQUUsSUFBSSxJQUFJLFlBQVk7QUFDdEIsRUFBRSxJQUFJLElBQUksY0FBYztBQUN4QixFQUFFLElBQUksSUFBSSxZQUFZO0FBQ3RCLEVBQUUsSUFBSSxJQUFJLHFCQUFxQjtBQUMvQixFQUFFLElBQUksSUFBSSxjQUFjO0FBQ3hCLEVBQUUsSUFBSSxJQUFJLHNCQUFzQjtBQUNoQyxDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxXQUFXLEdBQUc7QUFDbEI7QUFDQTtBQUNBLEVBQUUsVUFBVSxVQUFVLENBQUM7QUFDdkIsRUFBRSxlQUFlLEtBQUssQ0FBQztBQUN2QixFQUFFLFlBQVksUUFBUSxDQUFDO0FBQ3ZCLEVBQUUsWUFBWSxRQUFRLENBQUM7QUFDdkIsRUFBRSxRQUFRLFlBQVksQ0FBQztBQUN2QixFQUFFLE9BQU8sYUFBYSxDQUFDO0FBQ3ZCLEVBQUUsT0FBTyxhQUFhLENBQUM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksZ0JBQWdCLENBQUM7QUFDdkIsRUFBRSxZQUFZLFFBQVEsQ0FBQztBQUN2QixFQUFFLFdBQVcsU0FBUyxDQUFDO0FBQ3ZCLEVBQUUsT0FBTyxZQUFZLENBQUMsQ0FBQztBQUN2QixFQUFFLGNBQWMsS0FBSyxDQUFDLENBQUM7QUFDdkIsRUFBRSxZQUFZLE9BQU8sQ0FBQyxDQUFDO0FBQ3ZCLEVBQUUsV0FBVyxRQUFRLENBQUMsQ0FBQztBQUN2QixFQUFFLFdBQVcsUUFBUSxDQUFDLENBQUM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0IsVUFBVSxDQUFDO0FBQzdCLEVBQUUsWUFBWSxjQUFjLENBQUM7QUFDN0IsRUFBRSxrQkFBa0IsUUFBUSxDQUFDO0FBQzdCLEVBQUUscUJBQXFCLElBQUksQ0FBQyxDQUFDO0FBQzdCO0FBQ0E7QUFDQSxFQUFFLFVBQVUsZ0JBQWdCLENBQUM7QUFDN0IsRUFBRSxjQUFjLFlBQVksQ0FBQztBQUM3QixFQUFFLEtBQUsscUJBQXFCLENBQUM7QUFDN0IsRUFBRSxPQUFPLG1CQUFtQixDQUFDO0FBQzdCLEVBQUUsa0JBQWtCLFFBQVEsQ0FBQztBQUM3QjtBQUNBO0FBQ0EsRUFBRSxRQUFRLGtCQUFrQixDQUFDO0FBQzdCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUM3QjtBQUNBLEVBQUUsU0FBUyxpQkFBaUIsQ0FBQztBQUM3QjtBQUNBO0FBQ0EsRUFBRSxVQUFVLGdCQUFnQixDQUFDO0FBQzdCO0FBQ0EsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsR0FBRyxLQUFLLENBQUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLGVBQWUsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLFNBQVM7QUFDbkgsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsV0FBVyxFQUFFLGFBQWE7QUFDeEksRUFBRSxxQkFBcUIsRUFBRSx1QkFBdUI7QUFDaEQsRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsb0JBQW9CO0FBQ3RGLEVBQUUsU0FBUztBQUNYLEVBQUUsVUFBVSxFQUFFLFlBQVk7QUFDMUIsQ0FBQyxHQUFHLFdBQVcsQ0FBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN4QjtBQUNBLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN2QjtBQUNBLE1BQU0sYUFBYSxHQUFHLENBQUMsQ0FBQztBQUN4QjtBQUNBO0FBQ0EsTUFBTSxZQUFZLElBQUksRUFBRSxDQUFDO0FBQ3pCO0FBQ0EsTUFBTSxRQUFRLFFBQVEsR0FBRyxDQUFDO0FBQzFCO0FBQ0EsTUFBTSxPQUFPLFNBQVMsUUFBUSxHQUFHLENBQUMsR0FBRyxZQUFZLENBQUM7QUFDbEQ7QUFDQSxNQUFNLE9BQU8sU0FBUyxFQUFFLENBQUM7QUFDekI7QUFDQSxNQUFNLFFBQVEsUUFBUSxFQUFFLENBQUM7QUFDekI7QUFDQSxNQUFNLFNBQVMsT0FBTyxDQUFDLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQztBQUN0QztBQUNBLE1BQU0sUUFBUSxJQUFJLEVBQUUsQ0FBQztBQUNyQjtBQUNBO0FBQ0EsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBQ3BCLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQztBQUN0QixNQUFNLGFBQWEsSUFBSSxTQUFTLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2xEO0FBQ0EsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDO0FBQ3pCO0FBQ0EsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3RCLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN2QixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDdEIsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDO0FBQ3pCLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQztBQUN2QixNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUM7QUFDdkIsTUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDO0FBQ3pCO0FBQ0EsTUFBTSxZQUFZLFFBQVEsQ0FBQyxDQUFDO0FBQzVCLE1BQU0sYUFBYSxPQUFPLENBQUMsQ0FBQztBQUM1QixNQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQztBQUM1QixNQUFNLGNBQWMsTUFBTSxDQUFDLENBQUM7QUFDNUI7QUFDQSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDckI7QUFDQSxNQUFNLEdBQUcsR0FBRyxDQUFDLElBQUksRUFBRSxTQUFTLEtBQUs7QUFDakMsRUFBRSxJQUFJLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNqQyxFQUFFLE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUMsQ0FBQztBQUNGO0FBQ0EsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEtBQUs7QUFDcEIsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDeEMsQ0FBQyxDQUFDO0FBQ0Y7QUFDQSxNQUFNLElBQUksR0FBRyxDQUFDLEdBQUcsS0FBSztBQUN0QixFQUFFLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUM1RCxDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLFVBQVUsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUNqRjtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUksR0FBRyxTQUFTLENBQUM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQWEsR0FBRyxDQUFDLElBQUksS0FBSztBQUNoQyxFQUFFLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDdkI7QUFDQTtBQUNBLEVBQUUsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQztBQUN0QixFQUFFLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUU7QUFDNUIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUN6QixHQUFHO0FBQ0gsRUFBRSxJQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUU7QUFDNUI7QUFDQSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLFdBQVcsR0FBRyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDN0YsRUFBRSxJQUFJLENBQUMsUUFBUSxJQUFJLEdBQUcsQ0FBQztBQUN2QixFQUFFLENBQUMsQ0FBQyxXQUFXLElBQUksR0FBRyxDQUFDO0FBQ3ZCLEVBQUUsSUFBSSxDQUFDLFNBQVMsSUFBSSxHQUFHLENBQUM7QUFDeEIsRUFBRSxJQUFJLENBQUMsU0FBUyxJQUFJLEdBQUcsQ0FBQztBQUN4QixFQUFFLENBQUMsQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDO0FBQ25CLEVBQUUsSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLENBQUMsRUFBRTtBQUN2QixJQUFJLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBQ3RCLEdBQUc7QUFDSCxDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0EsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLEtBQUs7QUFDdEMsRUFBRSxlQUFlLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2xHLEVBQUUsQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQzdCLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4QixDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0EsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLO0FBQzNCLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDakMsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDaEQsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDeEMsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxRQUFRLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLEtBQUs7QUFDN0M7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7QUFDMUI7QUFDQSxFQUFFLElBQUksR0FBRyxHQUFHLElBQUksRUFBRSxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRTtBQUNqQyxFQUFFLElBQUksR0FBRyxLQUFLLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEVBQUU7QUFDOUI7QUFDQSxFQUFFLElBQUksQ0FBQyxRQUFRLElBQUksR0FBRyxDQUFDO0FBQ3ZCO0FBQ0E7QUFDQSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3hFLEVBQUUsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7QUFDN0IsSUFBSSxJQUFJLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDeEQsR0FBRztBQUNIO0FBQ0EsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtBQUNsQyxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUN0RCxHQUFHO0FBQ0g7QUFDQSxFQUFFLElBQUksQ0FBQyxPQUFPLElBQUksR0FBRyxDQUFDO0FBQ3RCLEVBQUUsSUFBSSxDQUFDLFFBQVEsSUFBSSxHQUFHLENBQUM7QUFDdkI7QUFDQSxFQUFFLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sYUFBYSxHQUFHLENBQUMsQ0FBQyxFQUFFLFNBQVMsS0FBSztBQUN4QztBQUNBLEVBQUUsSUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDLGdCQUFnQixDQUFDO0FBQ3hDLEVBQUUsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQztBQUN4QixFQUFFLElBQUksS0FBSyxDQUFDO0FBQ1osRUFBRSxJQUFJLEdBQUcsQ0FBQztBQUNWLEVBQUUsSUFBSSxRQUFRLEdBQUcsQ0FBQyxDQUFDLFdBQVcsQ0FBQztBQUMvQixFQUFFLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUM7QUFDaEMsRUFBRSxNQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLE1BQU0sR0FBRyxhQUFhLENBQUM7QUFDeEQsTUFBTSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxRQUFRO0FBQ3pEO0FBQ0EsRUFBRSxNQUFNLElBQUksR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3hCO0FBQ0EsRUFBRSxNQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3pCLEVBQUUsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQztBQUN4QyxFQUFFLElBQUksU0FBUyxJQUFJLElBQUksQ0FBQyxJQUFJLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzdDLEVBQUUsSUFBSSxRQUFRLEtBQUssSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxDQUFDLENBQUMsV0FBVyxJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUU7QUFDckMsSUFBSSxZQUFZLEtBQUssQ0FBQyxDQUFDO0FBQ3ZCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEVBQUUsR0FBRztBQUNMO0FBQ0EsSUFBSSxLQUFLLEdBQUcsU0FBUyxDQUFDO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLFNBQVMsUUFBUTtBQUMvQyxRQUFRLElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQyxLQUFLLFNBQVM7QUFDaEQsUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLG9CQUFvQixJQUFJLENBQUMsSUFBSSxDQUFDO0FBQ2pELFFBQVEsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLGtCQUFrQixJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ3ZELE1BQU0sU0FBUztBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQztBQUNkLElBQUksS0FBSyxFQUFFLENBQUM7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxHQUFHO0FBQ1A7QUFDQSxLQUFLLFFBQVEsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDO0FBQzdFLGFBQWEsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDO0FBQzdFLGFBQWEsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDO0FBQzdFLGFBQWEsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDO0FBQzdFLGFBQWEsSUFBSSxHQUFHLE1BQU0sRUFBRTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJLEdBQUcsR0FBRyxTQUFTLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3RDLElBQUksSUFBSSxHQUFHLE1BQU0sR0FBRyxTQUFTLENBQUM7QUFDOUI7QUFDQSxJQUFJLElBQUksR0FBRyxHQUFHLFFBQVEsRUFBRTtBQUN4QixNQUFNLENBQUMsQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUFDO0FBQ2hDLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQztBQUNyQixNQUFNLElBQUksR0FBRyxJQUFJLFVBQVUsRUFBRTtBQUM3QixRQUFRLE1BQU07QUFDZCxPQUFPO0FBQ1AsTUFBTSxTQUFTLElBQUksSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDN0MsTUFBTSxRQUFRLEtBQUssSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQztBQUN6QyxLQUFLO0FBQ0wsR0FBRyxRQUFRLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLElBQUksS0FBSyxJQUFJLEVBQUUsWUFBWSxLQUFLLENBQUMsRUFBRTtBQUNsRjtBQUNBLEVBQUUsSUFBSSxRQUFRLElBQUksQ0FBQyxDQUFDLFNBQVMsRUFBRTtBQUMvQixJQUFJLE9BQU8sUUFBUSxDQUFDO0FBQ3BCLEdBQUc7QUFDSCxFQUFFLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUNyQixDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQUMsS0FBSztBQUMzQjtBQUNBLEVBQUUsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUMzQixFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxFQUFFLEdBQUc7QUFDTCxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLFFBQVEsQ0FBQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLE9BQU8sSUFBSSxPQUFPLEdBQUcsYUFBYSxDQUFDLEVBQUU7QUFDM0Q7QUFDQSxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxPQUFPLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDckUsTUFBTSxDQUFDLENBQUMsV0FBVyxJQUFJLE9BQU8sQ0FBQztBQUMvQixNQUFNLENBQUMsQ0FBQyxRQUFRLElBQUksT0FBTyxDQUFDO0FBQzVCO0FBQ0EsTUFBTSxDQUFDLENBQUMsV0FBVyxJQUFJLE9BQU8sQ0FBQztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUN0QixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDWjtBQUNBLE1BQU0sR0FBRztBQUNULFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUN4QixRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLE9BQU8sR0FBRyxDQUFDLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3JELE9BQU8sUUFBUSxFQUFFLENBQUMsRUFBRTtBQUNwQjtBQUNBLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQztBQUNsQixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDWjtBQUNBLE1BQU0sR0FBRztBQUNULFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUN4QixRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLE9BQU8sR0FBRyxDQUFDLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE9BQU8sUUFBUSxFQUFFLENBQUMsRUFBRTtBQUNwQjtBQUNBLE1BQU0sSUFBSSxJQUFJLE9BQU8sQ0FBQztBQUN0QixLQUFLO0FBQ0wsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxLQUFLLENBQUMsRUFBRTtBQUMvQixNQUFNLE1BQU07QUFDWixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNuRSxJQUFJLENBQUMsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDO0FBQ3JCO0FBQ0E7QUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLFNBQVMsRUFBRTtBQUM3QyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDbEMsTUFBTSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDOUI7QUFDQTtBQUNBLE1BQU0sQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRTtBQUN2QjtBQUNBLFFBQVEsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEU7QUFDQSxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqRCxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUM5QixRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQ2QsUUFBUSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDbkIsUUFBUSxJQUFJLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxTQUFTLEVBQUU7QUFDaEQsVUFBVSxNQUFNO0FBQ2hCLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxRQUFRLENBQUMsQ0FBQyxTQUFTLEdBQUcsYUFBYSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxLQUFLLENBQUMsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxjQUFjLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxLQUFLO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLGNBQWMsR0FBRyxNQUFNLENBQUM7QUFDOUI7QUFDQSxFQUFFLElBQUksY0FBYyxHQUFHLENBQUMsQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLEVBQUU7QUFDL0MsSUFBSSxjQUFjLEdBQUcsQ0FBQyxDQUFDLGdCQUFnQixHQUFHLENBQUMsQ0FBQztBQUM1QyxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUUsU0FBUztBQUNYO0FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQyxTQUFTLElBQUksQ0FBQyxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyQixNQUFNLElBQUksQ0FBQyxDQUFDLFNBQVMsS0FBSyxDQUFDLElBQUksS0FBSyxLQUFLLFlBQVksRUFBRTtBQUN2RCxRQUFRLE9BQU8sWUFBWSxDQUFDO0FBQzVCLE9BQU87QUFDUDtBQUNBLE1BQU0sSUFBSSxDQUFDLENBQUMsU0FBUyxLQUFLLENBQUMsRUFBRTtBQUM3QixRQUFRLE1BQU07QUFDZCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDOUIsSUFBSSxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztBQUNwQjtBQUNBO0FBQ0EsSUFBSSxNQUFNLFNBQVMsR0FBRyxDQUFDLENBQUMsV0FBVyxHQUFHLGNBQWMsQ0FBQztBQUNyRDtBQUNBLElBQUksSUFBSSxDQUFDLENBQUMsUUFBUSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLFNBQVMsRUFBRTtBQUNyRDtBQUNBLE1BQU0sQ0FBQyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQztBQUMzQyxNQUFNLENBQUMsQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO0FBQzdCO0FBQ0EsTUFBTSxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDakMsTUFBTSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxLQUFLLENBQUMsRUFBRTtBQUNsQyxRQUFRLE9BQU8sWUFBWSxDQUFDO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLENBQUMsTUFBTSxHQUFHLGFBQWEsQ0FBQyxFQUFFO0FBQ2xFO0FBQ0EsTUFBTSxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDakMsTUFBTSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxLQUFLLENBQUMsRUFBRTtBQUNsQyxRQUFRLE9BQU8sWUFBWSxDQUFDO0FBQzVCLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ2Y7QUFDQSxFQUFFLElBQUksS0FBSyxLQUFLLFVBQVUsRUFBRTtBQUM1QjtBQUNBLElBQUksZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzlCLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLEVBQUU7QUFDaEMsTUFBTSxPQUFPLGlCQUFpQixDQUFDO0FBQy9CLEtBQUs7QUFDTDtBQUNBLElBQUksT0FBTyxjQUFjLENBQUM7QUFDMUIsR0FBRztBQUNIO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRTtBQUNsQztBQUNBLElBQUksZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQy9CLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLEVBQUU7QUFDaEMsTUFBTSxPQUFPLFlBQVksQ0FBQztBQUMxQixLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLE9BQU8sWUFBWSxDQUFDO0FBQ3RCLENBQUMsQ0FBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVksR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLEtBQUs7QUFDbkM7QUFDQSxFQUFFLElBQUksU0FBUyxDQUFDO0FBQ2hCLEVBQUUsSUFBSSxNQUFNLENBQUM7QUFDYjtBQUNBLEVBQUUsU0FBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUksQ0FBQyxDQUFDLFNBQVMsR0FBRyxhQUFhLEVBQUU7QUFDckMsTUFBTSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckIsTUFBTSxJQUFJLENBQUMsQ0FBQyxTQUFTLEdBQUcsYUFBYSxJQUFJLEtBQUssS0FBSyxZQUFZLEVBQUU7QUFDakUsUUFBUSxPQUFPLFlBQVksQ0FBQztBQUM1QixPQUFPO0FBQ1AsTUFBTSxJQUFJLENBQUMsQ0FBQyxTQUFTLEtBQUssQ0FBQyxFQUFFO0FBQzdCLFFBQVEsTUFBTTtBQUNkLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsR0FBRyxDQUFDLFFBQVE7QUFDekIsSUFBSSxJQUFJLENBQUMsQ0FBQyxTQUFTLElBQUksU0FBUyxFQUFFO0FBQ2xDO0FBQ0EsTUFBTSxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkUsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNsRSxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDbkM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUksU0FBUyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsU0FBUyxNQUFNLENBQUMsQ0FBQyxNQUFNLEdBQUcsYUFBYSxDQUFDLENBQUMsRUFBRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxDQUFDLFlBQVksR0FBRyxhQUFhLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ25EO0FBQ0EsS0FBSztBQUNMLElBQUksSUFBSSxDQUFDLENBQUMsWUFBWSxJQUFJLFNBQVMsRUFBRTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDLENBQUM7QUFDcEY7QUFDQSxNQUFNLENBQUMsQ0FBQyxTQUFTLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSSxDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQyxjQUFjLHlCQUF5QixDQUFDLENBQUMsU0FBUyxJQUFJLFNBQVMsRUFBRTtBQUMvRixRQUFRLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUN6QixRQUFRLEdBQUc7QUFDWCxVQUFVLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUN2QjtBQUNBLFVBQVUsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNFLFVBQVUsU0FBUyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdEUsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRLEVBQUUsQ0FBQyxDQUFDLFlBQVksS0FBSyxDQUFDLEVBQUU7QUFDekMsUUFBUSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDckIsT0FBTztBQUNQLE1BQU07QUFDTixRQUFRLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQztBQUNyQyxRQUFRLENBQUMsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO0FBQzNCLFFBQVEsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUN2QztBQUNBLFFBQVEsQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSyxNQUFNO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLENBQUMsRUFBRSxD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R0FBRyxTQUFTLENBQUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUFDLENBQUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FBQyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztBQUN2QyxNQUFNLENBQUMsQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDO0FBQ3pCLE1BQU0sR0FBRztBQUNULFFBQVEsSUFBSSxFQUFFLENBQUMsQ0FBQyxRQUFRLElBQUksVUFBVSxFQUFFO0FBQ3hDO0FBQ0EsVUFBVSxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0UsVUFBVSxTQUFTLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN0RSxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDdkM7QUFDQSxTQUFTO0FBQ1QsT0FBTyxRQUFRLEVBQUUsQ0FBQyxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUU7QUFDdEMsTUFBTSxDQUFDLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQztBQUM1QixNQUFNLENBQUMsQ0FBQyxZQUFZLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQztBQUNyQyxNQUFNLENBQUMsQ0FBQyxRQUFR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RUFBRSxFQUFFLEVBQUUsWUFBWSxDQUFDO0FBQ3hDO0FBQ0EsRUFBRSxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsWUFBWSxDQUFDO0FBQ3hDLEVBQUUsSUFBSSxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFlBQVksQ0FBQztBQUN6QyxFQUFFLElBQUksTUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxZQUFZLENBQUM7QUFDM0MsRUFBRSxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsWUFBWSxDQUFDO0FBQzNDLEVBQUUsSUFBSSxNQUFNLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLFlBQVksQ0FBQztBQUM5QyxFQUFFLElBQUksTUFBTSxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxZQUFZLENBQUM7QUFDOUMsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTyxHQUFHLENBQUMsQ0FBQyxLQUFLO0FBQ3ZCO0FBQ0EsRUFBRSxDQUFDLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQy9CO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDZjtBQUNBO0FBQ0E7QUFDQSxFQUFFLENBQUMsQ0FBQyxjQUFjLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQztBQUMzRCxFQUFFLENBQUMsQ0FBQyxVQUFVLEdBQUcsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsQ0FBQztBQUMxRCxFQUFFLENBQUMsQ0FBQyxVQUFVLEdBQUcsbUJBQW1CLENBQUMsQ0FB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LEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDakIsRUFBRSxDQUFDLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNoQjtBQUNBLEVBQUUsQ0FBQyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDaEIsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztBQUNsQixFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDO0FBQ3hCLEVBQUUsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUMzQixFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDMUI7QUFDQSxFQUFFLENBQUMsQ0FBQyxTQUFTLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQztBQUM3QixFQUFFLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDakMsRUFBRSxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBQ2hDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxHQUFHLFNBQVMsR0FBRyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUM7QUFDL0Q7QUFDQSxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztBQUMxQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3hDLEVBQUUsQ0FBQyxDQUFDLElBQUksR0FBRyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxLQUFLLFFBQVEs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QUFJLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDMUMsUUFBUSxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO0FBQ2pELFFBQVEsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQztBQUNsRCxRQUFRLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLENBQUM7QUFDbEQsUUFBUSxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxHQUFHLENBQUM7QUFDckMscUJBQXFCLENBQUMsQ0FBQyxRQUFRLElBQUksY0FBYyxJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQztBQUNoRSxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0IsUUFBUSxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3hDLFFBQVEsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7QUFDckQsVUFBVSxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQztBQUNwRCxVQUFVLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO0FBQzNELFNBQVM7QUFDVCxRQUFRLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUU7QUFDM0IsVUFBVSxJQUFJLENBQUMs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LENBQUMsRUFBRTtBQUNwQixJQUFJLFFBQVEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQztBQUNuQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztBQUMxQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQztBQUMzQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQztBQUMzQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUN0QyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztBQUM3QyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQztBQUM5QyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQztBQUM5QyxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0YsSUFBSSxXQUFXLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEtBQUssRUFBRSxDQUFDLENBQUM7QUFDdEMsSUFBSSxXQUFXLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUM7QUFDeEMsR0FBRztBQUNIO0FBQ0EsRUFBRSxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLEVB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aEUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDNUQsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQUNBLE1BQU0sS0FBSyxHQUFHLElBQUksV0FBVyxDQUFDO0FBQzlCLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMzRCxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUk7QUFDeEQsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFDakMsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQUNBLE1BQU0sSUFBSSxHQUFHLElBQUksVUFBVSxDQUFDO0FBQzVCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUNoRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDeEMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDeEIsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQUNBLE1BQU0sYUFBYSxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLElBQUk7QUFDcEY7QUFDQSxFQUFFLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDekI7QUFDQTtBQUNBLEVBQUUsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ2QsRUFBRSxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDZCxFQUFFLElBQUksR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLEVBQUUsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsRUFBRSxJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7QUFDZixFQUFFLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNmLEVBQUUsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsRUFBRSxJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7QUFDZixFQUFFLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNmLEVBQUUsSUFBSSxJQUFJLENBQUM7QUFDWCxFQUFFLElBQUksSUFBSSxDQUFDO0FBQ1gsRUFBRSxJQUFJLEdBQUcsQ0FBQztBQUNWLEVBQUUsSUFBSSxJQUFJLENBQUM7QUFDWCxFQUFFLElBQUksSUFBSSxDQUFDO0FBQ1gsRUFBRSxJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7QUFDbEIsRUFBRSxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7QUFDckI7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDO0FBQ1YsRUFBRSxNQUFNLEtBQUssR0FBRyxJQUFJLFdBQVcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDN0MsRUFBRSxNQUFNLElBQUksR0FBRyxJQUFJLFdBQVcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDNUMsRUFBRSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDbkIsRUFBRSxJQUFJLFdBQVcsR0FBRyxDQUFDLENBQUM7QUFDdEI7QUFDQSxFQUFFLElBQUksU0FBUyxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUFLLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJLE9BQU8sRUFBRSxHQUFHLEVBQUUsRUFBRTtBQUN2QyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbkIsR0FBRztBQUNILEVBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDcEMsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDcEMsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxJQUFJLENBQUM7QUFDZCxFQUFFLEtBQUssR0FBRyxHQUFHLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ3ZDLElBQUksSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFO0FBQ3BDLEdBQUc7QUFDSCxFQUFFLElBQUksSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUNsQixJQUFJLElBQUksR0FBRyxHQUFHLENBQUM7QUFDZixHQUFHO0FBQ0gsRUFBRSxJQUFJLEdBQUcsS0FBSyxDQUFDLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN0RDtBQUNBLElBQUksSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7QUFDbEIsSUFBSSxPQUFPLENBQUMsQ0FBQztBQUNiLEdBQUc7QUFDSCxFQUFFLEtBQUssR0FBRyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQ2xDLElBQUksSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFO0FBQ3BDLEdBQUc7QUFDSCxFQUFFLElBQUksSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUNsQixJQUFJLElBQUksR0FBRyxHQUFHLENBQUM7QUFDZixHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNYLEVBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsSUFBSSxPQUFPLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDdkMsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDO0FBQ2YsSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZCLElBQUksSUFBSSxJQUFJLEdBQUcsQ0FBQyxFQUFFO0FBQ2xCLE1BQU0sT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNoQixLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUUsSUFBSSxJQUFJLEdBQUcsQ0FBQyxLQUFLLElBQUksS0FBSyxPQUFPLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxFQUFFO0FBQ25ELElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNkLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2QsRUFBRSxLQUFLLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLE9BQU8sRUFBRSxHQUFHLEVBQUUsRUFBRTtBQUN0QyxJQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMzQyxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDcEMsSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ3RDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNqRCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksSUFBSSxLQUFLLE9BQU8sRUFBRTtBQUN4QixJQUFJLElBQUksR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNiO0FBQ0EsR0FBRyxNQUFNLElBQUksSUFBSSxLQUFLLE1BQU0sRUFBRTtBQUM5QixJQUFJLElBQUksR0FBRyxLQUFLLENBQUM7QUFDakIsSUFBSSxVQUFVLElBQUksR0FBRyxDQUFDO0FBQ3RCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQztBQUNqQixJQUFJLFdBQVcsSUFBSSxHQUFHLENBQUM7QUFDdkIsSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ2Q7QUFDQSxHQUFHLE1BQU07QUFDVCxJQUFJLElBQUksR0FBRyxLQUFLLENBQUM7QUFDakIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7QUFDWCxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDVixFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDWixFQUFFLElBQUksR0FBRyxXQUFXLENBQUM7QUFDckIsRUFBRSxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2QsRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ1gsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDWCxFQUFFLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDO0FBQ25CLEVBQUUsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLENBQUM7QUFDbEI7QUFDQTtBQUNBLEVBQUUsSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksSUFBSSxHQUFHLGFBQWE7QUFDOUMsS0FBSyxJQUFJLEtBQUssT0FBTyxJQUFJLElBQUksR0FBRyxjQUFjLENBQUMsRUFBRTtBQUNqRCxJQUFJLE9BQU8sQ0FBQyxDQUFDO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLFNBQVM7QUFDWDtBQUNBLElBQUksU0FBUyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUM7QUFDM0IsSUFBSSxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEVBQUU7QUFDekIsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBQ2xCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMzQixLQUFLO0FBQ0wsU0FBUyxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEVBQUU7QUFDOUIsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUMvQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzlDLEtBQUs7QUFDTCxTQUFTO0FBQ1QsTUFBTSxPQUFPLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUN4QixNQUFNLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLElBQUksR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQzdCLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDckIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ2YsSUFBSSxHQUFHO0FBQ1AsTUFBTSxJQUFJLElBQUksSUFBSSxDQUFDO0FBQ25CLE1BQU0sS0FBSyxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLElBQUksRUFBRSxLQUFLLE9BQU8sSUFBSSxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0FBQzlGLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxFQUFFO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLElBQUksR0FBRyxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzFCLElBQUksT0FBTyxJQUFJLEdBQUcsSUFBSSxFQUFFO0FBQ3hCLE1BQU0sSUFBSSxLQUFLLENBQUMsQ0FBQztBQUNqQixLQUFLO0FBQ0wsSUFBSSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7QUFDcEIsTUFBTSxJQUFJLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztBQUN2QixNQUFNLElBQUksSUFBSSxJQUFJLENBQUM7QUFDbkIsS0FBSyxNQUFNO0FBQ1gsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ1YsSUFBSSxJQUFJLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtBQUM1QixNQUFNLElBQUksR0FBRyxLQUFLLEdBQUcsRUFBRSxFQUFFLE1BQU0sRUFBRTtBQUNqQyxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSxJQUFJLEdBQUcsR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxNQUFNLEdBQUcsRUFBRTtBQUM3QztBQUNBLE1BQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO0FBQ3RCLFFBQVEsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNwQixPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU0sSUFBSSxJQUFJLEdBQUcsQ0FBQztBQUNsQjtBQUNBO0FBQ0EsTUFBTSxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQztBQUN4QixNQUFNLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDO0FBQ3ZCLE1BQU0sT0FBTyxJQUFJLEdBQUcsSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUNoQyxRQUFRLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ25DLFFBQVEsSUFBSSxJQUFJLElBQUksQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFO0FBQ2pDLFFBQVEsSUFBSSxFQUFFLENBQUM7QUFDZixRQUFRLElBQUksS0FBSyxDQUFDLENBQUM7QUFDbkIsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDO0FBQ3hCLE1BQU0sSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLElBQUksSUFBSSxHQUFHLGFBQWE7QUFDbEQsU0FBUyxJQUFJLEtBQUssT0FBTyxJQUFJLElBQUksR0FBRyxjQUFjLENBQUMsRUFBRTtBQUNyRCxRQUFRLE9BQU8sQ0FBQyxDQUFDO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxFQUFFLEtBQUssSUFBSSxJQUFJLEVBQUUsQ0FBQyxJQUFJLElBQUksR0FBRyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDekUsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUM5RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNuQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBLElBQUksUUFBUSxHQUFHLGFBQWEsQ0FBQztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNoQixNQUFNLElBQUksR0FBRyxDQUFDLENBQUM7QUFDZixNQUFNLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxPQUFPO0FBQ3hDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLFdBQVcsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsV0FBVyxFQUFFLGFBQWEsRUFBRSxXQUFXO0FBQ2pMLEVBQUUsVUFBVTtBQUNaLENBQUMsR0FBRyxXQUFXLENBQUM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2xCLFNBQVMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNuQixTQUFTLElBQUksR0FBRyxDQUFDLENBQUM7QUFDbEIsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ2hCLFNBQVMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNuQixTQUFTLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDbkIsU0FBUyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2xCLFNBQVMsT0FBTyxHQUFHLENBQUMsQ0FBQztBQUNyQixTQUFTLElBQUksR0FBRyxDQUFDLENBQUM7QUFDbEIsU0FBUyxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ3JCLFNBQVMsSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUNuQixhQUFhLElBQUksR0FBRyxFQUFFLENBQUM7QUFDdkIsYUFBYSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ3pCLGFBQWEsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUN6QixhQUFhLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDeEIsYUFBYSxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLGFBQWEsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUN4QixhQUFhLE9BQU8sR0FBRyxFQUFFLENBQUM7QUFDMUIsYUFBYSxRQUFRLEdBQUcsRUFBRSxDQUFDO0FBQzNCLGlCQUFpQixJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQzNCLGlCQUFpQixHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQzFCLGlCQUFpQixNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQzdCLGlCQUFpQixJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQzNCLGlCQUFpQixPQUFPLEdBQUcsRUFBRSxDQUFDO0FBQzlCLGlCQUFpQixLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQzVCLGlCQUFpQixHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQzFCLFNBQVMsS0FBSyxHQUFHLEVBQUUsQ0FBQztBQUNwQixTQUFTLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDckIsU0FBUyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25CLFNBQVMsR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNsQixTQUFTLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDbEIsU0FBUyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsR0FBRyxHQUFHLENBQUM7QUFDeEIsTUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDO0FBQ3pCO0FBQ0E7QUFDQSxNQUFNLFNBQVMsR0FBRyxFQUFFLENBQUM7QUFDckI7QUFDQSxNQUFNLFNBQVMsR0FBRyxTQUFTLENBQUM7QUFDNUI7QUFDQTtBQUNBLE1BQU0sT0FBTyxHQUFHLENBQUMsQ0FBQyxLQUFLO0FBQ3ZCO0FBQ0EsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLElBQUk7QUFDN0IsV0FBVyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDO0FBQzlCLFdBQVcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxLQUFLLENBQUMsQ0FBQztBQUM3QixXQUFXLENBQUMsQ0FBQyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUMsRUFBRTtBQUM5QixDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0EsU0FBUyxZQUFZLEdBQUc7QUFDeEIsRUFBRSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNoQixFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDO0FBQ3BCLEVBQUUsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7QUFDaEIsRUFBRSxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztBQUN4QixFQUFFLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ2pCLEVBQUUsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7QUFDaEIsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNqQixFQUFFLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ2pCO0FBQ0EsRUFBRSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNuQjtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNqQixFQUFFLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ2pCLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDakIsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNqQixFQUFFLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ3JCO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2hCLEVBQUUsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7QUFDaEI7QUFDQTtBQUNBLEVBQUUsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDbEIsRUFBRSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNsQjtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNqQjtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUN0QixFQUFFLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3ZCLEVBQUUsSUFBSSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFDbkIsRUFBRSxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztBQUNwQjtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNqQixFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2hCLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDakIsRUFBRSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNoQixFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ25CO0FBQ0EsRUFBRSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25DLEVBQUUsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLEVBQUUsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDdEIsRUFBRSxJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNoQixFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2hCLEVBQUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDZixDQUFDO0FBQ0Q7QUFDQTtBQUNBLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxJQUFJLEtBQUs7QUFDbkM7QUFDQSxFQUFFLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUUsT0FBTyxnQkFBZ0IsQ0FBQyxFQUFFO0FBQ3hELEVBQUUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUMzQixFQUFFLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNuRCxFQUFFLElBQUksQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2hCLEVBQUUsSUFBSSxLQUFLLENBQUMsSUFBSSxFQUFFO0FBQ2xCLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNoQyxHQUFHO0FBQ0gsRUFBRSxLQUFLLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNwQixFQUFFLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2pCLEVBQUUsS0FBSyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFDckIsRUFBRSxLQUFLLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztBQUNyQixFQUFFLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxXQUFXO0FBQzlCLEVBQUUsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7QUFDakIsRUFBRSxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNqQjtBQUNBLEVBQUUsS0FBSyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzdELEVBQUUsS0FBSyxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ2hFO0FBQ0EsRUFBRSxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNqQixFQUFFLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbEI7QUFDQSxFQUFFLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMsQ0FBQztBQUNGO0FBQ0E7QUFDQSxNQUFNLFlBQVksR0FBRyxDQUFDLElBQUksS0FBSztBQUMvQjtBQUNBLEVBQUUsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsRUFBRSxPQUFPLGdCQUFnQixDQUFDLEVBQUU7QUFDeEQsRUFBRSxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQzNCLEVBQUUsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDbEIsRUFBRSxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUNsQixFQUFFLEtBQUssQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ2xCLEVBQUUsT0FBTyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoQztBQUNBLENBQUMsQ0FBQztBQUNGO0FBQ0E7QUFDQSxNQUFNLGFBQWEsR0FBRyxDQUFDLElBQUksRUFBRSxVQUFVLEtBQUs7QUFDNUMsRUFBRSxJQUFJLElBQUksQ0FBQztBQUNYO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUUsT0FBTyxnQkFBZ0IsQ0FBQyxFQUFFO0FBQ3hELEVBQUUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUMzQjtBQUNBO0FBQ0EsRUFBRSxJQUFJLFVBQVUsR0FBRyxDQUFDLEVBQUU7QUFDdEIsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0FBQ2IsSUFBSSxVQUFVLEdBQUcsQ0FBQyxVQUFVLENBQUM7QUFDN0IsR0FBRztBQUNILE9BQU87QUFDUCxJQUFJLElBQUksR0FBRyxDQUFDLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLElBQUksSUFBSSxVQUFVLEdBQUcsRUFBRSxFQUFFO0FBQ3pCLE1BQU0sVUFBVSxJQUFJLEVBQUUsQ0FBQztBQUN2QixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLElBQUksVUFBVSxLQUFLLFVBQVUsR0FBRyxDQUFDLElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQyxFQUFFO0FBQ3pELElBQUksT0FBTyxnQkFBZ0IsQ0FBQztBQUM1QixHQUFHO0FBQ0gsRUFBRSxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSSxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssVUFBVSxFQUFFO0FBQzNELElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7QUFDeEIsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLEVBQUUsS0FBSyxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUM7QUFDM0IsRUFBRSxPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM1QixDQUFDLENBQUM7QUFDRjtBQUNBO0FBQ0EsTUFBTSxZQUFZLEdBQUcsQ0FBQyxJQUFJLEVBQUUsVUFBVSxLQUFLO0FBQzNDO0FBQ0EsRUFBRSxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsT0FBTyxnQkFBZ0IsQ0FBQyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQSxFQUFFLE1BQU0sS0FBSyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztBQUNyQixFQUFFLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxXQUFXO0FBQ2hDLEVBQUUsTUFBTSxHQUFHLEdBQUcsYUFBYSxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztBQUM5QyxFQUFFLElBQUksR0FBRyxLQUFLLE1BQU0sRUFBRTtBQUN0QixJQUFJLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxXQUFXO0FBQ2hDLEdBQUc7QUFDSCxFQUFFLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBLE1BQU0sV0FBVyxHQUFHLENBQUMsSUFBSSxLQUFLO0FBQzlCO0FBQ0EsRUFBRSxPQUFPLFlBQVksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDdkMsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ2xCO0FBQ0EsSUFBSSxNQUFNLEVBQUUsT0FBTyxDQUFDO0FBQ3BCO0FBQ0E7QUFDQSxNQUFNLFdBQVcsR0FBRyxDQUFDLEtBQUssS0FBSztBQUMvQjtBQUNBO0FBQ0EsRUFBRSxJQUFJLE1BQU0sRUFBRTtBQUNkLElBQUksTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2pDLElBQUksT0FBTyxHQUFHLElBQUksVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNoQixJQUFJLE9BQU8sR0FBRyxHQUFHLEdBQUcsRUFBRSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUNoRCxJQUFJLE9BQU8sR0FBRyxHQUFHLEdBQUcsRUFBRSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUNoRCxJQUFJLE9BQU8sR0FBRyxHQUFHLEdBQUcsRUFBRSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUNoRCxJQUFJLE9BQU8sR0FBRyxHQUFHLEdBQUcsRUFBRSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUNoRDtBQUNBLElBQUksUUFBUSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxJQUFJLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDOUU7QUFDQTtBQUNBLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNaLElBQUksT0FBTyxHQUFHLEdBQUcsRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQy9DO0FBQ0EsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVMsQ0FBQyxPQUFPLEVBQUU7QUFDNUIsRUFBRSxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDL0IsSUFBSSxTQUFTLEVBQUUsSUFBSSxHQUFHLEVBQUU7QUFDeEIsSUFBSSxVQUFVLEVBQUUsRUFBRTtBQUNsQixJQUFJLEVBQUUsRUFBRSxFQUFFO0FBQ1YsR0FBRyxFQUFFLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQztBQUNwQjtBQUNBLEVBQUUsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDLEVBQUU7QUFDakUsSUFBSSxHQUFHLENBQUMsVUFBVSxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQztBQUNyQyxJQUFJLElBQUksR0FBRyxDQUFDLFVBQVUsS0FBSyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7QUFDdkQsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsVUFBVSxH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USxFQUFFO0FBQ3RDLE1BQU0sSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN6QyxLQUFLLE1BQU07QUFDWCxNQUFNLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDdEQsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ25CLEVBQUUsSUFBSSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUM7QUFDcEIsRUFBRSxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQzNCLENBQUMsQ0FBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFO0FBQ25DLEVBQUUsTUFBTSxRQUFRLEdBQUcsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDMUM7QUFDQSxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkI7QUFDQTtBQUNBLEVBQUUsSUFBSSxRQUFRLENBQUMsR0FBRyxFQUFFLE1BQU0sUUFBUSxDQUFDLEdBQUcsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2pFO0FBQ0EsRUFBRSxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUM7QUFDekIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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
